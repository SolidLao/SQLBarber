{
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2'\n  AND mk.movie_id <= '2'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        379.9,
        379.11,
        377.08,
        9.4,
        8.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '887'\n  AND mk.movie_id <= '5258'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5122.81,
        5078.53,
        4479.66,
        232.79,
        83.46
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1091'\n  AND mk.movie_id <= '3871'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5008.77,
        4980.33,
        4479.66,
        145.9,
        55.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '963'\n  AND mk.movie_id <= '1069'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        839.7,
        837.85,
        833.08,
        10.7,
        7.76
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3834'\n  AND mk.movie_id <= '5009'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3841.42,
        3828.94,
        3796.93,
        26.69,
        5.4,
        5.39
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '918'\n  AND mk.movie_id <= '1025'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        839.7,
        837.85,
        833.08,
        10.7,
        7.76
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '591'\n  AND mk.movie_id <= '4664'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5101.87,
        5060.57,
        4479.66,
        216.96,
        78.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '818'\n  AND mk.movie_id <= '979'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1055.87,
        1053.47,
        1047.3,
        11.37,
        7.56
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1667'\n  AND mk.movie_id <= '2911'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3968.34,
        3955.18,
        3921.45,
        28.53,
        5.29,
        5.28
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '465'\n  AND mk.movie_id <= '2921'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4986.8,
        4961.58,
        4479.66,
        129.45,
        50.25
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2639'\n  AND mk.movie_id <= '3852'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3917.02,
        3904.16,
        3871.19,
        27.17,
        5.35,
        5.34
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '967'\n  AND mk.movie_id <= '4035'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5028.58,
        4997.27,
        4479.66,
        160.8,
        59.67
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '901'\n  AND mk.movie_id <= '3845'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5020.54,
        4990.45,
        4479.66,
        154.85,
        58.18
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '4739'\n  AND mk.movie_id <= '4948'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1237.95,
        1235.08,
        1227.7,
        11.95,
        7.41
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1400'\n  AND mk.movie_id <= '5258'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5087.62,
        5048.45,
        4479.66,
        206.36,
        76.24
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '64'\n  AND mk.movie_id <= '3842'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5081.37,
        5042.99,
        4479.66,
        201.46,
        74.28
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2071'\n  AND mk.movie_id <= '2079'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        418.5,
        417.63,
        415.38,
        9.5,
        8.12
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '327'\n  AND mk.movie_id <= '2040'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4515.49,
        4497.66,
        39.24,
        4.51,
        4.5
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '992'\n  AND mk.movie_id <= '1057'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        663.19,
        661.75,
        658.06,
        10.19,
        7.9
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1389'\n  AND mk.movie_id <= '1417'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        508.24,
        507.17,
        504.43,
        9.74,
        8.11
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '975'\n  AND mk.movie_id <= '1621'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2613.8,
        2606.59,
        2588.08,
        19.25,
        6.31,
        6.3
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '860'\n  AND mk.movie_id <= '5263'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5124.93,
        5080.34,
        4479.66,
        234.37,
        83.85
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '589'\n  AND mk.movie_id <= '4609'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5098.36,
        5057.59,
        4479.66,
        214.35,
        78.2
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '371'\n  AND mk.movie_id <= '4730'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5121.99,
        5077.83,
        4479.66,
        232.18,
        83.31
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '388'\n  AND mk.movie_id <= '4700'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5118.81,
        5075.13,
        4479.66,
        229.82,
        82.74
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '989'\n  AND mk.movie_id <= '1668'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2735.13,
        2727.58,
        2708.22,
        19.66,
        6.24
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '50'\n  AND mk.movie_id <= '3842'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5082.19,
        5043.69,
        4479.66,
        202.07,
        74.43
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '327'\n  AND mk.movie_id <= '936'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2542.27,
        2535.43,
        2517.87,
        18.8,
        6.39
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1400'\n  AND mk.movie_id <= '5225'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5084.4,
        5045.57,
        4479.66,
        203.71,
        74.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2071'\n  AND mk.movie_id <= '5264'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5041.76,
        5009.21,
        4479.66,
        171.84,
        66.19
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2070'\n  AND mk.movie_id <= '5266'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5041.99,
        5009.41,
        4479.66,
        172.02,
        66.23
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '941'\n  AND mk.movie_id <= '4436'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5061.65,
        5026.09,
        4479.66,
        186.58,
        69.85
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '945'\n  AND mk.movie_id <= '4316'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5053.43,
        5019.11,
        4479.66,
        180.48,
        68.34
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '387'\n  AND mk.movie_id <= '1070'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2744.17,
        2736.59,
        2717.14,
        19.7,
        6.23
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '399'\n  AND mk.movie_id <= '1070'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2690.27,
        2682.8,
        2663.62,
        19.58,
        6.26,
        6.25
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1046'\n  AND mk.movie_id <= '1557'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2256.59,
        2250.71,
        2235.63,
        16.63,
        6.6
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '582'\n  AND mk.movie_id <= '1063'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2167.76,
        2162.18,
        2147.83,
        16.26,
        6.68
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '468'\n  AND mk.movie_id <= '1062'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2498.1,
        2491.4,
        2474.2,
        18.63,
        6.41
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1760'\n  AND mk.movie_id <= '3680'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4742.27,
        4722.38,
        42.76,
        4.26,
        4.25
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1636'\n  AND mk.movie_id <= '3585'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4771.43,
        4751.25,
        43.1,
        4.23,
        4.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1140'\n  AND mk.movie_id <= '3916'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5008.54,
        4980.13,
        4479.66,
        145.73,
        55.13
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '334'\n  AND mk.movie_id <= '4734'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5124.69,
        5080.14,
        4479.66,
        234.2,
        83.8
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '818'\n  AND mk.movie_id <= '5226'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5125.28,
        5080.64,
        4479.66,
        234.63,
        83.91
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '4730'\n  AND mk.movie_id <= '4921'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1172.73,
        1170.04,
        1163.11,
        11.73,
        7.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '22'\n  AND mk.movie_id <= '908'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3220.04,
        3210.43,
        3185.76,
        22.19,
        5.85,
        5.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '4730'\n  AND mk.movie_id <= '4737'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        409.98,
        409.12,
        406.92,
        9.48,
        8.11
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '4730'\n  AND mk.movie_id <= '4731'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        388.42,
        387.61,
        385.54,
        9.42,
        8.18
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '818'\n  AND mk.movie_id <= '5265'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5127.87,
        5082.84,
        4479.66,
        236.56,
        84.38
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '984'\n  AND mk.movie_id <= '5006'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5098.48,
        5057.69,
        4479.66,
        214.43,
        78.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1158'\n  AND mk.movie_id <= '5226'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5101.52,
        5060.27,
        4479.66,
        216.7,
        78.78
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1158'\n  AND mk.movie_id <= '5258'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5103.74,
        5062.16,
        4479.66,
        218.35,
        79.18
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '591'\n  AND mk.movie_id <= '4665'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5101.99,
        5060.67,
        4479.66,
        217.04,
        78.86
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '388'\n  AND mk.movie_id <= '4665'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5116.47,
        5073.14,
        4479.66,
        228.07,
        82.31
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1335'\n  AND mk.movie_id <= '5229'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5089.95,
        5050.43,
        4479.66,
        208.09,
        76.67
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1057'\n  AND mk.movie_id <= '1551'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2203.38,
        2197.67,
        2183.04,
        16.41,
        6.65
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '50'\n  AND mk.movie_id <= '3837'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5081.95,
        5043.49,
        4479.66,
        201.9,
        74.39
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '909'\n  AND mk.movie_id <= '1051'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        982.13,
        979.93,
        974.26,
        11.13,
        7.64
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '106'\n  AND mk.movie_id <= '3837'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5078.23,
        5040.32,
        4479.66,
        199.13,
        73.71
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '587'\n  AND mk.movie_id <= '4658'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5101.75,
        5060.47,
        4479.66,
        216.87,
        78.82
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1547'\n  AND mk.movie_id <= '4039'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4989.18,
        4963.6,
        4479.66,
        131.21,
        50.7
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1545'\n  AND mk.movie_id <= '4119'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4995.41,
        4969.02,
        4479.66,
        136.06,
        52.68
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '907'\n  AND mk.movie_id <= '2627'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4521.9,
        4504.0,
        39.32,
        4.5,
        4.49
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '302'\n  AND mk.movie_id <= '582'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1499.8,
        1496.23,
        1487.05,
        13.8,
        7.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '302'\n  AND mk.movie_id <= '4731'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5126.69,
        5081.84,
        4479.66,
        235.68,
        84.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2685'\n  AND mk.movie_id <= '4921'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4972.65,
        4949.62,
        4479.66,
        119.05,
        47.58
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1045'\n  AND mk.movie_id <= '1049'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        405.46,
        404.62,
        402.46,
        9.46,
        8.19
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '334'\n  AND mk.movie_id <= '4731'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5124.46,
        5079.94,
        4479.66,
        234.02,
        83.76
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2599'\n  AND mk.movie_id <= '5226'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4998.83,
        4971.92,
        4479.66,
        138.58,
        53.32
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '723'\n  AND mk.movie_id <= '5192'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5129.28,
        5084.04,
        4479.66,
        237.61,
        84.63
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '595'\n  AND mk.movie_id <= '1023'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1996.12,
        1991.06,
        1978.06,
        15.62,
        6.79
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '723'\n  AND mk.movie_id <= '5267'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5135.34,
        5089.35,
        4479.66,
        242.38,
        86.55
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '813'\n  AND mk.movie_id <= '5267'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5128.34,
        5083.24,
        4479.66,
        236.91,
        84.46
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '818'\n  AND mk.movie_id <= '5225'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5125.16,
        5080.54,
        4479.66,
        234.55,
        83.89
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '596'\n  AND mk.movie_id <= '5225'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5141.0,
        5094.17,
        4479.66,
        246.6,
        87.57
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '357'\n  AND mk.movie_id <= '4496'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5106.32,
        5064.36,
        4479.66,
        220.27,
        79.65
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '118'\n  AND mk.movie_id <= '3800'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5074.97,
        5037.55,
        4479.66,
        196.71,
        73.11
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '69'\n  AND mk.movie_id <= '3834'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5080.44,
        5042.2,
        4479.66,
        200.77,
        74.11
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1015'\n  AND mk.movie_id <= '3864'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5013.34,
        4984.21,
        4479.66,
        149.28,
        56.03
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '24'\n  AND mk.movie_id <= '3841'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5083.93,
        5045.17,
        4479.66,
        203.37,
        74.75
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '302'\n  AND mk.movie_id <= '951'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2622.94,
        2615.7,
        2597.1,
        19.3,
        6.3,
        6.29
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '928'\n  AND mk.movie_id <= '3268'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4979.32,
        4955.25,
        4479.66,
        123.95,
        48.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '594'\n  AND mk.movie_id <= '5211'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5140.17,
        5093.46,
        4479.66,
        245.99,
        87.42
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '318'\n  AND mk.movie_id <= '1855'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4354.29,
        4338.21,
        4297.0,
        36.1,
        4.76,
        4.75
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '683'\n  AND mk.movie_id <= '5022'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5120.58,
        5076.63,
        4479.66,
        231.13,
        83.06
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '691'\n  AND mk.movie_id <= '5022'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5120.11,
        5076.23,
        4479.66,
        230.78,
        82.97
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '654'\n  AND mk.movie_id <= '5267'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5139.94,
        5093.26,
        4479.66,
        245.81,
        87.38
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '22'\n  AND mk.movie_id <= '3682'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5073.45,
        5036.27,
        4479.66,
        195.59,
        72.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '909'\n  AND mk.movie_id <= '1073'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1064.39,
        1061.97,
        1055.76,
        11.39,
        7.57
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '85'\n  AND mk.movie_id <= '4665'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5137.7,
        5091.36,
        4479.66,
        244.14,
        86.97
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3841'\n  AND mk.movie_id <= '5192'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4109.2,
        4094.98,
        4058.5,
        29.83,
        5.08,
        5.07
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1028'\n  AND mk.movie_id <= '2857'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4644.19,
        4625.2,
        40.65,
        4.36,
        4.35
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '647'\n  AND mk.movie_id <= '4700'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5100.58,
        5059.48,
        4479.66,
        216.0,
        78.61
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1024'\n  AND mk.movie_id <= '3191'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4987.25,
        4964.91,
        45.75,
        4.0,
        3.99
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '647'\n  AND mk.movie_id <= '4664'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5098.13,
        5057.39,
        4479.66,
        214.17,
        78.16
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '4440'\n  AND mk.movie_id <= '5266'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3082.26,
        3073.25,
        3050.11,
        21.46,
        5.97,
        5.96
    ]
}