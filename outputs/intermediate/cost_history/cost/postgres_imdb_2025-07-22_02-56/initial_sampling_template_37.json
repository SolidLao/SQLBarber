{
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '76'\n  AND cc.id <= '360'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '2'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '76'\n       AND mi2.info_type_id = '2')\nGROUP BY cc.status_id;": [
        266997.35,
        254710.14,
        254710.12,
        253709.92,
        253206.78,
        238982.96,
        2419.57,
        2419.57,
        12285.83,
        17.12,
        161.39
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '294'\n  AND cc.id <= '369'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '64'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '294'\n       AND mi2.info_type_id = '64')\nGROUP BY cc.status_id;": [
        32250.05,
        30268.63,
        30268.61,
        29268.41,
        29265.4,
        25885.27,
        87.56,
        1.01,
        1981.41,
        10.48,
        98.54,
        94.52,
        4.73,
        87.56
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '240'\n  AND cc.id <= '346'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '70'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '240'\n       AND mi2.info_type_id = '70')\nGROUP BY cc.status_id;": [
        26121.08,
        25611.2,
        25611.19,
        24610.99,
        24608.54,
        21524.2,
        72.48,
        1.14,
        509.86,
        11.31,
        83.08,
        79.07,
        4.73,
        72.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '143'\n  AND cc.id <= '487'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '1'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '143'\n       AND mi2.info_type_id = '1')\nGROUP BY cc.status_id;": [
        248881.61,
        245450.4,
        245450.38,
        244450.18,
        244139.13,
        233373.61,
        8899.91,
        2419.57,
        2419.57,
        3430.96,
        18.74,
        162.47
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '101'\n  AND cc.id <= '381'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '80'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '101'\n       AND mi2.info_type_id = '80')\nGROUP BY cc.status_id;": [
        39780.98,
        31786.41,
        31786.4,
        30786.2,
        30782.99,
        27304.68,
        95.26,
        0.98,
        7994.53,
        17.01,
        106.36,
        102.34,
        4.73,
        95.26
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '340'\n  AND cc.id <= '348'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '72'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '340'\n       AND mi2.info_type_id = '72')\nGROUP BY cc.status_id;": [
        20914.46,
        20770.52,
        20770.5,
        19770.3,
        19768.42,
        16979.57,
        57.39,
        1.34,
        143.93,
        8.67,
        67.62,
        63.6,
        4.73,
        57.39
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '29'\n  AND cc.id <= '374'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '110'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '29'\n       AND mi2.info_type_id = '110')\nGROUP BY cc.status_id;": [
        87646.56,
        84215.75,
        84187.34,
        78510.71,
        341.25,
        2419.57,
        2419.57,
        3430.77,
        18.77,
        162.47
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '315'\n  AND cc.id <= '321'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '88'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '315'\n       AND mi2.info_type_id = '88')\nGROUP BY cc.status_id;": [
        25786.01,
        25611.2,
        25611.19,
        24610.99,
        24608.54,
        21524.2,
        72.48,
        1.14,
        174.8,
        8.61,
        83.08,
        79.07,
        4.73,
        72.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '339'\n  AND cc.id <= '442'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '47'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '339'\n       AND mi2.info_type_id = '47')\nGROUP BY cc.status_id;": [
        31401.36,
        28737.81,
        28737.79,
        27737.59,
        27734.77,
        24452.79,
        83.87,
        1.05,
        2663.54,
        11.22,
        94.72,
        90.7,
        4.73,
        83.87
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '114'\n  AND cc.id <= '354'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '62'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '114'\n       AND mi2.info_type_id = '62')\nGROUP BY cc.status_id;": [
        26790.44,
        25611.21,
        25611.19,
        24610.99,
        24608.54,
        21524.2,
        72.48,
        1.14,
        1179.22,
        15.94,
        83.08,
        79.07,
        4.73,
        72.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '19'\n  AND cc.id <= '318'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '19'\n       AND mi2.info_type_id = '4')\nGROUP BY cc.status_id;": [
        266391.79,
        253465.29,
        253465.27,
        252465.07,
        251996.67,
        238400.03,
        13389.36,
        2419.57,
        2419.57,
        12925.15,
        17.53,
        161.32
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '237'\n  AND cc.id <= '401'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '86'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '237'\n       AND mi2.info_type_id = '86')\nGROUP BY cc.status_id;": [
        18001.14,
        17428.29,
        17428.27,
        16428.07,
        16426.56,
        13835.62,
        46.0,
        1.56,
        572.83,
        12.88,
        55.99,
        51.97,
        4.73,
        46.0
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '239'\n  AND cc.id <= '474'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '46'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '239'\n       AND mi2.info_type_id = '46')\nGROUP BY cc.status_id;": [
        26790.3,
        25611.2,
        25611.19,
        24610.99,
        24608.54,
        21524.2,
        72.48,
        1.14,
        1179.08,
        15.8,
        83.08,
        79.07,
        4.73,
        72.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '321'\n  AND cc.id <= '328'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '95'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '321'\n       AND mi2.info_type_id = '95')\nGROUP BY cc.status_id;": [
        13263.82,
        13174.08,
        13174.07,
        12173.97,
        12172.64,
        8931.96,
        30.91,
        2.22,
        89.72,
        8.64,
        40.53,
        36.52,
        4.73,
        30.91
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '26'\n  AND cc.id <= '31'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '91'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '26'\n       AND mi2.info_type_id = '91')\nGROUP BY cc.status_id;": [
        15822.41,
        15717.46,
        15717.44,
        14717.24,
        14715.92,
        12222.93,
        38.3,
        1.71,
        104.94,
        8.58,
        48.17,
        44.15,
        4.73,
        38.3
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '64'\n  AND cc.id <= '406'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '13'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '64'\n       AND mi2.info_type_id = '13')\nGROUP BY cc.status_id;": [
        245971.72,
        231131.95,
        231131.94,
        230131.74,
        230068.99,
        223775.83,
        1794.74,
        2419.57,
        2419.57,
        14839.54,
        18.69,
        161.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '184'\n  AND cc.id <= '298'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '42'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '184'\n       AND mi2.info_type_id = '42')\nGROUP BY cc.status_id;": [
        29886.82,
        27181.23,
        27181.21,
        26181.01,
        26178.37,
        22995.62,
        76.17,
        1.09,
        2705.57,
        11.53,
        86.89,
        82.88,
        4.73,
        76.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '82'\n  AND cc.id <= '143'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '57'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '82'\n       AND mi2.info_type_id = '57')\nGROUP BY cc.status_id;": [
        28668.72,
        27181.23,
        27181.21,
        26181.01,
        26178.37,
        22995.62,
        76.17,
        1.09,
        1487.48,
        10.1,
        86.89,
        82.88,
        4.73,
        76.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '35'\n  AND cc.id <= '150'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '62'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '35'\n       AND mi2.info_type_id = '62')\nGROUP BY cc.status_id;": [
        26204.42,
        25611.21,
        25611.19,
        24610.99,
        24608.54,
        21524.2,
        72.48,
        1.14,
        593.2,
        11.56,
        83.08,
        79.07,
        4.73,
        72.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '339'\n  AND cc.id <= '471'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '107'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '339'\n       AND mi2.info_type_id = '107')\nGROUP BY cc.status_id;": [
        228202.44,
        222351.31,
        222351.29,
        221351.09,
        221298.79,
        215197.2,
        1499.48,
        2419.57,
        2419.57,
        5851.04,
        12.02,
        162.19
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '206'\n  AND cc.id <= '438'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '105'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '206'\n       AND mi2.info_type_id = '105')\nGROUP BY cc.status_id;": [
        223797.56,
        213755.82,
        213755.8,
        212755.6,
        212710.0,
        206728.53,
        1306.45,
        2419.57,
        2419.57,
        10041.61,
        15.72,
        161.7
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '135'\n  AND cc.id <= '140'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '92'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '135'\n       AND mi2.info_type_id = '92')\nGROUP BY cc.status_id;": [
        22554.11,
        22402.61,
        22402.59,
        21402.39,
        21400.32,
        18513.41,
        61.09,
        1.26,
        151.49,
        8.58,
        71.44,
        67.43,
        4.73,
        61.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '221'\n  AND cc.id <= '362'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '35'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '221'\n       AND mi2.info_type_id = '35')\nGROUP BY cc.status_id;": [
        9732.9,
        9460.52,
        9460.5,
        8460.4,
        8459.6,
        5497.8,
        19.52,
        3.39,
        272.37,
        12.27,
        28.89,
        24.87,
        4.73,
        19.52
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '127'\n  AND cc.id <= '444'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '94'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '127'\n       AND mi2.info_type_id = '94')\nGROUP BY cc.status_id;": [
        146700.29,
        132977.66,
        132915.92,
        126640.89,
        738.72,
        2419.57,
        2419.57,
        13722.52,
        18.0,
        161.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '213'\n  AND cc.id <= '386'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '65'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '213'\n       AND mi2.info_type_id = '65')\nGROUP BY cc.status_id;": [
        25773.91,
        22402.61,
        22402.59,
        21402.39,
        21400.32,
        18513.41,
        61.09,
        1.26,
        3371.28,
        13.12,
        71.44,
        67.43,
        4.73,
        61.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '103'\n  AND cc.id <= '129'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '15'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '103'\n       AND mi2.info_type_id = '15')\nGROUP BY cc.status_id;": [
        241112.31,
        240777.4,
        240777.38,
        239777.18,
        239557.67,
        230440.75,
        6280.49,
        2419.57,
        2419.57,
        334.89,
        9.16,
        162.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '146'\n  AND cc.id <= '481'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '70'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '146'\n       AND mi2.info_type_id = '70')\nGROUP BY cc.status_id;": [
        33107.99,
        25611.21,
        25611.19,
        24610.99,
        24608.54,
        21524.2,
        72.48,
        1.14,
        7496.75,
        18.5,
        83.08,
        79.07,
        4.73,
        72.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '233'\n  AND cc.id <= '345'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '233'\n       AND mi2.info_type_id = '4')\nGROUP BY cc.status_id;": [
        258339.4,
        253457.02,
        253457.01,
        252456.81,
        251989.13,
        238400.03,
        13389.36,
        2419.57,
        2419.57,
        4881.86,
        11.47,
        162.32
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '26'\n  AND cc.id <= '379'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '8'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '26'\n       AND mi2.info_type_id = '8')\nGROUP BY cc.status_id;": [
        269933.76,
        254612.63,
        254612.61,
        253612.41,
        253114.35,
        238982.96,
        2419.57,
        2419.57,
        15319.43,
        18.99,
        161.02
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '81'\n  AND cc.id <= '244'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '84'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '81'\n       AND mi2.info_type_id = '84')\nGROUP BY cc.status_id;": [
        21459.68,
        20770.52,
        20770.51,
        19770.31,
        19768.42,
        16979.57,
        57.39,
        1.34,
        689.14,
        12.85,
        67.62,
        63.6,
        4.73,
        57.39
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '72'\n  AND cc.id <= '86'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '43'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '72'\n       AND mi2.info_type_id = '43')\nGROUP BY cc.status_id;": [
        25952.42,
        25611.21,
        25611.19,
        24610.99,
        24608.54,
        21524.2,
        72.48,
        1.14,
        341.2,
        8.83,
        83.08,
        79.07,
        4.73,
        72.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '116'\n  AND cc.id <= '431'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '8'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '116'\n       AND mi2.info_type_id = '8')\nGROUP BY cc.status_id;": [
        268336.44,
        254609.9,
        254609.88,
        253609.68,
        253111.95,
        238982.96,
        2419.57,
        2419.57,
        13725.02,
        17.95,
        161.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '116'\n  AND cc.id <= '220'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '73'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '116'\n       AND mi2.info_type_id = '73')\nGROUP BY cc.status_id;": [
        9100.51,
        8499.03,
        8498.12,
        3726.66,
        11.82,
        4.82,
        601.46,
        11.25,
        21.07,
        17.05,
        4.73,
        11.82
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '335'\n  AND cc.id <= '437'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '109'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '335'\n       AND mi2.info_type_id = '109')\nGROUP BY cc.status_id;": [
        9100.45,
        8499.03,
        8498.12,
        3726.66,
        11.82,
        4.82,
        601.41,
        11.2,
        21.07,
        17.05,
        4.73,
        11.82
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '175'\n  AND cc.id <= '209'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '109'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '175'\n       AND mi2.info_type_id = '109')\nGROUP BY cc.status_id;": [
        8550.56,
        8499.03,
        8498.12,
        3726.66,
        11.82,
        4.82,
        51.51,
        9.36,
        21.07,
        17.05,
        4.73,
        11.82
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '325'\n  AND cc.id <= '464'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '12'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '325'\n       AND mi2.info_type_id = '12')\nGROUP BY cc.status_id;": [
        48629.27,
        47314.23,
        47301.62,
        41916.07,
        151.91,
        2419.57,
        2419.57,
        1315.03,
        12.21,
        162.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '188'\n  AND cc.id <= '453'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '76'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '188'\n       AND mi2.info_type_id = '76')\nGROUP BY cc.status_id;": [
        20086.26,
        19112.58,
        19112.57,
        18112.37,
        18110.67,
        15420.21,
        49.7,
        1.44,
        973.66,
        16.6,
        59.81,
        55.79,
        4.73,
        49.7
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '224'\n  AND cc.id <= '461'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '1'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '224'\n       AND mi2.info_type_id = '1')\nGROUP BY cc.status_id;": [
        247742.6,
        245446.51,
        245446.49,
        244446.29,
        244135.42,
        233373.61,
        8899.91,
        2419.57,
        2419.57,
        2295.92,
        15.86,
        162.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '123'\n  AND cc.id <= '438'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '104'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '123'\n       AND mi2.info_type_id = '104')\nGROUP BY cc.status_id;": [
        97446.42,
        94338.2,
        94304.4,
        88531.8,
        405.6,
        2419.57,
        2419.57,
        3108.18,
        17.95,
        162.63
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '17'\n  AND cc.id <= '335'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '43'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '17'\n       AND mi2.info_type_id = '43')\nGROUP BY cc.status_id;": [
        27207.99,
        25611.21,
        25611.19,
        24610.99,
        24608.54,
        21524.2,
        72.48,
        1.14,
        1596.77,
        18.03,
        83.08,
        79.07,
        4.73,
        72.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '156'\n  AND cc.id <= '192'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '84'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '156'\n       AND mi2.info_type_id = '84')\nGROUP BY cc.status_id;": [
        21456.24,
        20770.52,
        20770.51,
        19770.31,
        19768.42,
        16979.57,
        57.39,
        1.34,
        685.71,
        9.41,
        67.62,
        63.6,
        4.73,
        57.39
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '328'\n  AND cc.id <= '448'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '97'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '328'\n       AND mi2.info_type_id = '97')\nGROUP BY cc.status_id;": [
        52156.6,
        51004.93,
        50990.97,
        45580.67,
        167.0,
        2419.57,
        2419.57,
        1151.65,
        11.69,
        162.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '44'\n  AND cc.id <= '88'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '96'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '44'\n       AND mi2.info_type_id = '96')\nGROUP BY cc.status_id;": [
        33621.06,
        33280.88,
        33280.86,
        32280.66,
        32277.27,
        28700.54,
        98.95,
        0.95,
        340.17,
        9.63,
        110.17,
        106.15,
        4.73,
        98.95
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '163'\n  AND cc.id <= '385'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '107'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '163'\n       AND mi2.info_type_id = '107')\nGROUP BY cc.status_id;": [
        224488.37,
        222355.81,
        222355.79,
        221355.59,
        221303.22,
        215197.2,
        1499.48,
        2419.57,
        2419.57,
        2132.51,
        15.44,
        162.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '121'\n  AND cc.id <= '307'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '66'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '121'\n       AND mi2.info_type_id = '66')\nGROUP BY cc.status_id;": [
        45794.92,
        39108.66,
        39108.64,
        38108.44,
        38104.3,
        34132.68,
        121.73,
        0.86,
        6686.24,
        13.48,
        133.45,
        129.43,
        4.73,
        121.73
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '18'\n  AND cc.id <= '273'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '17'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '18'\n       AND mi2.info_type_id = '17')\nGROUP BY cc.status_id;": [
        247939.27,
        236935.3,
        236935.28,
        235935.08,
        235790.78,
        228029.29,
        4126.59,
        2419.57,
        2419.57,
        11003.6,
        16.35,
        161.57
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '54'\n  AND cc.id <= '302'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '51'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '54'\n       AND mi2.info_type_id = '51')\nGROUP BY cc.status_id;": [
        33020.02,
        27181.23,
        27181.21,
        26181.01,
        26178.37,
        22995.62,
        76.17,
        1.09,
        5838.78,
        16.16,
        86.89,
        82.88,
        4.73,
        76.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '138'\n  AND cc.id <= '200'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '11'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '138'\n       AND mi2.info_type_id = '11')\nGROUP BY cc.status_id;": [
        54065.31,
        53403.77,
        53388.89,
        47957.65,
        178.38,
        2419.57,
        2419.57,
        661.53,
        10.13,
        162.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '394'\n  AND cc.id <= '449'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '106'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '394'\n       AND mi2.info_type_id = '106')\nGROUP BY cc.status_id;": [
        208771.52,
        206322.71,
        206322.7,
        205322.5,
        205281.45,
        199383.18,
        1177.75,
        2419.57,
        2419.57,
        2448.77,
        9.93,
        162.58
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '168'\n  AND cc.id <= '464'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '93'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '168'\n       AND mi2.info_type_id = '93')\nGROUP BY cc.status_id;": [
        11940.34,
        11333.91,
        11333.89,
        10333.79,
        10332.72,
        7231.42,
        23.22,
        2.66,
        606.42,
        17.45,
        32.71,
        28.7,
        4.73,
        23.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '51'\n  AND cc.id <= '137'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '97'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '51'\n       AND mi2.info_type_id = '97')\nGROUP BY cc.status_id;": [
        51835.5,
        51010.47,
        50996.48,
        45580.67,
        167.0,
        2419.57,
        2419.57,
        825.01,
        10.76,
        162.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '209'\n  AND cc.id <= '481'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '11'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '209'\n       AND mi2.info_type_id = '11')\nGROUP BY cc.status_id;": [
        56019.36,
        53400.87,
        53385.99,
        47957.65,
        178.38,
        2419.57,
        2419.57,
        2618.47,
        16.79,
        162.6
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '272'\n  AND cc.id <= '391'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '66'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '272'\n       AND mi2.info_type_id = '66')\nGROUP BY cc.status_id;": [
        40054.52,
        39108.66,
        39108.64,
        38108.44,
        38104.3,
        34132.68,
        121.73,
        0.86,
        945.85,
        11.67,
        133.45,
        129.43,
        4.73,
        121.73
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '282'\n  AND cc.id <= '463'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '81'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '282'\n       AND mi2.info_type_id = '81')\nGROUP BY cc.status_id;": [
        25917.03,
        22402.61,
        22402.59,
        21402.39,
        21400.32,
        18513.41,
        61.09,
        1.26,
        3514.4,
        13.34,
        71.44,
        67.43,
        4.73,
        61.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '22'\n  AND cc.id <= '94'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '16'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '22'\n       AND mi2.info_type_id = '16')\nGROUP BY cc.status_id;": [
        271038.88,
        267773.13,
        267773.11,
        266772.91,
        265582.12,
        238982.96,
        2419.57,
        2419.57,
        3264.89,
        10.4,
        162.64
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '13'\n  AND cc.id <= '216'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '2'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '13'\n       AND mi2.info_type_id = '2')\nGROUP BY cc.status_id;": [
        263631.33,
        254712.07,
        254712.05,
        253711.85,
        253208.48,
        238982.96,
        2419.57,
        2419.57,
        8918.26,
        14.92,
        161.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '9'\n  AND cc.id <= '41'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '88'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '9'\n       AND mi2.info_type_id = '88')\nGROUP BY cc.status_id;": [
        26368.35,
        25611.21,
        25611.19,
        24610.99,
        24608.54,
        21524.2,
        72.48,
        1.14,
        757.13,
        9.3,
        83.08,
        79.07,
        4.73,
        72.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '131'\n  AND cc.id <= '496'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '98'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '131'\n       AND mi2.info_type_id = '98')\nGROUP BY cc.status_id;": [
        251963.13,
        236165.08,
        236165.06,
        235164.86,
        235035.69,
        227546.26,
        3694.95,
        2419.57,
        2419.57,
        15797.59,
        19.32,
        160.99
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '187'\n  AND cc.id <= '284'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '93'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '187'\n       AND mi2.info_type_id = '93')\nGROUP BY cc.status_id;": [
        11541.3,
        11333.91,
        11333.89,
        10333.79,
        10332.72,
        7231.42,
        23.22,
        2.66,
        207.38,
        11.06,
        32.71,
        28.7,
        4.73,
        23.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '160'\n  AND cc.id <= '289'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '98'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '160'\n       AND mi2.info_type_id = '98')\nGROUP BY cc.status_id;": [
        237479.41,
        236164.6,
        236164.58,
        235164.38,
        235035.24,
        227546.26,
        3694.95,
        2419.57,
        2419.57,
        1314.75,
        11.94,
        162.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '111'\n  AND cc.id <= '330'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '87'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '111'\n       AND mi2.info_type_id = '87')\nGROUP BY cc.status_id;": [
        28714.9,
        24022.54,
        24022.52,
        23022.32,
        23020.06,
        20033.82,
        68.78,
        1.19,
        4692.35,
        15.36,
        79.26,
        75.25,
        4.73,
        68.78
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '125'\n  AND cc.id <= '420'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '82'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '125'\n       AND mi2.info_type_id = '82')\nGROUP BY cc.status_id;": [
        10181.71,
        8499.03,
        8498.12,
        3726.66,
        11.82,
        4.82,
        1682.66,
        17.42,
        21.07,
        17.05,
        4.73,
        11.82
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '146'\n  AND cc.id <= '248'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '51'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '146'\n       AND mi2.info_type_id = '51')\nGROUP BY cc.status_id;": [
        29625.77,
        27181.23,
        27181.21,
        26181.01,
        26178.37,
        22995.62,
        76.17,
        1.09,
        2444.53,
        11.2,
        86.89,
        82.88,
        4.73,
        76.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '72'\n  AND cc.id <= '192'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '75'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '72'\n       AND mi2.info_type_id = '75')\nGROUP BY cc.status_id;": [
        22914.47,
        22402.61,
        22402.59,
        21402.39,
        21400.32,
        18513.41,
        61.09,
        1.26,
        511.84,
        11.69,
        71.44,
        67.43,
        4.73,
        61.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '254'\n  AND cc.id <= '290'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '96'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '254'\n       AND mi2.info_type_id = '96')\nGROUP BY cc.status_id;": [
        33510.66,
        33280.87,
        33280.85,
        32280.65,
        32277.27,
        28700.54,
        98.95,
        0.95,
        229.77,
        9.41,
        110.17,
        106.15,
        4.73,
        98.95
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '243'\n  AND cc.id <= '269'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '85'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '243'\n       AND mi2.info_type_id = '85')\nGROUP BY cc.status_id;": [
        25786.56,
        25611.2,
        25611.19,
        24610.99,
        24608.54,
        21524.2,
        72.48,
        1.14,
        175.35,
        9.16,
        83.08,
        79.07,
        4.73,
        72.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '233'\n  AND cc.id <= '451'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '40'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '233'\n       AND mi2.info_type_id = '40')\nGROUP BY cc.status_id;": [
        39796.84,
        33280.87,
        33280.85,
        32280.65,
        32277.27,
        28700.54,
        98.95,
        0.95,
        6515.95,
        15.33,
        110.17,
        106.15,
        4.73,
        98.95
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '101'\n  AND cc.id <= '382'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '67'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '101'\n       AND mi2.info_type_id = '67')\nGROUP BY cc.status_id;": [
        45383.21,
        36229.53,
        36229.51,
        35229.31,
        35225.55,
        31451.45,
        110.35,
        0.9,
        9153.65,
        17.04,
        121.81,
        117.8,
        4.73,
        110.35
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '258'\n  AND cc.id <= '489'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '41'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '258'\n       AND mi2.info_type_id = '41')\nGROUP BY cc.status_id;": [
        30778.6,
        25611.2,
        25611.19,
        24610.99,
        24608.54,
        21524.2,
        72.48,
        1.14,
        5167.38,
        15.69,
        83.08,
        79.07,
        4.73,
        72.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '67'\n  AND cc.id <= '212'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '41'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '67'\n       AND mi2.info_type_id = '41')\nGROUP BY cc.status_id;": [
        28864.15,
        25611.21,
        25611.19,
        24610.99,
        24608.54,
        21524.2,
        72.48,
        1.14,
        3252.93,
        12.35,
        83.08,
        79.07,
        4.73,
        72.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '7'\n  AND cc.id <= '500'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '76'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '7'\n       AND mi2.info_type_id = '76')\nGROUP BY cc.status_id;": [
        27036.16,
        19112.59,
        19112.57,
        18112.37,
        18110.67,
        15420.21,
        49.7,
        1.44,
        7923.54,
        27.76,
        59.81,
        55.79,
        4.73,
        49.7
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '179'\n  AND cc.id <= '216'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '45'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '179'\n       AND mi2.info_type_id = '45')\nGROUP BY cc.status_id;": [
        8550.64,
        8499.03,
        8498.12,
        3726.66,
        11.82,
        4.82,
        51.6,
        9.44,
        21.07,
        17.05,
        4.73,
        11.82
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '133'\n  AND cc.id <= '410'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '50'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '133'\n       AND mi2.info_type_id = '50')\nGROUP BY cc.status_id;": [
        27706.87,
        22402.61,
        22402.59,
        21402.39,
        21400.32,
        18513.41,
        61.09,
        1.26,
        5304.25,
        16.93,
        71.44,
        67.43,
        4.73,
        61.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '45'\n  AND cc.id <= '247'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '77'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '45'\n       AND mi2.info_type_id = '77')\nGROUP BY cc.status_id;": [
        40725.03,
        39108.66,
        39108.65,
        38108.45,
        38104.3,
        34132.68,
        121.73,
        0.86,
        1616.36,
        14.89,
        133.45,
        129.43,
        4.73,
        121.73
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '63'\n  AND cc.id <= '250'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '95'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '63'\n       AND mi2.info_type_id = '95')\nGROUP BY cc.status_id;": [
        15214.67,
        13174.09,
        13174.07,
        12173.97,
        12172.64,
        8931.96,
        30.91,
        2.22,
        2040.57,
        13.51,
        40.53,
        36.52,
        4.73,
        30.91
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '1'\n  AND cc.id <= '435'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '64'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '1'\n       AND mi2.info_type_id = '64')\nGROUP BY cc.status_id;": [
        32857.01,
        30268.63,
        30268.62,
        29268.42,
        29265.4,
        25885.27,
        87.56,
        1.01,
        2588.36,
        26.16,
        98.54,
        94.52,
        4.73,
        87.56
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '28'\n  AND cc.id <= '300'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '94'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '28'\n       AND mi2.info_type_id = '94')\nGROUP BY cc.status_id;": [
        144781.73,
        132979.1,
        132917.32,
        126640.89,
        738.72,
        2419.57,
        2419.57,
        11802.54,
        16.79,
        161.44
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '313'\n  AND cc.id <= '343'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '73'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '313'\n       AND mi2.info_type_id = '73')\nGROUP BY cc.status_id;": [
        8550.45,
        8499.03,
        8498.12,
        3726.66,
        11.82,
        4.82,
        51.4,
        9.25,
        21.07,
        17.05,
        4.73,
        11.82
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '42'\n  AND cc.id <= '325'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '61'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '42'\n       AND mi2.info_type_id = '61')\nGROUP BY cc.status_id;": [
        27040.88,
        25611.21,
        25611.19,
        24610.99,
        24608.54,
        21524.2,
        72.48,
        1.14,
        1429.65,
        17.09,
        83.08,
        79.07,
        4.73,
        72.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '154'\n  AND cc.id <= '495'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '51'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '154'\n       AND mi2.info_type_id = '51')\nGROUP BY cc.status_id;": [
        29024.9,
        27181.23,
        27181.21,
        26181.01,
        26178.37,
        22995.62,
        76.17,
        1.09,
        1843.66,
        18.66,
        86.89,
        82.88,
        4.73,
        76.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '39'\n  AND cc.id <= '366'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '57'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '39'\n       AND mi2.info_type_id = '57')\nGROUP BY cc.status_id;": [
        28937.62,
        27181.23,
        27181.21,
        26181.01,
        26178.37,
        22995.62,
        76.17,
        1.09,
        1756.37,
        18.28,
        86.89,
        82.88,
        4.73,
        76.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '204'\n  AND cc.id <= '391'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '17'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '204'\n       AND mi2.info_type_id = '17')\nGROUP BY cc.status_id;": [
        238735.0,
        236930.05,
        236930.03,
        235929.83,
        235785.72,
        228029.29,
        4126.59,
        2419.57,
        2419.57,
        1804.87,
        13.51,
        162.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '182'\n  AND cc.id <= '250'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '46'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '182'\n       AND mi2.info_type_id = '46')\nGROUP BY cc.status_id;": [
        25953.88,
        25611.21,
        25611.19,
        24610.99,
        24608.54,
        21524.2,
        72.48,
        1.14,
        342.66,
        10.29,
        83.08,
        79.07,
        4.73,
        72.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '198'\n  AND cc.id <= '422'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '17'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '198'\n       AND mi2.info_type_id = '17')\nGROUP BY cc.status_id;": [
        239225.65,
        236930.14,
        236930.12,
        235929.92,
        235785.81,
        228029.29,
        4126.59,
        2419.57,
        2419.57,
        2295.42,
        15.5,
        162.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '98'\n  AND cc.id <= '442'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '67'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '98'\n       AND mi2.info_type_id = '67')\nGROUP BY cc.status_id;": [
        38806.54,
        36229.53,
        36229.51,
        35229.31,
        35225.55,
        31451.45,
        110.35,
        0.9,
        2576.99,
        18.74,
        121.81,
        117.8,
        4.73,
        110.35
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '179'\n  AND cc.id <= '277'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '48'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '179'\n       AND mi2.info_type_id = '48')\nGROUP BY cc.status_id;": [
        40.37,
        20.74,
        20.73,
        8.45,
        12.25,
        19.61,
        8.45,
        11.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '158'\n  AND cc.id <= '228'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '92'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '158'\n       AND mi2.info_type_id = '92')\nGROUP BY cc.status_id;": [
        23770.53,
        22402.61,
        22402.59,
        21402.39,
        21400.32,
        18513.41,
        61.09,
        1.26,
        1367.9,
        10.34,
        71.44,
        67.43,
        4.73,
        61.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '112'\n  AND cc.id <= '487'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '106'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '112'\n       AND mi2.info_type_id = '106')\nGROUP BY cc.status_id;": [
        210089.92,
        206328.59,
        206328.57,
        205328.37,
        205287.24,
        199383.18,
        1177.75,
        2419.57,
        2419.57,
        3761.27,
        23.57,
        162.5
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '350'\n  AND cc.id <= '404'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '92'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '350'\n       AND mi2.info_type_id = '92')\nGROUP BY cc.status_id;": [
        23484.28,
        22402.61,
        22402.59,
        21402.39,
        21400.32,
        18513.41,
        61.09,
        1.26,
        1081.66,
        9.9,
        71.44,
        67.43,
        4.73,
        61.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '351'\n  AND cc.id <= '367'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '54'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '351'\n       AND mi2.info_type_id = '54')\nGROUP BY cc.status_id;": [
        20847.05,
        20770.52,
        20770.5,
        19770.3,
        19768.42,
        16979.57,
        57.39,
        1.34,
        76.52,
        8.89,
        67.62,
        63.6,
        4.73,
        57.39
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '49'\n  AND cc.id <= '428'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '62'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '49'\n       AND mi2.info_type_id = '62')\nGROUP BY cc.status_id;": [
        27547.01,
        25611.21,
        25611.19,
        24610.99,
        24608.54,
        21524.2,
        72.48,
        1.14,
        1935.79,
        24.68,
        83.08,
        79.07,
        4.73,
        72.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '272'\n  AND cc.id <= '306'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '42'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '272'\n       AND mi2.info_type_id = '42')\nGROUP BY cc.status_id;": [
        27364.41,
        27181.23,
        27181.21,
        26181.01,
        26178.37,
        22995.62,
        76.17,
        1.09,
        183.16,
        9.36,
        86.89,
        82.88,
        4.73,
        76.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '370'\n  AND cc.id <= '486'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '81'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '370'\n       AND mi2.info_type_id = '81')\nGROUP BY cc.status_id;": [
        22914.36,
        22402.61,
        22402.59,
        21402.39,
        21400.32,
        18513.41,
        61.09,
        1.26,
        511.73,
        11.58,
        71.44,
        67.43,
        4.73,
        61.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '87'\n  AND cc.id <= '395'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '81'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '87'\n       AND mi2.info_type_id = '81')\nGROUP BY cc.status_id;": [
        23777.96,
        22402.61,
        22402.59,
        21402.39,
        21400.32,
        18513.41,
        61.09,
        1.26,
        1375.33,
        17.78,
        71.44,
        67.43,
        4.73,
        61.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '468'\n  AND cc.id <= '477'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '35'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '468'\n       AND mi2.info_type_id = '35')\nGROUP BY cc.status_id;": [
        9498.13,
        9460.52,
        9460.5,
        8460.4,
        8459.6,
        5497.8,
        19.52,
        3.39,
        37.59,
        8.7,
        28.89,
        24.87,
        4.73,
        19.52
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '303'\n  AND cc.id <= '311'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '65'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '303'\n       AND mi2.info_type_id = '65')\nGROUP BY cc.status_id;": [
        22482.74,
        22402.61,
        22402.59,
        21402.39,
        21400.32,
        18513.41,
        61.09,
        1.26,
        80.12,
        8.67,
        71.44,
        67.43,
        4.73,
        61.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '60'\n  AND cc.id <= '68'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '48'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '60'\n       AND mi2.info_type_id = '48')\nGROUP BY cc.status_id;": [
        37.89,
        20.74,
        20.73,
        8.45,
        12.25,
        17.13,
        8.67,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '37'\n  AND cc.id <= '374'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '7'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '37'\n       AND mi2.info_type_id = '7')\nGROUP BY cc.status_id;": [
        258512.95,
        255240.31,
        255240.29,
        254240.09,
        253709.0,
        238982.96,
        2419.57,
        2419.57,
        3272.24,
        18.55,
        162.64
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '78'\n  AND cc.id <= '224'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '78'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '78'\n       AND mi2.info_type_id = '78')\nGROUP BY cc.status_id;": [
        21391.58,
        20770.52,
        20770.51,
        19770.31,
        19768.42,
        16979.57,
        57.39,
        1.34,
        621.05,
        12.38,
        67.62,
        63.6,
        4.73,
        57.39
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '227'\n  AND cc.id <= '366'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '103'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '227'\n       AND mi2.info_type_id = '103')\nGROUP BY cc.status_id;": [
        116814.71,
        115499.67,
        115452.38,
        109439.22,
        564.46,
        2419.57,
        2419.57,
        1315.03,
        12.21,
        162.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '111'\n  AND cc.id <= '169'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '13'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '111'\n       AND mi2.info_type_id = '13')\nGROUP BY cc.status_id;": [
        233743.02,
        231131.27,
        231131.25,
        230131.05,
        230068.33,
        223775.83,
        1794.74,
        2419.57,
        2419.57,
        2611.7,
        10.02,
        162.6
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '318'\n  AND cc.id <= '425'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '9'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '318'\n       AND mi2.info_type_id = '9')\nGROUP BY cc.status_id;": [
        224948.45,
        220230.11,
        220230.09,
        219229.89,
        219179.45,
        213111.32,
        1446.53,
        2419.57,
        2419.57,
        4718.27,
        11.34,
        162.3
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '264'\n  AND cc.id <= '386'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '7'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '264'\n       AND mi2.info_type_id = '7')\nGROUP BY cc.status_id;": [
        260598.92,
        255231.13,
        255231.12,
        254230.92,
        253700.7,
        238982.96,
        2419.57,
        2419.57,
        5367.14,
        11.75,
        162.24
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '102'\n  AND cc.id <= '176'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '7'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '102'\n       AND mi2.info_type_id = '7')\nGROUP BY cc.status_id;": [
        256063.22,
        255238.25,
        255238.23,
        254238.03,
        253707.19,
        238982.96,
        2419.57,
        2419.57,
        824.86,
        10.46,
        162.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '358'\n  AND cc.id <= '454'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '72'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '358'\n       AND mi2.info_type_id = '72')\nGROUP BY cc.status_id;": [
        22539.93,
        20770.52,
        20770.5,
        19770.3,
        19768.42,
        16979.57,
        57.39,
        1.34,
        1769.4,
        11.03,
        67.62,
        63.6,
        4.73,
        57.39
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '21'\n  AND cc.id <= '289'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '54'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '21'\n       AND mi2.info_type_id = '54')\nGROUP BY cc.status_id;": [
        25656.54,
        20770.53,
        20770.51,
        19770.31,
        19768.42,
        16979.57,
        57.39,
        1.34,
        4886.0,
        16.68,
        67.62,
        63.6,
        4.73,
        57.39
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '70'\n  AND cc.id <= '208'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '6'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '70'\n       AND mi2.info_type_id = '6')\nGROUP BY cc.status_id;": [
        239810.92,
        238495.85,
        238495.83,
        237495.63,
        237320.77,
        229008.35,
        5000.96,
        2419.57,
        2419.57,
        1315.0,
        12.19,
        162.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '238'\n  AND cc.id <= '471'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '91'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '238'\n       AND mi2.info_type_id = '91')\nGROUP BY cc.status_id;": [
        16407.67,
        15717.46,
        15717.44,
        14717.24,
        14715.92,
        12222.93,
        38.3,
        1.71,
        690.2,
        15.75,
        48.17,
        44.15,
        4.73,
        38.3
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '4'\n  AND cc.id <= '278'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '66'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '4'\n       AND mi2.info_type_id = '66')\nGROUP BY cc.status_id;": [
        49001.23,
        39108.66,
        39108.65,
        38108.45,
        38104.3,
        34132.68,
        121.73,
        0.86,
        9892.53,
        16.85,
        133.45,
        129.43,
        4.73,
        121.73
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '163'\n  AND cc.id <= '307'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '77'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '163'\n       AND mi2.info_type_id = '77')\nGROUP BY cc.status_id;": [
        44325.76,
        39108.66,
        39108.64,
        38108.44,
        38104.3,
        34132.68,
        121.73,
        0.86,
        5217.08,
        12.33,
        133.45,
        129.43,
        4.73,
        121.73
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '42'\n  AND cc.id <= '76'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '98'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '42'\n       AND mi2.info_type_id = '98')\nGROUP BY cc.status_id;": [
        237641.68,
        236166.6,
        236166.59,
        235166.39,
        235037.13,
        227546.26,
        3694.95,
        2419.57,
        2419.57,
        1475.02,
        9.36,
        162.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '107'\n  AND cc.id <= '172'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '40'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '107'\n       AND mi2.info_type_id = '40')\nGROUP BY cc.status_id;": [
        35274.34,
        33280.88,
        33280.86,
        32280.66,
        32277.27,
        28700.54,
        98.95,
        0.95,
        1993.45,
        10.21,
        110.17,
        106.15,
        4.73,
        98.95
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '265'\n  AND cc.id <= '283'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '5'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '265'\n       AND mi2.info_type_id = '5')\nGROUP BY cc.status_id;": [
        238884.98,
        238713.17,
        238713.15,
        237712.95,
        237534.02,
        229148.12,
        5125.96,
        2419.57,
        2419.57,
        171.79,
        8.94,
        162.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '65'\n  AND cc.id <= '398'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '15'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '65'\n       AND mi2.info_type_id = '15')\nGROUP BY cc.status_id;": [
        244050.07,
        240778.16,
        240778.15,
        239777.95,
        239558.37,
        230440.75,
        6280.49,
        2419.57,
        2419.57,
        3271.73,
        18.44,
        162.64
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '230'\n  AND cc.id <= '291'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '18'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '230'\n       AND mi2.info_type_id = '18')\nGROUP BY cc.status_id;": [
        243724.69,
        243063.09,
        243063.07,
        242062.87,
        241798.73,
        231877.49,
        7563.73,
        2419.57,
        2419.57,
        661.54,
        10.1,
        162.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '15'\n  AND cc.id <= '378'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '61'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '15'\n       AND mi2.info_type_id = '61')\nGROUP BY cc.status_id;": [
        33690.4,
        25611.21,
        25611.19,
        24610.99,
        24608.54,
        21524.2,
        72.48,
        1.14,
        8079.16,
        19.27,
        83.08,
        79.07,
        4.73,
        72.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '269'\n  AND cc.id <= '280'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '9'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '269'\n       AND mi2.info_type_id = '9')\nGROUP BY cc.status_id;": [
        220728.11,
        220230.8,
        220230.78,
        219230.58,
        219180.12,
        213111.32,
        1446.53,
        2419.57,
        2419.57,
        497.3,
        8.75,
        162.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '49'\n  AND cc.id <= '200'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '109'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '49'\n       AND mi2.info_type_id = '109')\nGROUP BY cc.status_id;": [
        9375.8,
        8499.03,
        8498.12,
        3726.66,
        11.82,
        4.82,
        876.76,
        12.52,
        21.07,
        17.05,
        4.73,
        11.82
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '354'\n  AND cc.id <= '430'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '108'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '354'\n       AND mi2.info_type_id = '108')\nGROUP BY cc.status_id;": [
        62232.8,
        61408.02,
        61390.01,
        55907.69,
        216.25,
        2419.57,
        2419.57,
        824.77,
        10.51,
        162.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '95'\n  AND cc.id <= '457'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '72'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '95'\n       AND mi2.info_type_id = '72')\nGROUP BY cc.status_id;": [
        27349.84,
        20770.52,
        20770.51,
        19770.31,
        19768.42,
        16979.57,
        57.39,
        1.34,
        6579.3,
        19.24,
        67.62,
        63.6,
        4.73,
        57.39
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '52'\n  AND cc.id <= '155'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '77'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '52'\n       AND mi2.info_type_id = '77')\nGROUP BY cc.status_id;": [
        42856.65,
        39108.66,
        39108.65,
        38108.45,
        38104.3,
        34132.68,
        121.73,
        0.86,
        3747.97,
        11.22,
        133.45,
        129.43,
        4.73,
        121.73
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '331'\n  AND cc.id <= '467'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '48'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '331'\n       AND mi2.info_type_id = '48')\nGROUP BY cc.status_id;": [
        41.49,
        20.74,
        20.73,
        8.45,
        12.25,
        20.74,
        8.45,
        12.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '58'\n  AND cc.id <= '349'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '86'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '58'\n       AND mi2.info_type_id = '86')\nGROUP BY cc.status_id;": [
        21813.29,
        17428.29,
        17428.27,
        16428.07,
        16426.56,
        13835.62,
        46.0,
        1.56,
        4384.98,
        17.31,
        55.99,
        51.97,
        4.73,
        46.0
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '204'\n  AND cc.id <= '255'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '71'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '204'\n       AND mi2.info_type_id = '71')\nGROUP BY cc.status_id;": [
        18222.07,
        17428.29,
        17428.27,
        16428.07,
        16426.56,
        13835.62,
        46.0,
        1.56,
        793.76,
        9.82,
        55.99,
        51.97,
        4.73,
        46.0
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '134'\n  AND cc.id <= '403'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '134'\n       AND mi2.info_type_id = '3')\nGROUP BY cc.status_id;": [
        258599.18,
        255979.96,
        255979.94,
        254979.74,
        254409.99,
        238982.96,
        2419.57,
        2419.57,
        2618.87,
        16.71,
        162.6
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '388'\n  AND cc.id <= '425'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '84'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '388'\n       AND mi2.info_type_id = '84')\nGROUP BY cc.status_id;": [
        21456.27,
        20770.52,
        20770.5,
        19770.3,
        19768.42,
        16979.57,
        57.39,
        1.34,
        685.73,
        9.44,
        67.62,
        63.6,
        4.73,
        57.39
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '168'\n  AND cc.id <= '494'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '89'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '168'\n       AND mi2.info_type_id = '89')\nGROUP BY cc.status_id;": [
        22318.18,
        17428.29,
        17428.27,
        16428.07,
        16426.56,
        13835.62,
        46.0,
        1.56,
        4889.88,
        18.25,
        55.99,
        51.97,
        4.73,
        46.0
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '150'\n  AND cc.id <= '399'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '110'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '150'\n       AND mi2.info_type_id = '110')\nGROUP BY cc.status_id;": [
        95058.73,
        84214.15,
        84185.76,
        78510.71,
        341.25,
        2419.57,
        2419.57,
        10844.52,
        16.19,
        161.61
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '168'\n  AND cc.id <= '478'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '90'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '168'\n       AND mi2.info_type_id = '90')\nGROUP BY cc.status_id;": [
        62293.77,
        59185.68,
        59168.55,
        53696.36,
        204.87,
        2419.57,
        2419.57,
        3108.07,
        17.84,
        162.63
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '11'\n  AND cc.id <= '421'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '103'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '11'\n       AND mi2.info_type_id = '103')\nGROUP BY cc.status_id;": [
        119589.73,
        115504.69,
        115457.33,
        109439.22,
        564.46,
        2419.57,
        2419.57,
        4085.0,
        25.53,
        162.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '231'\n  AND cc.id <= '416'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '45'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '231'\n       AND mi2.info_type_id = '45')\nGROUP BY cc.status_id;": [
        8744.37,
        8499.03,
        8498.12,
        3726.66,
        11.82,
        4.82,
        245.32,
        13.45,
        21.07,
        17.05,
        4.73,
        11.82
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '195'\n  AND cc.id <= '407'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '90'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '195'\n       AND mi2.info_type_id = '90')\nGROUP BY cc.status_id;": [
        61315.57,
        59183.32,
        59166.19,
        53696.36,
        204.87,
        2419.57,
        2419.57,
        2132.24,
        15.17,
        162.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '261'\n  AND cc.id <= '409'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '18'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '261'\n       AND mi2.info_type_id = '18')\nGROUP BY cc.status_id;": [
        244540.71,
        243062.42,
        243062.4,
        242062.2,
        241798.11,
        231877.49,
        7563.73,
        2419.57,
        2419.57,
        1478.19,
        12.44,
        162.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '418'\n  AND cc.id <= '427'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '15'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '418'\n       AND mi2.info_type_id = '15')\nGROUP BY cc.status_id;": [
        240940.58,
        240769.0,
        240768.98,
        239768.78,
        239549.78,
        230440.75,
        6280.49,
        2419.57,
        2419.57,
        171.56,
        8.7,
        162.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '89'\n  AND cc.id <= '444'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '102'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '89'\n       AND mi2.info_type_id = '102')\nGROUP BY cc.status_id;": [
        58019.83,
        54588.77,
        54573.43,
        49133.3,
        186.08,
        2419.57,
        2419.57,
        3431.05,
        19.05,
        162.47
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '2'\n  AND cc.id <= '454'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '2'\n       AND mi2.info_type_id = '3')\nGROUP BY cc.status_id;": [
        260397.54,
        255984.34,
        255984.32,
        254984.12,
        254413.81,
        238982.96,
        2419.57,
        2419.57,
        4412.64,
        26.66,
        162.4
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '93'\n  AND cc.id <= '267'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '89'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '93'\n       AND mi2.info_type_id = '89')\nGROUP BY cc.status_id;": [
        20073.26,
        17428.29,
        17428.27,
        16428.07,
        16426.56,
        13835.62,
        46.0,
        1.56,
        2644.95,
        13.15,
        55.99,
        51.97,
        4.73,
        46.0
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '187'\n  AND cc.id <= '370'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '86'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '187'\n       AND mi2.info_type_id = '86')\nGROUP BY cc.status_id;": [
        20185.49,
        17428.29,
        17428.27,
        16428.07,
        16426.56,
        13835.62,
        46.0,
        1.56,
        2757.19,
        13.4,
        55.99,
        51.97,
        4.73,
        46.0
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '176'\n  AND cc.id <= '192'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '6'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '176'\n       AND mi2.info_type_id = '6')\nGROUP BY cc.status_id;": [
        239317.07,
        238493.88,
        238493.86,
        237493.66,
        237318.93,
        229008.35,
        5000.96,
        2419.57,
        2419.57,
        823.14,
        8.89,
        162.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '121'\n  AND cc.id <= '159'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '47'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '121'\n       AND mi2.info_type_id = '47')\nGROUP BY cc.status_id;": [
        29694.55,
        28737.82,
        28737.8,
        27737.6,
        27734.77,
        24452.79,
        83.87,
        1.05,
        956.72,
        9.46,
        94.72,
        90.7,
        4.73,
        83.87
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '121'\n  AND cc.id <= '311'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '121'\n       AND mi2.info_type_id = '3')\nGROUP BY cc.status_id;": [
        257786.93,
        255980.4,
        255980.38,
        254980.18,
        254410.37,
        238982.96,
        2419.57,
        2419.57,
        1806.29,
        14.59,
        162.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '357'\n  AND cc.id <= '416'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '75'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '357'\n       AND mi2.info_type_id = '75')\nGROUP BY cc.status_id;": [
        22698.47,
        22402.61,
        22402.59,
        21402.39,
        21400.32,
        18513.41,
        61.09,
        1.26,
        295.84,
        10.04,
        71.44,
        67.43,
        4.73,
        61.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '106'\n  AND cc.id <= '295'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '105'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '106'\n       AND mi2.info_type_id = '105')\nGROUP BY cc.status_id;": [
        222032.04,
        213759.21,
        213759.19,
        212758.99,
        212713.35,
        206728.53,
        1306.45,
        2419.57,
        2419.57,
        8272.72,
        14.56,
        161.91
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '79'\n  AND cc.id <= '261'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '87'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '79'\n       AND mi2.info_type_id = '87')\nGROUP BY cc.status_id;": [
        27920.21,
        24022.54,
        24022.53,
        23022.33,
        23020.06,
        20033.82,
        68.78,
        1.19,
        3897.65,
        13.37,
        79.26,
        75.25,
        4.73,
        68.78
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '34'\n  AND cc.id <= '57'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '78'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '34'\n       AND mi2.info_type_id = '78')\nGROUP BY cc.status_id;": [
        20847.25,
        20770.52,
        20770.51,
        19770.31,
        19768.42,
        16979.57,
        57.39,
        1.34,
        76.71,
        9.08,
        67.62,
        63.6,
        4.73,
        57.39
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '256'\n  AND cc.id <= '480'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '103'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '256'\n       AND mi2.info_type_id = '103')\nGROUP BY cc.status_id;": [
        117794.7,
        115499.25,
        115451.98,
        109439.22,
        564.46,
        2419.57,
        2419.57,
        2295.42,
        15.5,
        162.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '296'\n  AND cc.id <= '493'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '12'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '296'\n       AND mi2.info_type_id = '12')\nGROUP BY cc.status_id;": [
        55909.33,
        47314.6,
        47301.98,
        41916.07,
        151.91,
        2419.57,
        2419.57,
        8594.71,
        14.78,
        161.88
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '7'\n  AND cc.id <= '460'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '63'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '7'\n       AND mi2.info_type_id = '63')\nGROUP BY cc.status_id;": [
        35692.03,
        25611.21,
        25611.19,
        24610.99,
        24608.54,
        21524.2,
        72.48,
        1.14,
        10080.79,
        26.69,
        83.08,
        79.07,
        4.73,
        72.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '412'\n  AND cc.id <= '498'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '105'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '412'\n       AND mi2.info_type_id = '105')\nGROUP BY cc.status_id;": [
        214577.98,
        213752.93,
        213752.92,
        212752.72,
        212707.18,
        206728.53,
        1306.45,
        2419.57,
        2419.57,
        825.01,
        10.76,
        162.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:43\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info ON complete_cast.movie_id = movie_info.movie_id\n-- Table Size Changes: We added movie_info, a much larger table (1831 MB, 14,835,720 rows) compared to complete_cast (11 MB, 135086 rows) to increase the overall query cost.\n-- Structural Changes: Added a JOIN with movie_info along with an additional predicate on movie_info.info_type_id. The nested subquery was updated accordingly to include the join, ensuring the constraint on nested aggregation remains intact.\n-- LLM Reasoning: To push the cost into the target range [4000.0, 5000.0], the strategy was to increase query complexity by joining with a significantly larger table (movie_info) and adding extra filtering conditions. This increases both the IO and CPU cost while maintaining the nested aggregation constraint.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: increased from 1 to 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '1'\n  AND cc.id <= '1'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '1'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     JOIN movie_info mi2 ON cc2.movie_id = mi2.movie_id\n     WHERE cc2.id >= '1'\n       AND mi2.info_type_id = '1')\nGROUP BY cc.status_id;": [
        245625.1,
        245453.77,
        245453.75,
        244453.55,
        244142.18,
        233373.61,
        8899.91,
        2419.57,
        2419.57,
        171.31,
        8.45,
        162.84
    ]
}