{
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '76'\n  AND cc.id <= '360'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '2'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '76')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '294'\n  AND cc.id <= '369'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '64'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '294')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '240'\n  AND cc.id <= '346'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '70'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '240')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '143'\n  AND cc.id <= '487'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '1'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '143')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '101'\n  AND cc.id <= '381'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '80'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '101')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '340'\n  AND cc.id <= '348'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '72'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '340')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '29'\n  AND cc.id <= '374'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '110'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '29')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '315'\n  AND cc.id <= '321'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '88'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '315')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '339'\n  AND cc.id <= '442'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '47'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '339')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '114'\n  AND cc.id <= '354'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '62'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '114')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '19'\n  AND cc.id <= '318'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '4'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '19')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '237'\n  AND cc.id <= '401'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '86'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '237')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '239'\n  AND cc.id <= '474'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '46'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '239')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '321'\n  AND cc.id <= '328'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '95'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '321')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '26'\n  AND cc.id <= '31'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '91'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '26')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '64'\n  AND cc.id <= '406'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '13'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '64')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '184'\n  AND cc.id <= '298'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '42'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '184')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '82'\n  AND cc.id <= '143'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '57'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '82')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '35'\n  AND cc.id <= '150'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '62'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '35')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '339'\n  AND cc.id <= '471'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '107'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '339')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '206'\n  AND cc.id <= '438'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '105'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '206')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '135'\n  AND cc.id <= '140'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '92'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '135')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '221'\n  AND cc.id <= '362'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '35'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '221')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '127'\n  AND cc.id <= '444'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '94'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '127')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '213'\n  AND cc.id <= '386'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '65'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '213')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '103'\n  AND cc.id <= '129'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '15'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '103')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '146'\n  AND cc.id <= '481'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '70'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '146')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '233'\n  AND cc.id <= '345'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '4'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '233')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '26'\n  AND cc.id <= '379'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '8'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '26')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '81'\n  AND cc.id <= '244'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '84'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '81')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '72'\n  AND cc.id <= '86'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '43'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '72')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '116'\n  AND cc.id <= '431'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '8'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '116')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '116'\n  AND cc.id <= '220'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '73'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '116')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '335'\n  AND cc.id <= '437'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '109'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '335')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '175'\n  AND cc.id <= '209'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '109'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '175')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '325'\n  AND cc.id <= '464'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '12'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '325')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '188'\n  AND cc.id <= '453'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '76'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '188')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '224'\n  AND cc.id <= '461'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '1'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '224')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '123'\n  AND cc.id <= '438'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '104'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '123')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '17'\n  AND cc.id <= '335'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '43'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '17')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '156'\n  AND cc.id <= '192'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '84'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '156')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '328'\n  AND cc.id <= '448'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '97'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '328')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '44'\n  AND cc.id <= '88'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '96'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '44')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '163'\n  AND cc.id <= '385'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '107'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '163')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '121'\n  AND cc.id <= '307'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '66'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '121')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '18'\n  AND cc.id <= '273'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '17'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '18')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '54'\n  AND cc.id <= '302'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '51'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '54')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '138'\n  AND cc.id <= '200'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '11'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '138')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '394'\n  AND cc.id <= '449'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '106'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '394')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '168'\n  AND cc.id <= '464'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '93'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '168')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '51'\n  AND cc.id <= '137'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '97'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '51')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '209'\n  AND cc.id <= '481'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '11'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '209')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '272'\n  AND cc.id <= '391'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '66'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '272')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '282'\n  AND cc.id <= '463'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '81'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '282')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '22'\n  AND cc.id <= '94'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '16'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '22')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '13'\n  AND cc.id <= '216'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '2'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '13')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '9'\n  AND cc.id <= '41'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '88'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '9')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '131'\n  AND cc.id <= '496'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '98'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '131')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '187'\n  AND cc.id <= '284'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '93'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '187')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '160'\n  AND cc.id <= '289'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '98'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '160')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '111'\n  AND cc.id <= '330'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '87'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '111')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '125'\n  AND cc.id <= '420'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '82'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '125')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '146'\n  AND cc.id <= '248'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '51'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '146')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '72'\n  AND cc.id <= '192'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '75'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '72')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '254'\n  AND cc.id <= '290'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '96'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '254')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '243'\n  AND cc.id <= '269'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '85'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '243')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '233'\n  AND cc.id <= '451'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '40'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '233')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '101'\n  AND cc.id <= '382'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '67'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '101')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '258'\n  AND cc.id <= '489'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '41'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '258')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '67'\n  AND cc.id <= '212'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '41'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '67')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '7'\n  AND cc.id <= '500'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '76'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '7')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '179'\n  AND cc.id <= '216'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '45'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '179')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '133'\n  AND cc.id <= '410'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '50'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '133')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '45'\n  AND cc.id <= '247'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '77'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '45')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '63'\n  AND cc.id <= '250'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '95'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '63')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '1'\n  AND cc.id <= '435'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '64'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '1')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '28'\n  AND cc.id <= '300'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '94'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '28')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '313'\n  AND cc.id <= '343'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '73'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '313')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '42'\n  AND cc.id <= '325'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '61'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '42')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '154'\n  AND cc.id <= '495'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '51'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '154')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '39'\n  AND cc.id <= '366'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '57'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '39')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '204'\n  AND cc.id <= '391'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '17'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '204')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '182'\n  AND cc.id <= '250'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '46'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '182')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '198'\n  AND cc.id <= '422'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '17'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '198')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '98'\n  AND cc.id <= '442'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '67'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '98')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '179'\n  AND cc.id <= '277'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '48'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '179')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '158'\n  AND cc.id <= '228'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '92'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '158')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '112'\n  AND cc.id <= '487'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '106'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '112')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '350'\n  AND cc.id <= '404'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '92'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '350')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '351'\n  AND cc.id <= '367'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '54'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '351')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '49'\n  AND cc.id <= '428'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '62'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '49')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '272'\n  AND cc.id <= '306'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '42'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '272')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '370'\n  AND cc.id <= '486'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '81'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '370')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '87'\n  AND cc.id <= '395'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '81'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '87')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '468'\n  AND cc.id <= '477'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '35'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '468')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '303'\n  AND cc.id <= '311'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '65'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '303')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '60'\n  AND cc.id <= '68'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '48'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '60')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '37'\n  AND cc.id <= '374'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '7'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '37')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '78'\n  AND cc.id <= '224'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '78'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '78')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '227'\n  AND cc.id <= '366'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '103'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '227')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '111'\n  AND cc.id <= '169'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '13'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '111')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '318'\n  AND cc.id <= '425'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '9'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '318')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '264'\n  AND cc.id <= '386'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '7'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '264')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '102'\n  AND cc.id <= '176'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '7'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '102')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '358'\n  AND cc.id <= '454'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '72'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '358')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '21'\n  AND cc.id <= '289'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '54'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '21')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '70'\n  AND cc.id <= '208'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '6'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '70')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '238'\n  AND cc.id <= '471'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '91'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '238')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '4'\n  AND cc.id <= '278'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '66'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '4')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '163'\n  AND cc.id <= '307'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '77'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '163')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '42'\n  AND cc.id <= '76'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '98'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '42')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '107'\n  AND cc.id <= '172'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '40'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '107')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '265'\n  AND cc.id <= '283'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '5'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '265')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '65'\n  AND cc.id <= '398'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '15'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '65')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '230'\n  AND cc.id <= '291'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '18'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '230')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '15'\n  AND cc.id <= '378'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '61'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '15')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '269'\n  AND cc.id <= '280'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '9'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '269')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '49'\n  AND cc.id <= '200'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '109'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '49')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '354'\n  AND cc.id <= '430'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '108'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '354')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '95'\n  AND cc.id <= '457'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '72'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '95')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '52'\n  AND cc.id <= '155'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '77'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '52')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '331'\n  AND cc.id <= '467'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '48'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '331')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '58'\n  AND cc.id <= '349'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '86'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '58')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '204'\n  AND cc.id <= '255'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '71'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '204')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '134'\n  AND cc.id <= '403'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '3'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '134')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '388'\n  AND cc.id <= '425'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '84'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '388')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '168'\n  AND cc.id <= '494'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '89'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '168')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '150'\n  AND cc.id <= '399'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '110'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '150')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '168'\n  AND cc.id <= '478'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '90'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '168')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '11'\n  AND cc.id <= '421'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '103'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '11')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '231'\n  AND cc.id <= '416'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '45'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '231')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '195'\n  AND cc.id <= '407'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '90'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '195')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '261'\n  AND cc.id <= '409'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '18'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '261')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '418'\n  AND cc.id <= '427'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '15'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '418')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '89'\n  AND cc.id <= '444'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '102'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '89')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '2'\n  AND cc.id <= '454'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '3'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '2')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '93'\n  AND cc.id <= '267'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '89'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '93')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '187'\n  AND cc.id <= '370'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '86'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '187')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '176'\n  AND cc.id <= '192'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '6'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '176')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '121'\n  AND cc.id <= '159'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '47'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '121')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '121'\n  AND cc.id <= '311'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '3'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '121')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '357'\n  AND cc.id <= '416'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '75'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '357')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '106'\n  AND cc.id <= '295'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '105'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '106')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '79'\n  AND cc.id <= '261'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '87'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '79')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '34'\n  AND cc.id <= '57'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '78'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '34')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '256'\n  AND cc.id <= '480'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '103'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '256')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '296'\n  AND cc.id <= '493'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '12'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '296')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '7'\n  AND cc.id <= '460'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '63'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '7')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '412'\n  AND cc.id <= '498'\n  AND cc.status_id = '4'\n  AND mi.info_type_id = '105'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '412')\nGROUP BY cc.status_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:47\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_info (on cc.movie_id = mi.movie_id)\n-- Table Size Changes: Changed from the smaller table complete_cast (11 MB) to including movie_info (1831 MB), which is a much larger table to increase cost.\n-- Structural Changes: Added a JOIN with movie_info, included an additional predicate on movie_info.info_type_id, and selected an additional aggregated column AVG(mi.info). Retained the nested subquery with aggregation.\n-- LLM Reasoning: To push the execution plan cost into the target range, we added a join with the much larger movie_info table. This increases the amount of data processed, and the additional predicate further contributes to the complexity, thus shifting the cost into [3000.0, 4000.0].\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: now 2\n--   Number of Joins: 1\n--   Number of Aggregations: 3\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_info']\n-- Rewrite Attempts Number for Constraints Check: 2\n-- Rewrite Attempts Number for Grammar Check: 3\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count,\n       AVG(mi.info) AS avg_info\nFROM complete_cast cc\nJOIN movie_info mi ON cc.movie_id = mi.movie_id\nWHERE cc.id >= '1'\n  AND cc.id <= '1'\n  AND cc.status_id = '3'\n  AND mi.info_type_id = '1'\n  AND cc.id >\n    (SELECT AVG(subcc.id)\n     FROM complete_cast subcc\n     WHERE subcc.id >= '1')\nGROUP BY cc.status_id;": []
}