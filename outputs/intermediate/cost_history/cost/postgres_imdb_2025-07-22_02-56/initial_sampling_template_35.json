{
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '238'\n  AND ci.role_id = '7'\n  AND pi.person_id BETWEEN '89' AND '2380'\n  AND mii.info_type_id = '113';": [
        431.13,
        427.74,
        405.26,
        9.28,
        393.18,
        393.15,
        350.97,
        329.66,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.45,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '476'\n  AND ci.role_id = '6'\n  AND pi.person_id BETWEEN '258' AND '2113'\n  AND mii.info_type_id = '99';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '362'\n  AND ci.role_id = '11'\n  AND pi.person_id BETWEEN '182' AND '3302'\n  AND mii.info_type_id = '101';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '178'\n  AND ci.role_id = '2'\n  AND pi.person_id BETWEEN '2743' AND '3263'\n  AND mii.info_type_id = '112';": [
        491.71,
        488.32,
        415.38,
        403.17,
        360.99,
        339.68,
        331.17,
        322.72,
        159.58,
        145.26,
        145.14,
        13.53,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '336'\n  AND ci.role_id = '4'\n  AND pi.person_id BETWEEN '666' AND '862'\n  AND mii.info_type_id = '113';": [
        452.05,
        448.66,
        409.37,
        397.16,
        354.97,
        333.66,
        325.21,
        316.75,
        153.61,
        145.17,
        145.14,
        8.17,
        162.74,
        8.45,
        8.45,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '488'\n  AND ci.role_id = '5'\n  AND pi.person_id BETWEEN '498' AND '1928'\n  AND mii.info_type_id = '113';": [
        431.13,
        427.74,
        405.26,
        9.28,
        393.18,
        393.15,
        350.97,
        329.66,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.45,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '427'\n  AND ci.role_id = '4'\n  AND pi.person_id BETWEEN '582' AND '1728'\n  AND mii.info_type_id = '113';": [
        456.87,
        453.48,
        414.19,
        9.28,
        402.1,
        402.08,
        359.89,
        338.58,
        330.13,
        321.67,
        158.53,
        145.14,
        4.45,
        162.74,
        8.45,
        8.45,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '372'\n  AND ci.role_id = '8'\n  AND pi.person_id BETWEEN '874' AND '3222'\n  AND mii.info_type_id = '112';": [
        444.05,
        440.66,
        409.77,
        9.28,
        397.69,
        397.66,
        355.48,
        334.17,
        325.66,
        317.21,
        154.06,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '213'\n  AND ci.role_id = '11'\n  AND pi.person_id BETWEEN '1521' AND '2091'\n  AND mii.info_type_id = '101';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '73'\n  AND ci.role_id = '8'\n  AND pi.person_id BETWEEN '1580' AND '3302'\n  AND mii.info_type_id = '112';": [
        444.05,
        440.66,
        409.77,
        9.28,
        397.69,
        397.66,
        355.48,
        334.17,
        325.66,
        317.21,
        154.06,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '124'\n  AND ci.role_id = '6'\n  AND pi.person_id BETWEEN '4' AND '987'\n  AND mii.info_type_id = '112';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '134'\n  AND ci.role_id = '5'\n  AND pi.person_id BETWEEN '505' AND '2160'\n  AND mii.info_type_id = '100';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '466'\n  AND ci.role_id = '8'\n  AND pi.person_id BETWEEN '1045' AND '2195'\n  AND mii.info_type_id = '113';": [
        444.0,
        440.61,
        409.72,
        9.28,
        397.64,
        397.62,
        355.43,
        334.12,
        325.66,
        317.21,
        154.06,
        145.14,
        4.45,
        162.74,
        8.45,
        8.45,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '217'\n  AND ci.role_id = '3'\n  AND pi.person_id BETWEEN '366' AND '3703'\n  AND mii.info_type_id = '100';": [
        505.59,
        492.08,
        427.38,
        9.28,
        406.9,
        406.8,
        63.44,
        21.26,
        8.44,
        343.11,
        343.09,
        179.95,
        171.45,
        162.99,
        145.14,
        4.45,
        8.45,
        8.5,
        162.74,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '405'\n  AND ci.role_id = '4'\n  AND pi.person_id BETWEEN '2705' AND '3397'\n  AND mii.info_type_id = '100';": [
        456.92,
        453.53,
        414.23,
        9.28,
        402.15,
        402.13,
        359.94,
        338.63,
        330.13,
        321.67,
        158.53,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '68'\n  AND ci.role_id = '4'\n  AND pi.person_id BETWEEN '113' AND '2770'\n  AND mii.info_type_id = '113';": [
        468.83,
        462.07,
        417.09,
        9.28,
        402.21,
        402.16,
        63.44,
        21.26,
        8.44,
        338.59,
        338.58,
        175.44,
        166.98,
        158.53,
        145.14,
        4.45,
        8.45,
        8.45,
        162.74,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '387'\n  AND ci.role_id = '2'\n  AND pi.person_id BETWEEN '2140' AND '2267'\n  AND mii.info_type_id = '99';": [
        484.61,
        481.22,
        408.29,
        396.08,
        353.89,
        332.58,
        324.08,
        315.62,
        152.48,
        145.26,
        145.14,
        7.03,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '474'\n  AND ci.role_id = '9'\n  AND pi.person_id BETWEEN '1001' AND '2175'\n  AND mii.info_type_id = '101';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '144'\n  AND ci.role_id = '10'\n  AND pi.person_id BETWEEN '3075' AND '3347'\n  AND mii.info_type_id = '113';": [
        461.89,
        458.5,
        410.79,
        398.59,
        356.4,
        335.09,
        326.63,
        318.18,
        155.03,
        145.19,
        145.14,
        9.43,
        162.74,
        8.45,
        8.45,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '512'\n  AND ci.role_id = '6'\n  AND pi.person_id BETWEEN '685' AND '2001'\n  AND mii.info_type_id = '99';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '182'\n  AND ci.role_id = '5'\n  AND pi.person_id BETWEEN '726' AND '1696'\n  AND mii.info_type_id = '100';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '171'\n  AND ci.role_id = '2'\n  AND pi.person_id BETWEEN '3050' AND '3463'\n  AND mii.info_type_id = '112';": [
        489.77,
        486.38,
        413.44,
        401.24,
        359.05,
        337.74,
        329.24,
        320.78,
        157.64,
        145.26,
        145.14,
        11.77,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '359'\n  AND ci.role_id = '2'\n  AND pi.person_id BETWEEN '582' AND '1323'\n  AND mii.info_type_id = '112';": [
        507.74,
        500.98,
        422.29,
        407.27,
        343.68,
        180.54,
        172.04,
        163.58,
        145.26,
        145.14,
        17.19,
        8.45,
        8.5,
        162.74,
        63.47,
        63.44,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '193'\n  AND ci.role_id = '8'\n  AND pi.person_id BETWEEN '710' AND '1132'\n  AND mii.info_type_id = '113';": [
        444.0,
        440.61,
        409.72,
        9.28,
        397.64,
        397.62,
        355.43,
        334.12,
        325.66,
        317.21,
        154.06,
        145.14,
        4.45,
        162.74,
        8.45,
        8.45,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '353'\n  AND ci.role_id = '1'\n  AND pi.person_id BETWEEN '1850' AND '2560'\n  AND mii.info_type_id = '100';": [
        561.44,
        551.3,
        424.77,
        406.93,
        343.29,
        180.15,
        171.64,
        163.18,
        145.39,
        145.14,
        16.69,
        8.45,
        8.5,
        162.74,
        63.47,
        63.44,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '324'\n  AND ci.role_id = '1'\n  AND pi.person_id BETWEEN '926' AND '3545'\n  AND mii.info_type_id = '113';": [
        668.25,
        637.86,
        477.47,
        442.77,
        378.75,
        215.6,
        207.15,
        198.69,
        145.14,
        4.45,
        8.45,
        8.45,
        162.74,
        63.47,
        63.44,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '433'\n  AND ci.role_id = '9'\n  AND pi.person_id BETWEEN '1967' AND '3605'\n  AND mii.info_type_id = '112';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '511'\n  AND ci.role_id = '4'\n  AND pi.person_id BETWEEN '944' AND '3518'\n  AND mii.info_type_id = '99';": [
        468.88,
        462.12,
        417.14,
        9.28,
        402.26,
        402.21,
        63.44,
        21.26,
        8.44,
        338.64,
        338.63,
        175.49,
        166.98,
        158.53,
        145.14,
        4.45,
        8.45,
        8.5,
        162.74,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '482'\n  AND ci.role_id = '5'\n  AND pi.person_id BETWEEN '2617' AND '3563'\n  AND mii.info_type_id = '100';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '2'\n  AND ci.role_id = '10'\n  AND pi.person_id BETWEEN '1631' AND '2173'\n  AND mii.info_type_id = '100';": [
        466.84,
        463.45,
        415.74,
        403.53,
        361.35,
        340.04,
        331.53,
        323.08,
        159.93,
        145.19,
        145.14,
        13.91,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '305'\n  AND ci.role_id = '1'\n  AND pi.person_id BETWEEN '965' AND '1470'\n  AND mii.info_type_id = '100';": [
        545.75,
        538.99,
        418.15,
        403.13,
        339.55,
        176.41,
        167.9,
        159.44,
        145.39,
        145.14,
        13.29,
        8.45,
        8.5,
        162.74,
        63.47,
        63.44,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '418'\n  AND ci.role_id = '10'\n  AND pi.person_id BETWEEN '987' AND '2052'\n  AND mii.info_type_id = '99';": [
        469.79,
        466.4,
        418.7,
        9.28,
        406.61,
        406.59,
        364.4,
        343.09,
        334.59,
        326.13,
        162.99,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '329'\n  AND ci.role_id = '2'\n  AND pi.person_id BETWEEN '861' AND '1225'\n  AND mii.info_type_id = '100';": [
        488.9,
        485.51,
        412.58,
        400.37,
        358.18,
        336.87,
        328.37,
        319.91,
        156.77,
        145.26,
        145.14,
        10.95,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '495'\n  AND ci.role_id = '1'\n  AND pi.person_id BETWEEN '803' AND '3480'\n  AND mii.info_type_id = '113';": [
        668.25,
        637.86,
        477.47,
        442.77,
        378.75,
        215.6,
        207.15,
        198.69,
        145.14,
        4.45,
        8.45,
        8.45,
        162.74,
        63.47,
        63.44,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '175'\n  AND ci.role_id = '5'\n  AND pi.person_id BETWEEN '2185' AND '3031'\n  AND mii.info_type_id = '101';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '390'\n  AND ci.role_id = '10'\n  AND pi.person_id BETWEEN '1139' AND '1169'\n  AND mii.info_type_id = '101';": [
        458.37,
        454.98,
        407.27,
        395.06,
        352.88,
        331.57,
        323.06,
        314.61,
        151.46,
        145.14,
        5.43,
        5.43,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '309'\n  AND ci.role_id = '7'\n  AND pi.person_id BETWEEN '1989' AND '3490'\n  AND mii.info_type_id = '99';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '260'\n  AND ci.role_id = '10'\n  AND pi.person_id BETWEEN '2604' AND '3425'\n  AND mii.info_type_id = '101';": [
        469.79,
        466.4,
        418.7,
        9.28,
        406.61,
        406.59,
        364.4,
        343.09,
        334.59,
        326.13,
        162.99,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '281'\n  AND ci.role_id = '9'\n  AND pi.person_id BETWEEN '1272' AND '3567'\n  AND mii.info_type_id = '100';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '147'\n  AND ci.role_id = '1'\n  AND pi.person_id BETWEEN '1071' AND '2887'\n  AND mii.info_type_id = '99';": [
        624.98,
        604.72,
        461.23,
        434.96,
        371.13,
        207.98,
        199.48,
        191.02,
        145.39,
        145.14,
        42.99,
        8.45,
        8.5,
        162.74,
        63.47,
        63.44,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '243'\n  AND ci.role_id = '6'\n  AND pi.person_id BETWEEN '2185' AND '3230'\n  AND mii.info_type_id = '113';": [
        431.13,
        427.74,
        405.26,
        9.28,
        393.18,
        393.15,
        350.97,
        329.66,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.45,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '411'\n  AND ci.role_id = '10'\n  AND pi.person_id BETWEEN '421' AND '3619'\n  AND mii.info_type_id = '113';": [
        505.54,
        492.03,
        427.33,
        9.28,
        406.85,
        406.75,
        63.44,
        21.26,
        8.44,
        343.07,
        343.05,
        179.9,
        171.45,
        162.99,
        145.14,
        4.45,
        8.45,
        8.45,
        162.74,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '356'\n  AND ci.role_id = '5'\n  AND pi.person_id BETWEEN '1882' AND '2871'\n  AND mii.info_type_id = '100';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '313'\n  AND ci.role_id = '10'\n  AND pi.person_id BETWEEN '2351' AND '2742'\n  AND mii.info_type_id = '112';": [
        464.09,
        460.7,
        412.99,
        400.79,
        358.6,
        337.29,
        328.79,
        320.33,
        157.19,
        145.19,
        145.14,
        11.41,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '115'\n  AND ci.role_id = '5'\n  AND pi.person_id BETWEEN '2977' AND '3617'\n  AND mii.info_type_id = '99';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '61'\n  AND ci.role_id = '3'\n  AND pi.person_id BETWEEN '969' AND '1224'\n  AND mii.info_type_id = '101';": [
        461.62,
        458.23,
        410.52,
        398.31,
        356.13,
        334.82,
        326.31,
        317.85,
        154.71,
        145.19,
        145.14,
        9.15,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '233'\n  AND ci.role_id = '5'\n  AND pi.person_id BETWEEN '724' AND '1668'\n  AND mii.info_type_id = '100';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '142'\n  AND ci.role_id = '9'\n  AND pi.person_id BETWEEN '1593' AND '3596'\n  AND mii.info_type_id = '99';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '53'\n  AND ci.role_id = '5'\n  AND pi.person_id BETWEEN '1224' AND '2811'\n  AND mii.info_type_id = '101';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '203'\n  AND ci.role_id = '11'\n  AND pi.person_id BETWEEN '2220' AND '3371'\n  AND mii.info_type_id = '113';": [
        431.13,
        427.74,
        405.26,
        9.28,
        393.18,
        393.15,
        350.97,
        329.66,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.45,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '241'\n  AND ci.role_id = '10'\n  AND pi.person_id BETWEEN '1545' AND '3636'\n  AND mii.info_type_id = '101';": [
        481.77,
        475.01,
        421.6,
        9.28,
        406.72,
        406.67,
        63.44,
        21.26,
        8.44,
        343.1,
        343.09,
        179.95,
        171.45,
        162.99,
        145.14,
        4.45,
        8.45,
        8.5,
        162.74,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '383'\n  AND ci.role_id = '7'\n  AND pi.person_id BETWEEN '538' AND '2129'\n  AND mii.info_type_id = '99';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '18'\n  AND ci.role_id = '11'\n  AND pi.person_id BETWEEN '1521' AND '3230'\n  AND mii.info_type_id = '101';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '452'\n  AND ci.role_id = '4'\n  AND pi.person_id BETWEEN '3541' AND '3635'\n  AND mii.info_type_id = '100';": [
        451.83,
        448.45,
        409.15,
        396.94,
        354.75,
        333.45,
        324.94,
        161.8,
        153.62,
        8.45,
        145.14,
        6.49,
        6.49,
        162.74,
        8.5,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '307'\n  AND ci.role_id = '9'\n  AND pi.person_id BETWEEN '431' AND '3108'\n  AND mii.info_type_id = '112';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '299'\n  AND ci.role_id = '8'\n  AND pi.person_id BETWEEN '234' AND '2136'\n  AND mii.info_type_id = '100';": [
        444.05,
        440.66,
        409.77,
        9.28,
        397.69,
        397.66,
        355.48,
        334.17,
        325.66,
        317.21,
        154.06,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '167'\n  AND ci.role_id = '6'\n  AND pi.person_id BETWEEN '89' AND '752'\n  AND mii.info_type_id = '113';": [
        431.13,
        427.74,
        405.26,
        9.28,
        393.18,
        393.15,
        350.97,
        329.66,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.45,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '119'\n  AND ci.role_id = '7'\n  AND pi.person_id BETWEEN '362' AND '1867'\n  AND mii.info_type_id = '101';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '504'\n  AND ci.role_id = '8'\n  AND pi.person_id BETWEEN '3538' AND '3566'\n  AND mii.info_type_id = '101';": [
        442.06,
        438.67,
        407.78,
        395.57,
        353.39,
        332.08,
        323.57,
        315.12,
        151.97,
        5.39,
        145.15,
        145.14,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '468'\n  AND ci.role_id = '3'\n  AND pi.person_id BETWEEN '1545' AND '1669'\n  AND mii.info_type_id = '100';": [
        459.26,
        455.87,
        408.17,
        395.96,
        353.77,
        332.46,
        323.96,
        315.5,
        152.36,
        145.19,
        145.14,
        6.99,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '342'\n  AND ci.role_id = '6'\n  AND pi.person_id BETWEEN '1056' AND '2787'\n  AND mii.info_type_id = '112';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '153'\n  AND ci.role_id = '3'\n  AND pi.person_id BETWEEN '597' AND '2501'\n  AND mii.info_type_id = '101';": [
        481.77,
        475.01,
        421.6,
        9.28,
        406.72,
        406.67,
        63.44,
        21.26,
        8.44,
        343.1,
        343.09,
        179.95,
        171.45,
        162.99,
        145.14,
        4.45,
        8.45,
        8.5,
        162.74,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '266'\n  AND ci.role_id = '1'\n  AND pi.person_id BETWEEN '248' AND '2029'\n  AND mii.info_type_id = '100';": [
        624.35,
        604.09,
        460.6,
        434.33,
        370.5,
        207.36,
        198.85,
        190.39,
        145.39,
        145.14,
        42.41,
        8.45,
        8.5,
        162.74,
        63.47,
        63.44,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '113'\n  AND ci.role_id = '2'\n  AND pi.person_id BETWEEN '1246' AND '2844'\n  AND mii.info_type_id = '112';": [
        532.38,
        522.24,
        437.88,
        9.28,
        420.2,
        420.12,
        63.44,
        21.26,
        8.44,
        356.5,
        356.48,
        193.34,
        184.83,
        176.38,
        145.14,
        4.45,
        8.45,
        8.5,
        162.74,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '88'\n  AND ci.role_id = '5'\n  AND pi.person_id BETWEEN '393' AND '3616'\n  AND mii.info_type_id = '99';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '12'\n  AND ci.role_id = '4'\n  AND pi.person_id BETWEEN '1351' AND '2119'\n  AND mii.info_type_id = '100';": [
        456.92,
        453.53,
        414.23,
        9.28,
        402.15,
        402.13,
        359.94,
        338.63,
        330.13,
        321.67,
        158.53,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '15'\n  AND ci.role_id = '7'\n  AND pi.person_id BETWEEN '2351' AND '3323'\n  AND mii.info_type_id = '113';": [
        431.13,
        427.74,
        405.26,
        9.28,
        393.18,
        393.15,
        350.97,
        329.66,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.45,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '273'\n  AND ci.role_id = '11'\n  AND pi.person_id BETWEEN '726' AND '3132'\n  AND mii.info_type_id = '112';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '437'\n  AND ci.role_id = '6'\n  AND pi.person_id BETWEEN '295' AND '916'\n  AND mii.info_type_id = '112';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '292'\n  AND ci.role_id = '10'\n  AND pi.person_id BETWEEN '626' AND '814'\n  AND mii.info_type_id = '99';": [
        460.39,
        457.0,
        409.3,
        397.09,
        354.9,
        333.59,
        325.09,
        316.63,
        153.49,
        145.19,
        145.14,
        8.05,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '430'\n  AND ci.role_id = '4'\n  AND pi.person_id BETWEEN '1928' AND '2569'\n  AND mii.info_type_id = '113';": [
        456.87,
        453.48,
        414.19,
        9.28,
        402.1,
        402.08,
        359.89,
        338.58,
        330.13,
        321.67,
        158.53,
        145.14,
        4.45,
        162.74,
        8.45,
        8.45,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '268'\n  AND ci.role_id = '10'\n  AND pi.person_id BETWEEN '1291' AND '3661'\n  AND mii.info_type_id = '100';": [
        493.69,
        483.55,
        424.49,
        9.28,
        406.81,
        406.73,
        63.44,
        21.26,
        8.44,
        343.11,
        343.09,
        179.95,
        171.45,
        162.99,
        145.14,
        4.45,
        8.45,
        8.5,
        162.74,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '33'\n  AND ci.role_id = '6'\n  AND pi.person_id BETWEEN '1835' AND '3645'\n  AND mii.info_type_id = '112';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '518'\n  AND ci.role_id = '4'\n  AND pi.person_id BETWEEN '2323' AND '3674'\n  AND mii.info_type_id = '112';": [
        456.92,
        453.53,
        414.23,
        9.28,
        402.15,
        402.13,
        359.94,
        338.63,
        330.13,
        321.67,
        158.53,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '163'\n  AND ci.role_id = '8'\n  AND pi.person_id BETWEEN '1871' AND '2089'\n  AND mii.info_type_id = '100';": [
        444.15,
        440.76,
        409.87,
        397.66,
        355.48,
        334.17,
        325.66,
        317.21,
        154.06,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '24'\n  AND ci.role_id = '1'\n  AND pi.person_id BETWEEN '691' AND '1910'\n  AND mii.info_type_id = '100';": [
        586.47,
        572.96,
        440.76,
        420.12,
        356.41,
        193.27,
        184.76,
        176.3,
        145.39,
        145.14,
        29.11,
        8.45,
        8.5,
        162.74,
        63.47,
        63.44,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '76'\n  AND ci.role_id = '3'\n  AND pi.person_id BETWEEN '780' AND '3265'\n  AND mii.info_type_id = '112';": [
        493.69,
        483.55,
        424.49,
        9.28,
        406.81,
        406.73,
        63.44,
        21.26,
        8.44,
        343.11,
        343.09,
        179.95,
        171.45,
        162.99,
        145.14,
        4.45,
        8.45,
        8.5,
        162.74,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '226'\n  AND ci.role_id = '5'\n  AND pi.person_id BETWEEN '944' AND '1586'\n  AND mii.info_type_id = '112';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '28'\n  AND ci.role_id = '3'\n  AND pi.person_id BETWEEN '2115' AND '3683'\n  AND mii.info_type_id = '113';": [
        481.72,
        474.96,
        421.55,
        9.28,
        406.67,
        406.62,
        63.44,
        21.26,
        8.44,
        343.06,
        343.05,
        179.9,
        171.45,
        162.99,
        145.14,
        4.45,
        8.45,
        8.45,
        162.74,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '480'\n  AND ci.role_id = '1'\n  AND pi.person_id BETWEEN '300' AND '1258'\n  AND mii.info_type_id = '99';": [
        569.84,
        559.7,
        433.16,
        415.33,
        351.69,
        188.55,
        180.04,
        171.58,
        145.39,
        145.14,
        24.79,
        8.45,
        8.5,
        162.74,
        63.47,
        63.44,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '104'\n  AND ci.role_id = '3'\n  AND pi.person_id BETWEEN '1850' AND '3388'\n  AND mii.info_type_id = '101';": [
        481.77,
        475.01,
        421.6,
        9.28,
        406.72,
        406.67,
        63.44,
        21.26,
        8.44,
        343.1,
        343.09,
        179.95,
        171.45,
        162.99,
        145.14,
        4.45,
        8.45,
        8.5,
        162.74,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '195'\n  AND ci.role_id = '6'\n  AND pi.person_id BETWEEN '340' AND '581'\n  AND mii.info_type_id = '101';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '139'\n  AND ci.role_id = '11'\n  AND pi.person_id BETWEEN '926' AND '2022'\n  AND mii.info_type_id = '99';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '221'\n  AND ci.role_id = '6'\n  AND pi.person_id BETWEEN '192' AND '1806'\n  AND mii.info_type_id = '99';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '154'\n  AND ci.role_id = '10'\n  AND pi.person_id BETWEEN '1001' AND '2159'\n  AND mii.info_type_id = '99';": [
        469.79,
        466.4,
        418.7,
        9.28,
        406.61,
        406.59,
        364.4,
        343.09,
        334.59,
        326.13,
        162.99,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '85'\n  AND ci.role_id = '3'\n  AND pi.person_id BETWEEN '2006' AND '2963'\n  AND mii.info_type_id = '99';": [
        469.79,
        466.4,
        418.7,
        9.28,
        406.61,
        406.59,
        364.4,
        343.09,
        334.59,
        326.13,
        162.99,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '159'\n  AND ci.role_id = '4'\n  AND pi.person_id BETWEEN '795' AND '3248'\n  AND mii.info_type_id = '100';": [
        468.88,
        462.12,
        417.14,
        9.28,
        402.26,
        402.21,
        63.44,
        21.26,
        8.44,
        338.64,
        338.63,
        175.49,
        166.98,
        158.53,
        145.14,
        4.45,
        8.45,
        8.5,
        162.74,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '397'\n  AND ci.role_id = '5'\n  AND pi.person_id BETWEEN '2231' AND '3151'\n  AND mii.info_type_id = '101';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '91'\n  AND ci.role_id = '7'\n  AND pi.person_id BETWEEN '735' AND '3428'\n  AND mii.info_type_id = '101';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '121'\n  AND ci.role_id = '4'\n  AND pi.person_id BETWEEN '266' AND '788'\n  AND mii.info_type_id = '100';": [
        456.92,
        453.53,
        414.23,
        9.28,
        402.15,
        402.13,
        359.94,
        338.63,
        330.13,
        321.67,
        158.53,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '407'\n  AND ci.role_id = '7'\n  AND pi.person_id BETWEEN '2052' AND '3096'\n  AND mii.info_type_id = '112';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '249'\n  AND ci.role_id = '7'\n  AND pi.person_id BETWEEN '1318' AND '1761'\n  AND mii.info_type_id = '100';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '373'\n  AND ci.role_id = '4'\n  AND pi.person_id BETWEEN '3031' AND '3169'\n  AND mii.info_type_id = '99';": [
        451.03,
        447.65,
        408.35,
        396.14,
        353.95,
        332.65,
        324.14,
        315.68,
        152.54,
        145.17,
        145.14,
        7.21,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '320'\n  AND ci.role_id = '3'\n  AND pi.person_id BETWEEN '454' AND '2512'\n  AND mii.info_type_id = '113';": [
        481.72,
        474.96,
        421.55,
        9.28,
        406.67,
        406.62,
        63.44,
        21.26,
        8.44,
        343.06,
        343.05,
        179.9,
        171.45,
        162.99,
        145.14,
        4.45,
        8.45,
        8.45,
        162.74,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '47'\n  AND ci.role_id = '9'\n  AND pi.person_id BETWEEN '3567' AND '3670'\n  AND mii.info_type_id = '112';": [
        435.09,
        431.71,
        409.23,
        397.02,
        354.83,
        333.53,
        325.02,
        161.88,
        6.63,
        153.6,
        153.6,
        145.14,
        8.45,
        162.74,
        8.5,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '130'\n  AND ci.role_id = '9'\n  AND pi.person_id BETWEEN '362' AND '2050'\n  AND mii.info_type_id = '99';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '423'\n  AND ci.role_id = '8'\n  AND pi.person_id BETWEEN '572' AND '2748'\n  AND mii.info_type_id = '101';": [
        444.05,
        440.66,
        409.77,
        9.28,
        397.69,
        397.66,
        355.48,
        334.17,
        325.66,
        317.21,
        154.06,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '254'\n  AND ci.role_id = '9'\n  AND pi.person_id BETWEEN '752' AND '3197'\n  AND mii.info_type_id = '113';": [
        431.13,
        427.74,
        405.26,
        9.28,
        393.18,
        393.15,
        350.97,
        329.66,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.45,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '377'\n  AND ci.role_id = '7'\n  AND pi.person_id BETWEEN '1608' AND '2046'\n  AND mii.info_type_id = '101';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '186'\n  AND ci.role_id = '4'\n  AND pi.person_id BETWEEN '31' AND '1893'\n  AND mii.info_type_id = '99';": [
        468.88,
        462.12,
        417.14,
        9.28,
        402.26,
        402.21,
        63.44,
        21.26,
        8.44,
        338.64,
        338.63,
        175.49,
        166.98,
        158.53,
        145.14,
        4.45,
        8.45,
        8.5,
        162.74,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '296'\n  AND ci.role_id = '7'\n  AND pi.person_id BETWEEN '1963' AND '2323'\n  AND mii.info_type_id = '101';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '207'\n  AND ci.role_id = '2'\n  AND pi.person_id BETWEEN '1722' AND '2767'\n  AND mii.info_type_id = '113';": [
        517.13,
        510.37,
        431.67,
        416.65,
        353.07,
        189.93,
        181.47,
        173.01,
        145.26,
        145.14,
        26.23,
        8.45,
        8.45,
        162.74,
        63.47,
        63.44,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '287'\n  AND ci.role_id = '9'\n  AND pi.person_id BETWEEN '911' AND '1206'\n  AND mii.info_type_id = '101';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '25'\n  AND ci.role_id = '9'\n  AND pi.person_id BETWEEN '2089' AND '2405'\n  AND mii.info_type_id = '113';": [
        431.13,
        427.74,
        405.26,
        9.28,
        393.18,
        393.15,
        350.97,
        329.66,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.45,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '44'\n  AND ci.role_id = '6'\n  AND pi.person_id BETWEEN '2325' AND '2807'\n  AND mii.info_type_id = '99';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '401'\n  AND ci.role_id = '8'\n  AND pi.person_id BETWEEN '900' AND '1451'\n  AND mii.info_type_id = '100';": [
        444.05,
        440.66,
        409.77,
        9.28,
        397.69,
        397.66,
        355.48,
        334.17,
        325.66,
        317.21,
        154.06,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '282'\n  AND ci.role_id = '5'\n  AND pi.person_id BETWEEN '3473' AND '3582'\n  AND mii.info_type_id = '99';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '458'\n  AND ci.role_id = '8'\n  AND pi.person_id BETWEEN '1470' AND '3119'\n  AND mii.info_type_id = '101';": [
        444.05,
        440.66,
        409.77,
        9.28,
        397.69,
        397.66,
        355.48,
        334.17,
        325.66,
        317.21,
        154.06,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '453'\n  AND ci.role_id = '9'\n  AND pi.person_id BETWEEN '878' AND '1634'\n  AND mii.info_type_id = '101';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '489'\n  AND ci.role_id = '11'\n  AND pi.person_id BETWEEN '898' AND '3387'\n  AND mii.info_type_id = '100';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '414'\n  AND ci.role_id = '1'\n  AND pi.person_id BETWEEN '279' AND '3060'\n  AND mii.info_type_id = '99';": [
        680.18,
        646.41,
        480.4,
        442.88,
        378.79,
        215.65,
        207.15,
        198.69,
        145.14,
        4.45,
        8.45,
        8.5,
        162.74,
        63.47,
        63.44,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '462'\n  AND ci.role_id = '9'\n  AND pi.person_id BETWEEN '2009' AND '3386'\n  AND mii.info_type_id = '112';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '4'\n  AND ci.role_id = '7'\n  AND pi.person_id BETWEEN '113' AND '2569'\n  AND mii.info_type_id = '112';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '39'\n  AND ci.role_id = '6'\n  AND pi.person_id BETWEEN '505' AND '2072'\n  AND mii.info_type_id = '113';": [
        431.13,
        427.74,
        405.26,
        9.28,
        393.18,
        393.15,
        350.97,
        329.66,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.45,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '8'\n  AND ci.role_id = '6'\n  AND pi.person_id BETWEEN '1128' AND '1668'\n  AND mii.info_type_id = '112';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '449'\n  AND ci.role_id = '2'\n  AND pi.person_id BETWEEN '2038' AND '2842'\n  AND mii.info_type_id = '100';": [
        508.91,
        502.15,
        423.46,
        408.44,
        344.86,
        181.71,
        173.21,
        164.75,
        145.26,
        145.14,
        18.25,
        8.45,
        8.5,
        162.74,
        63.47,
        63.44,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '62'\n  AND ci.role_id = '10'\n  AND pi.person_id BETWEEN '2123' AND '2716'\n  AND mii.info_type_id = '101';": [
        467.76,
        464.37,
        416.66,
        404.46,
        362.27,
        340.96,
        332.46,
        324.0,
        160.86,
        145.19,
        145.14,
        14.75,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '342'\n  AND ci.role_id = '8'\n  AND pi.person_id BETWEEN '921' AND '1456'\n  AND mii.info_type_id = '100';": [
        444.05,
        440.66,
        409.77,
        9.28,
        397.69,
        397.66,
        355.48,
        334.17,
        325.66,
        317.21,
        154.06,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '318'\n  AND ci.role_id = '2'\n  AND pi.person_id BETWEEN '339' AND '3408'\n  AND mii.info_type_id = '113';": [
        568.04,
        547.78,
        446.5,
        9.28,
        420.42,
        420.27,
        356.43,
        193.29,
        184.83,
        176.38,
        145.14,
        4.45,
        8.45,
        8.45,
        162.74,
        63.47,
        63.44,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '93'\n  AND ci.role_id = '7'\n  AND pi.person_id BETWEEN '621' AND '794'\n  AND mii.info_type_id = '113';": [
        431.13,
        427.74,
        405.26,
        9.28,
        393.18,
        393.15,
        350.97,
        329.66,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.45,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '129'\n  AND ci.role_id = '3'\n  AND pi.person_id BETWEEN '626' AND '2611'\n  AND mii.info_type_id = '101';": [
        481.77,
        475.01,
        421.6,
        9.28,
        406.72,
        406.67,
        63.44,
        21.26,
        8.44,
        343.1,
        343.09,
        179.95,
        171.45,
        162.99,
        145.14,
        4.45,
        8.45,
        8.5,
        162.74,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '394'\n  AND ci.role_id = '1'\n  AND pi.person_id BETWEEN '959' AND '1359'\n  AND mii.info_type_id = '113';": [
        531.69,
        528.31,
        413.32,
        401.11,
        358.93,
        337.62,
        329.16,
        320.7,
        157.56,
        145.39,
        145.14,
        11.55,
        162.74,
        8.45,
        8.45,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '97'\n  AND ci.role_id = '2'\n  AND pi.person_id BETWEEN '259' AND '967'\n  AND mii.info_type_id = '112';": [
        495.13,
        491.74,
        418.8,
        406.6,
        364.41,
        343.1,
        334.59,
        326.14,
        163.0,
        145.26,
        145.14,
        16.65,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '381'\n  AND ci.role_id = '11'\n  AND pi.person_id BETWEEN '402' AND '3582'\n  AND mii.info_type_id = '100';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '67'\n  AND ci.role_id = '3'\n  AND pi.person_id BETWEEN '1967' AND '3461'\n  AND mii.info_type_id = '113';": [
        481.72,
        474.96,
        421.55,
        9.28,
        406.67,
        406.62,
        63.44,
        21.26,
        8.44,
        343.06,
        343.05,
        179.9,
        171.45,
        162.99,
        145.14,
        4.45,
        8.45,
        8.45,
        162.74,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '34'\n  AND ci.role_id = '9'\n  AND pi.person_id BETWEEN '916' AND '3493'\n  AND mii.info_type_id = '113';": [
        431.13,
        427.74,
        405.26,
        9.28,
        393.18,
        393.15,
        350.97,
        329.66,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.45,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '499'\n  AND ci.role_id = '2'\n  AND pi.person_id BETWEEN '192' AND '3656'\n  AND mii.info_type_id = '99';": [
        579.98,
        556.35,
        449.43,
        9.28,
        420.55,
        420.38,
        356.48,
        193.34,
        184.83,
        176.38,
        145.14,
        4.45,
        8.45,
        8.5,
        162.74,
        63.47,
        63.44,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '107'\n  AND ci.role_id = '2'\n  AND pi.person_id BETWEEN '3137' AND '3493'\n  AND mii.info_type_id = '99';": [
        488.77,
        485.38,
        412.44,
        400.23,
        358.05,
        336.74,
        328.23,
        319.77,
        156.63,
        145.26,
        145.14,
        10.83,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '505'\n  AND ci.role_id = '11'\n  AND pi.person_id BETWEEN '1830' AND '2771'\n  AND mii.info_type_id = '101';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '492'\n  AND ci.role_id = '11'\n  AND pi.person_id BETWEEN '705' AND '1815'\n  AND mii.info_type_id = '101';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '168'\n  AND ci.role_id = '10'\n  AND pi.person_id BETWEEN '1898' AND '2925'\n  AND mii.info_type_id = '112';": [
        469.79,
        466.4,
        418.7,
        9.28,
        406.61,
        406.59,
        364.4,
        343.09,
        334.59,
        326.13,
        162.99,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '218'\n  AND ci.role_id = '11'\n  AND pi.person_id BETWEEN '208' AND '691'\n  AND mii.info_type_id = '113';": [
        431.13,
        427.74,
        405.26,
        9.28,
        393.18,
        393.15,
        350.97,
        329.66,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.45,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '200'\n  AND ci.role_id = '4'\n  AND pi.person_id BETWEEN '2624' AND '2956'\n  AND mii.info_type_id = '112';": [
        454.57,
        451.19,
        411.89,
        399.68,
        357.49,
        336.19,
        327.68,
        319.22,
        156.08,
        145.17,
        145.14,
        10.43,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '277'\n  AND ci.role_id = '9'\n  AND pi.person_id BETWEEN '1189' AND '2102'\n  AND mii.info_type_id = '100';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '348'\n  AND ci.role_id = '10'\n  AND pi.person_id BETWEEN '349' AND '2039'\n  AND mii.info_type_id = '101';": [
        481.77,
        475.01,
        421.6,
        9.28,
        406.72,
        406.67,
        63.44,
        21.26,
        8.44,
        343.1,
        343.09,
        179.95,
        171.45,
        162.99,
        145.14,
        4.45,
        8.45,
        8.5,
        162.74,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '103'\n  AND ci.role_id = '11'\n  AND pi.person_id BETWEEN '1091' AND '3168'\n  AND mii.info_type_id = '99';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '351'\n  AND ci.role_id = '6'\n  AND pi.person_id BETWEEN '3121' AND '3265'\n  AND mii.info_type_id = '112';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '326'\n  AND ci.role_id = '3'\n  AND pi.person_id BETWEEN '2072' AND '3108'\n  AND mii.info_type_id = '112';": [
        469.79,
        466.4,
        418.7,
        9.28,
        406.61,
        406.59,
        364.4,
        343.09,
        334.59,
        326.13,
        162.99,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '443'\n  AND ci.role_id = '2'\n  AND pi.person_id BETWEEN '2078' AND '3191'\n  AND mii.info_type_id = '99';": [
        518.39,
        511.63,
        432.93,
        417.91,
        354.33,
        191.19,
        182.68,
        174.22,
        145.26,
        145.14,
        27.35,
        8.45,
        8.5,
        162.74,
        63.47,
        63.44,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '56'\n  AND ci.role_id = '1'\n  AND pi.person_id BETWEEN '1258' AND '3228'\n  AND mii.info_type_id = '99';": [
        639.68,
        616.04,
        466.92,
        437.84,
        373.94,
        210.8,
        202.29,
        193.84,
        145.39,
        145.14,
        45.55,
        8.45,
        8.5,
        162.74,
        63.47,
        63.44,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '335'\n  AND ci.role_id = '8'\n  AND pi.person_id BETWEEN '2954' AND '3619'\n  AND mii.info_type_id = '101';": [
        444.05,
        440.66,
        409.77,
        9.28,
        397.69,
        397.66,
        355.48,
        334.17,
        325.66,
        317.21,
        154.06,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '441'\n  AND ci.role_id = '1'\n  AND pi.person_id BETWEEN '2011' AND '3518'\n  AND mii.info_type_id = '112';": [
        603.59,
        586.7,
        448.86,
        425.4,
        361.63,
        198.49,
        189.98,
        181.52,
        145.39,
        145.14,
        33.87,
        8.45,
        8.5,
        162.74,
        63.47,
        63.44,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '368'\n  AND ci.role_id = '11'\n  AND pi.person_id BETWEEN '763' AND '2277'\n  AND mii.info_type_id = '100';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '290'\n  AND ci.role_id = '2'\n  AND pi.person_id BETWEEN '2244' AND '3063'\n  AND mii.info_type_id = '100';": [
        509.19,
        502.42,
        423.73,
        408.71,
        345.13,
        181.99,
        173.48,
        165.02,
        145.26,
        145.14,
        18.49,
        8.45,
        8.5,
        162.74,
        63.47,
        63.44,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '189'\n  AND ci.role_id = '1'\n  AND pi.person_id BETWEEN '1708' AND '3302'\n  AND mii.info_type_id = '99';": [
        617.06,
        596.79,
        453.31,
        427.04,
        363.2,
        200.06,
        191.56,
        183.1,
        145.39,
        145.14,
        35.31,
        8.45,
        8.5,
        162.74,
        63.47,
        63.44,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '423'\n  AND ci.role_id = '8'\n  AND pi.person_id BETWEEN '538' AND '3544'\n  AND mii.info_type_id = '113';": [
        455.94,
        449.18,
        412.63,
        9.28,
        397.75,
        397.7,
        63.44,
        21.26,
        8.44,
        334.13,
        334.12,
        170.98,
        162.52,
        154.06,
        145.14,
        4.45,
        8.45,
        8.45,
        162.74,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '45'\n  AND ci.role_id = '7'\n  AND pi.person_id BETWEEN '3143' AND '3703'\n  AND mii.info_type_id = '113';": [
        431.13,
        427.74,
        405.26,
        9.28,
        393.18,
        393.15,
        350.97,
        329.66,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.45,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '81'\n  AND ci.role_id = '7'\n  AND pi.person_id BETWEEN '724' AND '3336'\n  AND mii.info_type_id = '112';": [
        431.17,
        427.79,
        405.31,
        9.28,
        393.23,
        393.2,
        351.01,
        329.71,
        321.2,
        312.74,
        149.6,
        145.14,
        4.45,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '208'\n  AND ci.role_id = '1'\n  AND pi.person_id BETWEEN '3220' AND '3456'\n  AND mii.info_type_id = '101';": [
        528.74,
        525.36,
        410.37,
        398.16,
        355.97,
        334.67,
        326.16,
        317.7,
        154.56,
        145.39,
        145.14,
        8.83,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:55\n-- Operation: both\n-- Old Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> cast_info\n-- New Join Path: cast_info -> movie_info -> title -> person_info -> movie_keyword -> movie_companies -> company_name -> movie_info_idx -> name\n-- Table Size Changes: Added movie_info_idx (122 MB, 1380035 rows) and name (524 MB, 4167491 rows) which are large tables to increase I/O and join complexity, thus raising the cost.\n-- Structural Changes: Added an extra join on movie_info_idx and name, introduced an additional predicate on mii.info_type_id placeholder, and an extra aggregation COUNT(n.name) to increase the query complexity.\n-- LLM Reasoning: To push the cost into the target range [7000.0, 8000.0], both join path and query structure were modified. By joining additional large tables and adding another filter condition as well as an extra aggregation, the query now requires processing a larger amount of data, thereby increasing the execution plan cost while still preserving the required predicate placeholders.\n\n-- SQL Template Metadata\n-- Template ID: 22_modified\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 9\n--   Number of Joins: 8\n--   Number of Aggregations: 6\n--   Semantic Requirement: The query should use aggregation, and have at least three predicate values to fill.\n--   Tables Involved: [cast_info, movie_info, title, person_info, movie_keyword, movie_companies, company_name, movie_info_idx, name]\n\nSELECT MAX(ci.nr_order) AS max_nr_order,\n       MIN(mi.info) AS min_info_value,\n       COUNT(DISTINCT t.title) AS distinct_titles,\n       SUM(mc.company_id) AS sum_company_id,\n       AVG(pi.person_id) AS avg_person_id,\n       COUNT(n.name) AS cnt_names\nFROM cast_info AS ci\nJOIN movie_info AS mi ON ci.movie_id = mi.movie_id\nJOIN title AS t ON mi.movie_id = t.id\nJOIN person_info AS pi ON ci.person_id = pi.person_id\nJOIN movie_keyword AS mk ON mi.movie_id = mk.movie_id\nJOIN movie_companies AS mc ON mi.movie_id = mc.movie_id\nJOIN company_name AS cn ON mc.company_id = cn.id\nJOIN movie_info_idx AS mii ON mi.movie_id = mii.movie_id\nJOIN name AS n ON pi.person_id = n.id\nWHERE mi.movie_id = '1'\n  AND ci.role_id = '1'\n  AND pi.person_id BETWEEN '4' AND '4'\n  AND mii.info_type_id = '99';": [
        524.98,
        521.59,
        406.6,
        394.4,
        352.21,
        330.9,
        322.4,
        313.94,
        150.8,
        145.14,
        4.93,
        4.93,
        162.74,
        8.45,
        8.5,
        21.26,
        8.44,
        9.51,
        9.28,
        8.46,
        8.45
    ]
}