{
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1143') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '335'\n  AND m.movie_id <= '503'\n  AND t.production_year = '1888'\n  AND c.nr_order = '1143'\nGROUP BY m.movie_id;": [
        5551.01,
        4613.27,
        4610.83,
        4609.56,
        4607.73,
        4542.0,
        4524.59,
        15.33,
        8.27,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '715') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '13'\n  AND m.movie_id <= '294'\n  AND t.production_year = '1892'\n  AND c.nr_order = '715'\nGROUP BY m.movie_id;": [
        8336.11,
        7398.38,
        7395.94,
        7394.67,
        7392.83,
        7376.53,
        7247.92,
        26.11,
        8.17,
        128.59,
        16.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '28424') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '289'\n  AND m.movie_id <= '436'\n  AND t.production_year = '1890'\n  AND c.nr_order = '28424'\nGROUP BY m.movie_id;": [
        5037.4,
        4099.66,
        4097.22,
        4095.95,
        4094.12,
        4028.39,
        4010.98,
        14.08,
        8.29,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '161') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '402'\n  AND m.movie_id <= '429'\n  AND t.production_year = '1976'\n  AND c.nr_order = '161'\nGROUP BY m.movie_id;": [
        2050.24,
        1112.5,
        1110.06,
        1108.79,
        1106.96,
        1098.72,
        1025.31,
        6.85,
        8.42,
        73.4,
        8.17,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '358') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '109'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1905'\n  AND c.nr_order = '358'\nGROUP BY m.movie_id;": [
        11268.83,
        10331.1,
        10328.66,
        10327.39,
        10325.55,
        10309.25,
        10180.64,
        33.64,
        8.05,
        128.59,
        16.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '469') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '244'\n  AND m.movie_id <= '462'\n  AND t.production_year = '1899'\n  AND c.nr_order = '469'\nGROUP BY m.movie_id;": [
        6794.37,
        5856.64,
        5854.2,
        5852.93,
        5851.09,
        5752.5,
        5735.09,
        18.33,
        8.23,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '293') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '62'\n  AND m.movie_id <= '498'\n  AND t.production_year = '1942'\n  AND c.nr_order = '293'\nGROUP BY m.movie_id;": [
        11959.13,
        11021.4,
        11018.96,
        11017.69,
        11015.85,
        10999.55,
        10870.94,
        35.44,
        8.03,
        128.59,
        16.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1173') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '111'\n  AND m.movie_id <= '414'\n  AND t.production_year = '1993'\n  AND c.nr_order = '1173'\nGROUP BY m.movie_id;": [
        9252.59,
        8314.85,
        8312.42,
        8311.15,
        8309.31,
        8303.0,
        7771.41,
        27.45,
        8.14,
        53.15,
        6.25,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '980102') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '217'\n  AND m.movie_id <= '289'\n  AND t.production_year = '1936'\n  AND c.nr_order = '980102'\nGROUP BY m.movie_id;": [
        3180.59,
        2242.86,
        2240.42,
        2239.15,
        2237.31,
        2171.59,
        2156.76,
        9.56,
        8.39,
        14.76,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1900') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '355'\n  AND m.movie_id <= '436'\n  AND t.production_year = '1937'\n  AND c.nr_order = '1900'\nGROUP BY m.movie_id;": [
        3402.01,
        2464.27,
        2461.83,
        2460.56,
        2458.73,
        2393.0,
        2377.45,
        10.1,
        8.37,
        15.49,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '829') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '138'\n  AND m.movie_id <= '340'\n  AND t.production_year = '1880'\n  AND c.nr_order = '829'\nGROUP BY m.movie_id;": [
        6411.81,
        5474.08,
        5471.64,
        5470.37,
        5468.53,
        5369.94,
        5352.53,
        17.37,
        8.25,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '525') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '52'\n  AND m.movie_id <= '143'\n  AND t.production_year = '1963'\n  AND c.nr_order = '525'\nGROUP BY m.movie_id;": [
        3659.37,
        2721.64,
        2719.2,
        2717.93,
        2716.09,
        2707.27,
        2627.55,
        10.7,
        8.36,
        79.71,
        8.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1167') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '316'\n  AND m.movie_id <= '438'\n  AND t.production_year = '1924'\n  AND c.nr_order = '1167'\nGROUP BY m.movie_id;": [
        4457.37,
        3519.63,
        3517.2,
        3515.93,
        3514.09,
        3415.5,
        3399.73,
        12.58,
        8.32,
        15.71,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '258') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '176'\n  AND m.movie_id <= '517'\n  AND t.production_year = '1897'\n  AND c.nr_order = '258'\nGROUP BY m.movie_id;": [
        9757.18,
        8819.45,
        8817.01,
        8815.74,
        8813.9,
        8797.6,
        8668.99,
        29.73,
        8.11,
        128.59,
        16.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '286') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '168'\n  AND m.movie_id <= '353'\n  AND t.production_year = '2001'\n  AND c.nr_order = '286'\nGROUP BY m.movie_id;": [
        6449.12,
        5511.38,
        5508.94,
        5507.67,
        5505.84,
        5500.54,
        4940.56,
        16.36,
        8.26,
        43.06,
        5.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '296') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '364'\n  AND m.movie_id <= '488'\n  AND t.production_year = '1889'\n  AND c.nr_order = '296'\nGROUP BY m.movie_id;": [
        4476.97,
        3539.23,
        3536.79,
        3535.52,
        3533.69,
        3467.96,
        3450.55,
        12.69,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '137') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '26'\n  AND m.movie_id <= '322'\n  AND t.production_year = '1962'\n  AND c.nr_order = '137'\nGROUP BY m.movie_id;": [
        8908.8,
        7971.07,
        7968.63,
        7967.36,
        7965.52,
        7956.06,
        7609.54,
        27.04,
        8.15,
        86.62,
        9.4,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '5001') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '143'\n  AND m.movie_id <= '260'\n  AND t.production_year = '1964'\n  AND c.nr_order = '5001'\nGROUP BY m.movie_id;": [
        4379.95,
        3442.22,
        3439.78,
        3438.51,
        3436.67,
        3428.22,
        3276.68,
        12.28,
        8.33,
        75.76,
        8.39,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '11002') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '394'\n  AND m.movie_id <= '453'\n  AND t.production_year = '1998'\n  AND c.nr_order = '11002'\nGROUP BY m.movie_id;": [
        2961.11,
        2023.37,
        2020.93,
        2019.66,
        2017.83,
        2012.3,
        1830.43,
        8.78,
        8.39,
        45.46,
        5.46,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '811') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '74'\n  AND m.movie_id <= '91'\n  AND t.production_year = '1951'\n  AND c.nr_order = '811'\nGROUP BY m.movie_id;": [
        1764.34,
        826.61,
        824.17,
        822.9,
        790.03,
        788.2,
        775.21,
        6.25,
        8.45,
        12.93,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '481') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '86'\n  AND m.movie_id <= '123'\n  AND t.production_year = '1941'\n  AND c.nr_order = '481'\nGROUP BY m.movie_id;": [
        2272.97,
        1335.23,
        1332.79,
        1331.52,
        1298.66,
        1296.82,
        1279.41,
        7.45,
        8.42,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '174') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '388'\n  AND m.movie_id <= '460'\n  AND t.production_year = '1985'\n  AND c.nr_order = '174'\nGROUP BY m.movie_id;": [
        3223.88,
        2286.15,
        2283.71,
        2282.44,
        2280.6,
        2273.77,
        2156.76,
        9.56,
        8.39,
        58.5,
        6.77,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '152') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '176'\n  AND m.movie_id <= '398'\n  AND t.production_year = '1903'\n  AND c.nr_order = '152'\nGROUP BY m.movie_id;": [
        6892.01,
        5954.28,
        5951.84,
        5950.57,
        5948.73,
        5850.14,
        5832.73,
        18.57,
        8.22,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2037') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '153'\n  AND m.movie_id <= '466'\n  AND t.production_year = '1908'\n  AND c.nr_order = '2037'\nGROUP BY m.movie_id;": [
        9097.7,
        8159.97,
        8157.53,
        8156.26,
        8154.42,
        8138.12,
        8009.51,
        28.06,
        8.14,
        128.59,
        16.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '44') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '146'\n  AND m.movie_id <= '342'\n  AND t.production_year = '1945'\n  AND c.nr_order = '44'\nGROUP BY m.movie_id;": [
        6263.35,
        5325.62,
        5323.18,
        5321.91,
        5320.07,
        5221.48,
        5204.07,
        17.01,
        8.25,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '88') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '124'\n  AND m.movie_id <= '463'\n  AND t.production_year = '2008'\n  AND c.nr_order = '88'\nGROUP BY m.movie_id;": [
        11540.29,
        10602.56,
        10600.12,
        10598.85,
        10597.01,
        10592.26,
        8618.17,
        29.61,
        8.11,
        37.23,
        4.69,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '7000') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '361'\n  AND m.movie_id <= '495'\n  AND t.production_year = '1950'\n  AND c.nr_order = '7000'\nGROUP BY m.movie_id;": [
        4759.83,
        3822.09,
        3819.65,
        3818.38,
        3816.55,
        3803.45,
        3696.65,
        13.29,
        8.31,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '283') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '45'\n  AND m.movie_id <= '128'\n  AND t.production_year = '2007'\n  AND c.nr_order = '283'\nGROUP BY m.movie_id;": [
        3901.92,
        2964.18,
        2961.75,
        2960.48,
        2958.64,
        2953.86,
        2428.27,
        10.22,
        8.37,
        37.53,
        4.72,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '384') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '160'\n  AND m.movie_id <= '482'\n  AND t.production_year = '1974'\n  AND c.nr_order = '384'\nGROUP BY m.movie_id;": [
        9601.38,
        8663.64,
        8661.2,
        8659.93,
        8658.1,
        8650.06,
        8222.2,
        28.59,
        8.13,
        71.3,
        7.97,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '19101') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '129'\n  AND m.movie_id <= '310'\n  AND t.production_year = '1939'\n  AND c.nr_order = '19101'\nGROUP BY m.movie_id;": [
        5869.34,
        4931.6,
        4929.16,
        4927.89,
        4926.06,
        4860.33,
        4842.92,
        16.11,
        8.27,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '60') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '132'\n  AND m.movie_id <= '195'\n  AND t.production_year = '1935'\n  AND c.nr_order = '60'\nGROUP BY m.movie_id;": [
        2923.98,
        1986.25,
        1983.81,
        1982.54,
        1949.67,
        1947.84,
        1932.07,
        9.02,
        8.4,
        15.71,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '24100') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '40'\n  AND m.movie_id <= '279'\n  AND t.production_year = '1922'\n  AND c.nr_order = '24100'\nGROUP BY m.movie_id;": [
        7299.98,
        6362.25,
        6359.81,
        6358.54,
        6356.7,
        6258.11,
        6240.7,
        19.59,
        8.21,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '181') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '119'\n  AND m.movie_id <= '164'\n  AND t.production_year = '1914'\n  AND c.nr_order = '181'\nGROUP BY m.movie_id;": [
        2530.27,
        1592.53,
        1590.09,
        1588.82,
        1586.99,
        1575.96,
        1478.69,
        7.93,
        8.4,
        97.26,
        10.96,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '57') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '103'\n  AND m.movie_id <= '508'\n  AND t.production_year = '2004'\n  AND c.nr_order = '57'\nGROUP BY m.movie_id;": [
        13770.37,
        11894.9,
        11890.02,
        11886.35,
        11881.41,
        11880.14,
        10155.23,
        33.58,
        8.05,
        39.19,
        1.12,
        4.87,
        1.84,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '441') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '222'\n  AND m.movie_id <= '313'\n  AND t.production_year = '1985'\n  AND c.nr_order = '441'\nGROUP BY m.movie_id;": [
        3753.18,
        2815.45,
        2813.01,
        2811.74,
        2809.9,
        2803.07,
        2627.55,
        10.7,
        8.36,
        58.5,
        6.77,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '12100') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '154'\n  AND m.movie_id <= '233'\n  AND t.production_year = '1927'\n  AND c.nr_order = '12100'\nGROUP BY m.movie_id;": [
        3320.18,
        2382.45,
        2380.01,
        2378.74,
        2345.88,
        2344.04,
        2326.63,
        9.97,
        8.36,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1036') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '6'\n  AND m.movie_id <= '465'\n  AND t.production_year = '1951'\n  AND c.nr_order = '1036'\nGROUP BY m.movie_id;": [
        12670.73,
        11733.0,
        11730.56,
        11729.29,
        11727.45,
        11714.46,
        11395.37,
        36.81,
        8.0,
        106.35,
        12.93,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '11002') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '243'\n  AND m.movie_id <= '454'\n  AND t.production_year = '1973'\n  AND c.nr_order = '11002'\nGROUP BY m.movie_id;": [
        6792.43,
        5854.69,
        5852.25,
        5850.98,
        5849.15,
        5841.32,
        5565.22,
        17.91,
        8.23,
        69.01,
        7.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2303') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '149'\n  AND m.movie_id <= '171'\n  AND t.production_year = '2010'\n  AND c.nr_order = '2303'\nGROUP BY m.movie_id;": [
        2070.79,
        1133.06,
        1130.62,
        1129.35,
        1127.51,
        1122.81,
        902.26,
        6.56,
        8.45,
        36.75,
        4.64,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '49') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '80'\n  AND m.movie_id <= '376'\n  AND t.production_year = '1925'\n  AND c.nr_order = '49'\nGROUP BY m.movie_id;": [
        8690.01,
        7752.27,
        7749.83,
        7748.56,
        7746.73,
        7738.15,
        7609.54,
        27.04,
        8.15,
        128.59,
        8.52,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '822') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '423'\n  AND m.movie_id <= '482'\n  AND t.production_year = '1965'\n  AND c.nr_order = '822'\nGROUP BY m.movie_id;": [
        2859.83,
        1922.09,
        1919.65,
        1918.38,
        1916.55,
        1907.93,
        1830.43,
        8.78,
        8.39,
        77.49,
        8.55,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '10000') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '432'\n  AND m.movie_id <= '499'\n  AND t.production_year = '1898'\n  AND c.nr_order = '10000'\nGROUP BY m.movie_id;": [
        3023.26,
        2085.53,
        2083.09,
        2081.82,
        2048.96,
        2047.12,
        2029.71,
        9.26,
        8.38,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '501') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '180'\n  AND m.movie_id <= '238'\n  AND t.production_year = '1981'\n  AND c.nr_order = '501'\nGROUP BY m.movie_id;": [
        2825.58,
        1887.84,
        1885.4,
        1884.13,
        1882.3,
        1874.44,
        1805.02,
        8.72,
        8.39,
        69.41,
        7.8,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '20001') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '356'\n  AND m.movie_id <= '379'\n  AND t.production_year = '1970'\n  AND c.nr_order = '20001'\nGROUP BY m.movie_id;": [
        1948.23,
        1010.49,
        1008.05,
        1006.78,
        1004.95,
        997.09,
        927.67,
        6.61,
        8.45,
        69.41,
        7.8,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '387') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '9'\n  AND m.movie_id <= '384'\n  AND t.production_year = '2013'\n  AND c.nr_order = '387'\nGROUP BY m.movie_id;": [
        11594.57,
        10656.83,
        10654.39,
        10653.12,
        10651.29,
        10646.06,
        9460.93,
        31.78,
        8.08,
        42.31,
        5.17,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '209') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '135'\n  AND m.movie_id <= '204'\n  AND t.production_year = '1929'\n  AND c.nr_order = '209'\nGROUP BY m.movie_id;": [
        3074.08,
        2136.35,
        2133.91,
        2132.64,
        2099.78,
        2097.94,
        2080.53,
        9.38,
        8.39,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '378') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '84'\n  AND m.movie_id <= '108'\n  AND t.production_year = '1940'\n  AND c.nr_order = '378'\nGROUP BY m.movie_id;": [
        1946.64,
        1008.9,
        1006.46,
        1005.19,
        972.33,
        970.49,
        953.08,
        6.67,
        8.45,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '6100') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '17'\n  AND m.movie_id <= '198'\n  AND t.production_year = '2011'\n  AND c.nr_order = '6100'\nGROUP BY m.movie_id;": [
        7098.04,
        6160.31,
        6157.87,
        6156.6,
        6154.76,
        6150.1,
        4842.92,
        16.11,
        8.27,
        36.3,
        4.6,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '391') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '163'\n  AND m.movie_id <= '305'\n  AND t.production_year = '1980'\n  AND c.nr_order = '391'\nGROUP BY m.movie_id;": [
        5051.16,
        4113.42,
        4110.98,
        4109.71,
        4107.88,
        4099.9,
        3887.93,
        13.78,
        8.3,
        70.65,
        7.91,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '950508') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '419'\n  AND m.movie_id <= '444'\n  AND t.production_year = '1966'\n  AND c.nr_order = '950508'\nGROUP BY m.movie_id;": [
        2002.36,
        1064.62,
        1062.19,
        1060.92,
        1059.08,
        1050.94,
        978.49,
        6.74,
        8.45,
        72.44,
        8.08,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '23002') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '191'\n  AND m.movie_id <= '306'\n  AND t.production_year = '2015'\n  AND c.nr_order = '23002'\nGROUP BY m.movie_id;": [
        4252.28,
        3314.54,
        3312.1,
        3310.83,
        3309.0,
        3243.27,
        3225.86,
        12.15,
        8.33,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1015') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '30'\n  AND m.movie_id <= '54'\n  AND t.production_year = '1962'\n  AND c.nr_order = '1015'\nGROUP BY m.movie_id;": [
        1971.54,
        1033.81,
        1031.37,
        1030.1,
        1028.26,
        962.54,
        953.08,
        6.67,
        8.45,
        9.4,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '350257462') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '189'\n  AND m.movie_id <= '295'\n  AND t.production_year = '1994'\n  AND c.nr_order = '350257462'\nGROUP BY m.movie_id;": [
        4160.69,
        3222.95,
        3220.52,
        3219.25,
        3217.41,
        3211.27,
        3005.17,
        11.62,
        8.34,
        51.51,
        6.08,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '361') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '125'\n  AND m.movie_id <= '504'\n  AND t.production_year = '2008'\n  AND c.nr_order = '361'\nGROUP BY m.movie_id;": [
        12700.18,
        11762.44,
        11760.0,
        11758.73,
        11756.9,
        11752.14,
        9554.57,
        32.02,
        8.08,
        37.23,
        4.69,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '3000') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '46'\n  AND m.movie_id <= '321'\n  AND t.production_year = '1987'\n  AND c.nr_order = '3000'\nGROUP BY m.movie_id;": [
        8484.49,
        7546.76,
        7544.32,
        7543.05,
        7541.21,
        7534.1,
        7103.46,
        25.75,
        8.17,
        61.51,
        7.05,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1401') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '173'\n  AND m.movie_id <= '303'\n  AND t.production_year = '1891'\n  AND c.nr_order = '1401'\nGROUP BY m.movie_id;": [
        4625.43,
        3687.69,
        3685.25,
        3683.98,
        3682.15,
        3616.42,
        3599.01,
        13.06,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '978') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '6'\n  AND m.movie_id <= '427'\n  AND t.production_year = '1911'\n  AND c.nr_order = '978'\nGROUP BY m.movie_id;": [
        11795.75,
        10858.01,
        10855.57,
        10854.3,
        10852.47,
        10839.59,
        10521.79,
        34.54,
        8.04,
        105.92,
        12.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1078') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '37'\n  AND m.movie_id <= '238'\n  AND t.production_year = '1946'\n  AND c.nr_order = '1078'\nGROUP BY m.movie_id;": [
        6386.4,
        5448.67,
        5446.23,
        5444.96,
        5443.12,
        5344.53,
        5327.12,
        17.32,
        8.25,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2025') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '314'\n  AND m.movie_id <= '476'\n  AND t.production_year = '2009'\n  AND c.nr_order = '2025'\nGROUP BY m.movie_id;": [
        6329.32,
        5391.58,
        5389.14,
        5387.87,
        5386.04,
        5381.3,
        4380.13,
        14.97,
        8.28,
        37.07,
        4.67,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '250') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '190'\n  AND m.movie_id <= '207'\n  AND t.production_year = '1936'\n  AND c.nr_order = '250'\nGROUP BY m.movie_id;": [
        1766.18,
        828.44,
        826.01,
        824.74,
        791.87,
        790.04,
        775.21,
        6.25,
        8.45,
        14.76,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '800') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '146'\n  AND m.movie_id <= '393'\n  AND t.production_year = '1979'\n  AND c.nr_order = '800'\nGROUP BY m.movie_id;": [
        7717.92,
        6780.19,
        6777.75,
        6776.48,
        6774.65,
        6767.01,
        6431.98,
        20.07,
        8.2,
        66.99,
        7.57,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '199') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '273'\n  AND m.movie_id <= '339'\n  AND t.production_year = '1903'\n  AND c.nr_order = '199'\nGROUP BY m.movie_id;": [
        2997.85,
        2060.12,
        2057.68,
        2056.41,
        2023.55,
        2021.71,
        2004.3,
        9.2,
        8.38,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '75') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '20'\n  AND m.movie_id <= '192'\n  AND t.production_year = '1953'\n  AND c.nr_order = '75'\nGROUP BY m.movie_id;": [
        5684.86,
        4747.13,
        4744.69,
        4743.42,
        4741.58,
        4728.59,
        4622.23,
        15.58,
        8.27,
        106.35,
        12.93,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '95') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '367'\n  AND m.movie_id <= '372'\n  AND t.production_year = '1930'\n  AND c.nr_order = '95'\nGROUP BY m.movie_id;": [
        1462.09,
        524.35,
        521.92,
        520.65,
        487.78,
        485.95,
        470.29,
        5.53,
        8.45,
        15.59,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '461') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '32'\n  AND m.movie_id <= '497'\n  AND t.production_year = '1898'\n  AND c.nr_order = '461'\nGROUP BY m.movie_id;": [
        12620.02,
        11682.29,
        11679.85,
        11678.58,
        11676.74,
        11660.44,
        11531.83,
        37.18,
        8.0,
        128.59,
        16.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '329') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '185'\n  AND m.movie_id <= '296'\n  AND t.production_year = '1933'\n  AND c.nr_order = '329'\nGROUP BY m.movie_id;": [
        4158.64,
        3220.9,
        3218.46,
        3217.19,
        3215.36,
        3149.63,
        3132.22,
        11.92,
        8.34,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1025') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '332'\n  AND m.movie_id <= '484'\n  AND t.production_year = '1998'\n  AND c.nr_order = '1025'\nGROUP BY m.movie_id;": [
        5492.05,
        4554.32,
        4551.88,
        4550.61,
        4548.77,
        4543.25,
        4134.03,
        14.37,
        8.29,
        45.46,
        5.46,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '28000') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '385'\n  AND m.movie_id <= '406'\n  AND t.production_year = '1909'\n  AND c.nr_order = '28000'\nGROUP BY m.movie_id;": [
        1868.65,
        930.91,
        928.48,
        927.21,
        894.34,
        892.51,
        876.85,
        6.5,
        8.45,
        15.59,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '832') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '27'\n  AND m.movie_id <= '332'\n  AND t.production_year = '1917'\n  AND c.nr_order = '832'\nGROUP BY m.movie_id;": [
        9003.28,
        8065.55,
        8063.11,
        8061.84,
        8060.0,
        8045.92,
        7822.23,
        27.57,
        8.14,
        111.83,
        14.02,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '14101') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '68'\n  AND m.movie_id <= '94'\n  AND t.production_year = '1913'\n  AND c.nr_order = '14101'\nGROUP BY m.movie_id;": [
        2023.86,
        1086.12,
        1083.68,
        1082.41,
        1080.58,
        1014.85,
        1003.9,
        6.79,
        8.45,
        10.89,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '305') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '343'\n  AND m.movie_id <= '444'\n  AND t.production_year = '1949'\n  AND c.nr_order = '305'\nGROUP BY m.movie_id;": [
        3938.34,
        3000.61,
        2998.17,
        2996.9,
        2995.06,
        2896.47,
        2882.12,
        11.31,
        8.35,
        14.29,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '17101') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '198'\n  AND m.movie_id <= '509'\n  AND t.production_year = '1931'\n  AND c.nr_order = '17101'\nGROUP BY m.movie_id;": [
        9038.42,
        8100.69,
        8098.25,
        8096.98,
        8095.14,
        8079.38,
        7958.69,
        27.93,
        8.13,
        120.67,
        15.71,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '806') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '375'\n  AND m.movie_id <= '506'\n  AND t.production_year = '1945'\n  AND c.nr_order = '806'\nGROUP BY m.movie_id;": [
        4646.84,
        3709.1,
        3706.66,
        3705.39,
        3703.56,
        3637.83,
        3620.42,
        13.12,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '318') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '328'\n  AND m.movie_id <= '405'\n  AND t.production_year = '2017'\n  AND c.nr_order = '318'\nGROUP BY m.movie_id;": [
        3269.36,
        2331.63,
        2329.19,
        2327.92,
        2295.06,
        2293.22,
        2275.81,
        9.86,
        8.36,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1185') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '105'\n  AND m.movie_id <= '233'\n  AND t.production_year = '1958'\n  AND c.nr_order = '1185'\nGROUP BY m.movie_id;": [
        4677.04,
        3739.31,
        3736.87,
        3735.6,
        3733.76,
        3724.18,
        3548.19,
        12.94,
        8.32,
        87.98,
        9.52,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '30') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '76'\n  AND m.movie_id <= '181'\n  AND t.production_year = '1948'\n  AND c.nr_order = '30'\nGROUP BY m.movie_id;": [
        3977.31,
        3039.58,
        3037.14,
        3035.87,
        3003.01,
        3001.17,
        2983.76,
        11.56,
        8.35,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '233') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '98'\n  AND m.movie_id <= '324'\n  AND t.production_year = '1996'\n  AND c.nr_order = '233'\nGROUP BY m.movie_id;": [
        7363.51,
        6425.78,
        6423.34,
        6422.07,
        6420.23,
        6414.37,
        5926.37,
        18.82,
        8.22,
        48.79,
        5.8,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '428') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '196'\n  AND m.movie_id <= '365'\n  AND t.production_year = '1920'\n  AND c.nr_order = '428'\nGROUP BY m.movie_id;": [
        5619.21,
        4681.47,
        4679.04,
        4677.77,
        4675.93,
        4661.84,
        4550.0,
        15.4,
        8.27,
        111.83,
        14.02,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '271') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '420'\n  AND m.movie_id <= '514'\n  AND t.production_year = '1960'\n  AND c.nr_order = '271'\nGROUP BY m.movie_id;": [
        3732.34,
        2794.6,
        2792.16,
        2790.89,
        2789.06,
        2780.17,
        2699.78,
        10.88,
        8.35,
        80.38,
        8.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '31') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '51'\n  AND m.movie_id <= '169'\n  AND t.production_year = '1894'\n  AND c.nr_order = '31'\nGROUP BY m.movie_id;": [
        4328.51,
        3390.77,
        3388.33,
        3387.06,
        3385.23,
        3319.5,
        3302.09,
        12.34,
        8.33,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '226') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '225'\n  AND m.movie_id <= '268'\n  AND t.production_year = '2000'\n  AND c.nr_order = '226'\nGROUP BY m.movie_id;": [
        2550.02,
        1612.28,
        1609.84,
        1608.57,
        1606.74,
        1601.41,
        1427.87,
        7.81,
        8.4,
        43.37,
        5.27,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '962') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '32'\n  AND m.movie_id <= '278'\n  AND t.production_year = '1902'\n  AND c.nr_order = '962'\nGROUP BY m.movie_id;": [
        7465.85,
        6528.12,
        6525.68,
        6524.41,
        6522.57,
        6423.98,
        6406.57,
        20.01,
        8.2,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '980226') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '69'\n  AND m.movie_id <= '268'\n  AND t.production_year = '1919'\n  AND c.nr_order = '980226'\nGROUP BY m.movie_id;": [
        6346.08,
        5408.34,
        5405.9,
        5404.63,
        5402.8,
        5388.63,
        5276.3,
        17.19,
        8.24,
        112.31,
        14.11,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '904') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '42'\n  AND m.movie_id <= '219'\n  AND t.production_year = '1890'\n  AND c.nr_order = '904'\nGROUP BY m.movie_id;": [
        5771.7,
        4833.96,
        4831.52,
        4830.25,
        4828.42,
        4762.69,
        4745.28,
        15.87,
        8.27,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '22001') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '19'\n  AND m.movie_id <= '307'\n  AND t.production_year = '1924'\n  AND c.nr_order = '22001'\nGROUP BY m.movie_id;": [
        8497.99,
        7560.26,
        7557.82,
        7556.55,
        7554.71,
        7538.95,
        7418.26,
        26.56,
        8.16,
        120.67,
        15.71,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '264') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '84'\n  AND m.movie_id <= '261'\n  AND t.production_year = '1983'\n  AND c.nr_order = '264'\nGROUP BY m.movie_id;": [
        5964.22,
        5026.48,
        5024.04,
        5022.77,
        5020.94,
        5013.3,
        4745.28,
        15.87,
        8.27,
        66.99,
        7.57,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '351') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '102'\n  AND m.movie_id <= '110'\n  AND t.production_year = '1995'\n  AND c.nr_order = '351'\nGROUP BY m.movie_id;": [
        1544.42,
        606.68,
        604.24,
        602.97,
        601.14,
        595.28,
        546.52,
        5.71,
        8.45,
        48.75,
        5.8,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '400') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '282'\n  AND m.movie_id <= '410'\n  AND t.production_year = '1966'\n  AND c.nr_order = '400'\nGROUP BY m.movie_id;": [
        4644.51,
        3706.77,
        3704.33,
        3703.06,
        3701.23,
        3693.09,
        3548.19,
        12.94,
        8.32,
        72.44,
        8.08,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1052') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '90'\n  AND m.movie_id <= '281'\n  AND t.production_year = '2002'\n  AND c.nr_order = '1052'\nGROUP BY m.movie_id;": [
        6662.19,
        5724.45,
        5722.01,
        5720.74,
        5718.91,
        5713.69,
        5081.02,
        16.71,
        8.25,
        42.17,
        5.15,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '308') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '24'\n  AND m.movie_id <= '165'\n  AND t.production_year = '1912'\n  AND c.nr_order = '308'\nGROUP BY m.movie_id;": [
        5004.22,
        4066.49,
        4064.05,
        4062.78,
        4060.94,
        4050.83,
        3866.52,
        13.72,
        8.3,
        92.15,
        10.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1006') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '343'\n  AND m.movie_id <= '398'\n  AND t.production_year = '1956'\n  AND c.nr_order = '1006'\nGROUP BY m.movie_id;": [
        2777.59,
        1839.86,
        1837.42,
        1836.15,
        1834.31,
        1824.31,
        1732.79,
        8.54,
        8.41,
        91.51,
        9.94,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1048') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '152'\n  AND m.movie_id <= '216'\n  AND t.production_year = '1932'\n  AND c.nr_order = '1048'\nGROUP BY m.movie_id;": [
        2982.14,
        2044.41,
        2041.97,
        2040.7,
        2038.86,
        1973.14,
        1957.48,
        9.08,
        8.4,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '322') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '86'\n  AND m.movie_id <= '389'\n  AND t.production_year = '1991'\n  AND c.nr_order = '322'\nGROUP BY m.movie_id;": [
        9226.06,
        8288.32,
        8285.89,
        8284.62,
        8282.78,
        8276.18,
        7771.41,
        27.45,
        8.14,
        56.07,
        6.53,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '226') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '49'\n  AND m.movie_id <= '494'\n  AND t.production_year = '1972'\n  AND c.nr_order = '226'\nGROUP BY m.movie_id;": [
        12537.58,
        11599.84,
        11597.41,
        11596.14,
        11594.3,
        11586.11,
        11075.63,
        35.98,
        8.02,
        72.91,
        8.13,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '4100') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '337'\n  AND m.movie_id <= '485'\n  AND t.production_year = '2017'\n  AND c.nr_order = '4100'\nGROUP BY m.movie_id;": [
        5062.81,
        4125.07,
        4122.63,
        4121.36,
        4119.53,
        4053.8,
        4036.39,
        14.14,
        8.29,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '3200') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '37'\n  AND m.movie_id <= '54'\n  AND t.production_year = '1955'\n  AND c.nr_order = '3200'\nGROUP BY m.movie_id;": [
        1762.6,
        824.86,
        822.42,
        821.15,
        788.29,
        786.45,
        775.21,
        6.25,
        8.45,
        11.18,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1602') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '60'\n  AND m.movie_id <= '208'\n  AND t.production_year = '1977'\n  AND c.nr_order = '1602'\nGROUP BY m.movie_id;": [
        5208.91,
        4271.18,
        4268.74,
        4267.47,
        4265.63,
        4257.38,
        4036.39,
        14.14,
        8.29,
        73.65,
        8.19,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '4102') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '416'\n  AND m.movie_id <= '475'\n  AND t.production_year = '1910'\n  AND c.nr_order = '4102'\nGROUP BY m.movie_id;": [
        2852.54,
        1914.8,
        1912.36,
        1911.09,
        1909.26,
        1843.53,
        1830.43,
        8.78,
        8.39,
        13.04,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1135') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '254'\n  AND m.movie_id <= '277'\n  AND t.production_year = '1938'\n  AND c.nr_order = '1135'\nGROUP BY m.movie_id;": [
        1921.23,
        983.49,
        981.05,
        979.78,
        946.92,
        945.08,
        927.67,
        6.61,
        8.45,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '350') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '3'\n  AND m.movie_id <= '37'\n  AND t.production_year = '1948'\n  AND c.nr_order = '350'\nGROUP BY m.movie_id;": [
        2196.74,
        1259.0,
        1256.56,
        1255.29,
        1222.43,
        1220.59,
        1203.18,
        7.27,
        8.42,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1062') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '250'\n  AND m.movie_id <= '293'\n  AND t.production_year = '1969'\n  AND c.nr_order = '1062'\nGROUP BY m.movie_id;": [
        2445.23,
        1507.49,
        1505.05,
        1503.78,
        1501.95,
        1494.36,
        1427.87,
        7.81,
        8.4,
        66.48,
        7.52,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '149') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '362'\n  AND m.movie_id <= '442'\n  AND t.production_year = '1942'\n  AND c.nr_order = '149'\nGROUP BY m.movie_id;": [
        3345.59,
        2407.86,
        2405.42,
        2404.15,
        2371.29,
        2369.45,
        2352.04,
        10.04,
        8.36,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2125') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '118'\n  AND m.movie_id <= '309'\n  AND t.production_year = '1928'\n  AND c.nr_order = '2125'\nGROUP BY m.movie_id;": [
        6160.75,
        5223.02,
        5220.58,
        5219.31,
        5217.47,
        5201.71,
        5081.02,
        16.71,
        8.25,
        120.67,
        15.71,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '3500') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '288'\n  AND m.movie_id <= '489'\n  AND t.production_year = '1971'\n  AND c.nr_order = '3500'\nGROUP BY m.movie_id;": [
        6498.11,
        5560.38,
        5557.94,
        5556.67,
        5554.83,
        5546.62,
        5327.12,
        17.32,
        8.25,
        73.16,
        8.15,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '652') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '52'\n  AND m.movie_id <= '368'\n  AND t.production_year = '1969'\n  AND c.nr_order = '652'\nGROUP BY m.movie_id;": [
        9431.57,
        8493.84,
        8491.4,
        8490.13,
        8488.29,
        8480.71,
        8081.74,
        28.23,
        8.13,
        66.48,
        7.52,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1200') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '116'\n  AND m.movie_id <= '201'\n  AND t.production_year = '1934'\n  AND c.nr_order = '1200'\nGROUP BY m.movie_id;": [
        3468.64,
        2530.91,
        2528.47,
        2527.2,
        2494.34,
        2492.5,
        2475.09,
        10.34,
        8.36,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '436') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '62'\n  AND m.movie_id <= '488'\n  AND t.production_year = '2004'\n  AND c.nr_order = '436'\nGROUP BY m.movie_id;": [
        13392.37,
        12454.64,
        12452.2,
        12450.93,
        12449.09,
        12444.16,
        10640.84,
        34.84,
        8.03,
        39.19,
        4.87,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1984') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '185'\n  AND m.movie_id <= '315'\n  AND t.production_year = '1988'\n  AND c.nr_order = '1984'\nGROUP BY m.movie_id;": [
        4785.98,
        3848.24,
        3845.8,
        3844.53,
        3842.7,
        3835.8,
        3599.01,
        13.06,
        8.32,
        59.19,
        6.83,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2402') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '203'\n  AND m.movie_id <= '267'\n  AND t.production_year = '1915'\n  AND c.nr_order = '2402'\nGROUP BY m.movie_id;": [
        3010.37,
        2072.63,
        2070.19,
        2068.92,
        2067.09,
        2055.84,
        1957.48,
        9.08,
        8.4,
        98.35,
        11.18,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '38000') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '155'\n  AND m.movie_id <= '447'\n  AND t.production_year = '1916'\n  AND c.nr_order = '38000'\nGROUP BY m.movie_id;": [
        8686.88,
        7749.14,
        7746.7,
        7745.43,
        7743.6,
        7730.38,
        7515.9,
        26.79,
        8.16,
        107.23,
        13.16,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '18') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '1'\n  AND m.movie_id <= '392'\n  AND t.production_year = '1893'\n  AND c.nr_order = '18'\nGROUP BY m.movie_id;": [
        10908.02,
        9970.29,
        9967.85,
        9966.58,
        9964.74,
        9960.1,
        9831.49,
        32.73,
        8.06,
        128.59,
        4.58,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2121') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '263'\n  AND m.movie_id <= '407'\n  AND t.production_year = '2000'\n  AND c.nr_order = '2121'\nGROUP BY m.movie_id;": [
        5321.21,
        4383.47,
        4381.04,
        4379.77,
        4377.93,
        4372.6,
        3938.75,
        13.9,
        8.3,
        43.37,
        5.27,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1075') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '8'\n  AND m.movie_id <= '346'\n  AND t.production_year = '1973'\n  AND c.nr_order = '1075'\nGROUP BY m.movie_id;": [
        9962.02,
        9024.29,
        9021.85,
        9020.58,
        9018.74,
        9010.92,
        8596.76,
        29.56,
        8.11,
        69.01,
        7.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '606') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '284'\n  AND m.movie_id <= '502'\n  AND t.production_year = '1900'\n  AND c.nr_order = '606'\nGROUP BY m.movie_id;": [
        6794.37,
        5856.64,
        5854.2,
        5852.93,
        5851.09,
        5752.5,
        5735.09,
        18.33,
        8.23,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '916') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '206'\n  AND m.movie_id <= '358'\n  AND t.production_year = '1926'\n  AND c.nr_order = '916'\nGROUP BY m.movie_id;": [
        5160.45,
        4222.71,
        4220.27,
        4219.0,
        4217.17,
        4151.44,
        4134.03,
        14.37,
        8.29,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '127') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '103'\n  AND m.movie_id <= '371'\n  AND t.production_year = '1954'\n  AND c.nr_order = '127'\nGROUP BY m.movie_id;": [
        8180.3,
        7242.57,
        7240.13,
        7238.86,
        7237.02,
        7226.2,
        6937.59,
        25.33,
        8.18,
        96.19,
        10.75,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '9100') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '249'\n  AND m.movie_id <= '298'\n  AND t.production_year = '1976'\n  AND c.nr_order = '9100'\nGROUP BY m.movie_id;": [
        2605.26,
        1667.52,
        1665.08,
        1663.81,
        1661.98,
        1653.74,
        1580.33,
        8.18,
        8.41,
        73.4,
        8.17,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1279') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '163'\n  AND m.movie_id <= '184'\n  AND t.production_year = '1918'\n  AND c.nr_order = '1279'\nGROUP BY m.movie_id;": [
        1866.82,
        929.08,
        926.65,
        925.38,
        892.51,
        890.68,
        876.85,
        6.5,
        8.45,
        13.77,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '180') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '451'\n  AND m.movie_id <= '457'\n  AND t.production_year = '1895'\n  AND c.nr_order = '180'\nGROUP BY m.movie_id;": [
        1489.26,
        551.52,
        549.08,
        547.81,
        514.95,
        513.11,
        495.7,
        5.59,
        8.45,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1126') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '66'\n  AND m.movie_id <= '451'\n  AND t.production_year = '1913'\n  AND c.nr_order = '1126'\nGROUP BY m.movie_id;": [
        11032.91,
        10095.18,
        10092.74,
        10091.47,
        10089.63,
        10078.68,
        9691.03,
        32.38,
        8.07,
        96.9,
        10.89,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '243') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '288'\n  AND m.movie_id <= '348'\n  AND t.production_year = '1904'\n  AND c.nr_order = '243'\nGROUP BY m.movie_id;": [
        2849.39,
        1911.66,
        1909.22,
        1907.95,
        1875.09,
        1873.25,
        1855.84,
        8.84,
        8.4,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '42') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '179'\n  AND m.movie_id <= '433'\n  AND t.production_year = '1920'\n  AND c.nr_order = '42'\nGROUP BY m.movie_id;": [
        7668.41,
        6730.68,
        6728.24,
        6726.97,
        6725.13,
        6717.69,
        6605.85,
        24.5,
        8.2,
        111.83,
        7.38,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '113') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '23'\n  AND m.movie_id <= '412'\n  AND t.production_year = '1921'\n  AND c.nr_order = '113'\nGROUP BY m.movie_id;": [
        10876.86,
        9939.13,
        9936.69,
        9935.42,
        9933.58,
        9917.28,
        9788.67,
        32.62,
        8.07,
        128.59,
        16.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '102484') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '43'\n  AND m.movie_id <= '138'\n  AND t.production_year = '2011'\n  AND c.nr_order = '102484'\nGROUP BY m.movie_id;": [
        4407.81,
        3470.08,
        3467.64,
        3466.37,
        3464.53,
        3459.87,
        2733.66,
        10.96,
        8.35,
        36.3,
        4.6,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '191') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '251'\n  AND m.movie_id <= '475'\n  AND t.production_year = '2003'\n  AND c.nr_order = '191'\nGROUP BY m.movie_id;": [
        7647.1,
        6709.37,
        6706.93,
        6705.66,
        6703.82,
        6698.74,
        5883.55,
        18.69,
        8.23,
        40.75,
        5.02,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '3007') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '120'\n  AND m.movie_id <= '449'\n  AND t.production_year = '2005'\n  AND c.nr_order = '3007'\nGROUP BY m.movie_id;": [
        10838.44,
        9900.7,
        9898.26,
        9896.99,
        9895.16,
        9890.28,
        8384.07,
        29.01,
        8.12,
        38.61,
        4.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '99') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '14'\n  AND m.movie_id <= '73'\n  AND t.production_year = '2016'\n  AND c.nr_order = '99'\nGROUP BY m.movie_id;": [
        2823.98,
        1886.25,
        1883.81,
        1882.54,
        1849.68,
        1847.84,
        1830.43,
        8.78,
        8.39,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '157') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '77'\n  AND m.movie_id <= '468'\n  AND t.production_year = '1990'\n  AND c.nr_order = '157'\nGROUP BY m.movie_id;": [
        11413.98,
        10476.24,
        10473.8,
        10472.53,
        10470.7,
        10463.97,
        9831.49,
        32.73,
        8.06,
        57.49,
        6.67,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '673377124') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '218'\n  AND m.movie_id <= '221'\n  AND t.production_year = '1978'\n  AND c.nr_order = '673377124'\nGROUP BY m.movie_id;": [
        1436.31,
        498.58,
        496.14,
        494.87,
        493.04,
        427.31,
        419.47,
        5.42,
        8.45,
        7.78,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '164550101') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '79'\n  AND m.movie_id <= '241'\n  AND t.production_year = '1944'\n  AND c.nr_order = '164550101'\nGROUP BY m.movie_id;": [
        5406.55,
        4468.81,
        4466.37,
        4465.1,
        4463.27,
        4397.54,
        4380.13,
        14.97,
        8.28,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '18002') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '240'\n  AND m.movie_id <= '332'\n  AND t.production_year = '1982'\n  AND c.nr_order = '18002'\nGROUP BY m.movie_id;": [
        3741.09,
        2803.35,
        2800.91,
        2799.64,
        2797.81,
        2789.85,
        2648.96,
        10.76,
        8.35,
        70.43,
        7.89,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '20010208') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '16'\n  AND m.movie_id <= '509'\n  AND t.production_year = '1906'\n  AND c.nr_order = '20010208'\nGROUP BY m.movie_id;": [
        13263.97,
        12326.24,
        12323.8,
        12322.53,
        12320.69,
        12304.39,
        12175.78,
        38.88,
        7.97,
        128.59,
        16.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '370') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '350'\n  AND m.movie_id <= '389'\n  AND t.production_year = '1983'\n  AND c.nr_order = '370'\nGROUP BY m.movie_id;": [
        2348.15,
        1410.41,
        1407.97,
        1406.7,
        1404.87,
        1397.23,
        1330.23,
        7.58,
        8.42,
        66.99,
        7.57,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '8000') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '115'\n  AND m.movie_id <= '159'\n  AND t.production_year = '1960'\n  AND c.nr_order = '8000'\nGROUP BY m.movie_id;": [
        2485.84,
        1548.1,
        1545.66,
        1544.39,
        1542.56,
        1533.67,
        1453.28,
        7.87,
        8.4,
        80.38,
        8.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '15101') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '273'\n  AND m.movie_id <= '300'\n  AND t.production_year = '1896'\n  AND c.nr_order = '15101'\nGROUP BY m.movie_id;": [
        2018.86,
        1081.13,
        1078.69,
        1077.42,
        1044.56,
        1042.72,
        1025.31,
        6.85,
        8.42,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '26001') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '23'\n  AND m.movie_id <= '149'\n  AND t.production_year = '1991'\n  AND c.nr_order = '26001'\nGROUP BY m.movie_id;": [
        4671.59,
        3733.85,
        3731.41,
        3730.14,
        3728.31,
        3721.71,
        3497.37,
        12.82,
        8.32,
        56.07,
        6.53,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '704') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '326'\n  AND m.movie_id <= '430'\n  AND t.production_year = '1988'\n  AND c.nr_order = '704'\nGROUP BY m.movie_id;": [
        4086.12,
        3148.38,
        3145.94,
        3144.67,
        3142.84,
        3135.94,
        2958.35,
        11.5,
        8.35,
        59.19,
        6.83,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '214') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '399'\n  AND t.production_year = '1957'\n  AND c.nr_order = '214'\nGROUP BY m.movie_id;": [
        2070.35,
        1132.61,
        1130.17,
        1128.9,
        1127.07,
        1061.34,
        1050.72,
        6.92,
        8.42,
        10.56,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '128') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '67'\n  AND m.movie_id <= '415'\n  AND t.production_year = '1957'\n  AND c.nr_order = '128'\nGROUP BY m.movie_id;": [
        10070.24,
        9132.5,
        9130.06,
        9128.79,
        9126.96,
        9116.34,
        8830.86,
        30.15,
        8.1,
        95.15,
        10.56,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '91') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '100'\n  AND m.movie_id <= '422'\n  AND t.production_year = '1931'\n  AND c.nr_order = '91'\nGROUP BY m.movie_id;": [
        9301.93,
        8364.2,
        8361.76,
        8360.49,
        8358.65,
        8342.89,
        8222.2,
        28.59,
        8.13,
        120.67,
        15.71,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1990') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '226'\n  AND m.movie_id <= '380'\n  AND t.production_year = '2013'\n  AND c.nr_order = '1990'\nGROUP BY m.movie_id;": [
        5641.27,
        4703.53,
        4701.09,
        4699.82,
        4697.99,
        4692.76,
        4184.85,
        14.5,
        8.29,
        42.31,
        5.17,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '381'\n  AND m.movie_id <= '474'\n  AND t.production_year = '1952'\n  AND c.nr_order = '2'\nGROUP BY m.movie_id;": [
        5627.99,
        2793.47,
        2786.16,
        2780.65,
        2776.27,
        2775.0,
        2674.37,
        10.81,
        8.35,
        100.62,
        1.12,
        4.32,
        1.84,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '950508') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '94'\n  AND m.movie_id <= '133'\n  AND t.production_year = '1968'\n  AND c.nr_order = '950508'\nGROUP BY m.movie_id;": [
        2354.1,
        1416.36,
        1413.93,
        1412.66,
        1410.82,
        1402.68,
        1330.23,
        7.58,
        8.42,
        72.44,
        8.08,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '118') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '137'\n  AND m.movie_id <= '320'\n  AND t.production_year = '1986'\n  AND c.nr_order = '118'\nGROUP BY m.movie_id;": [
        6139.08,
        5201.34,
        5198.91,
        5197.64,
        5195.8,
        5188.85,
        4889.74,
        16.23,
        8.26,
        59.81,
        6.89,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '8') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '60'\n  AND m.movie_id <= '211'\n  AND t.production_year = '1997'\n  AND c.nr_order = '8'\nGROUP BY m.movie_id;": [
        15072.77,
        4540.81,
        4496.9,
        4463.86,
        4450.58,
        4448.89,
        4112.62,
        14.32,
        8.3,
        48.03,
        1.18,
        1.12,
        4.36,
        1.84,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1776') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '479'\n  AND m.movie_id <= '516'\n  AND t.production_year = '1901'\n  AND c.nr_order = '1776'\nGROUP BY m.movie_id;": [
        2272.97,
        1335.23,
        1332.79,
        1331.52,
        1298.66,
        1296.82,
        1279.41,
        7.45,
        8.42,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1091') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '408'\n  AND m.movie_id <= '425'\n  AND t.production_year = '2019'\n  AND c.nr_order = '1091'\nGROUP BY m.movie_id;": [
        1768.77,
        831.03,
        828.59,
        827.32,
        794.46,
        792.62,
        775.21,
        6.25,
        8.45,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1008') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '352'\n  AND m.movie_id <= '439'\n  AND t.production_year = '1908'\n  AND c.nr_order = '1008'\nGROUP BY m.movie_id;": [
        3519.46,
        2581.73,
        2579.29,
        2578.02,
        2545.16,
        2543.32,
        2525.91,
        10.46,
        8.36,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '77') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '211'\n  AND m.movie_id <= '458'\n  AND t.production_year = '1993'\n  AND c.nr_order = '77'\nGROUP BY m.movie_id;": [
        7806.84,
        6869.11,
        6866.67,
        6865.4,
        6863.56,
        6857.25,
        6431.98,
        20.07,
        8.2,
        53.15,
        6.25,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '1'\n  AND m.movie_id <= '1'\n  AND t.production_year = '1880'\n  AND c.nr_order = '2'\nGROUP BY m.movie_id;": [
        1251.6,
        399.06,
        396.62,
        395.35,
        362.49,
        360.65,
        343.24,
        5.24,
        8.45,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ]
}