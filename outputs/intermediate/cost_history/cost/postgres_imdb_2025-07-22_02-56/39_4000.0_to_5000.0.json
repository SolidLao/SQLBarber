{
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '1'\n  AND m.movie_id <= '1'\n  AND t.production_year = '1880'\n  AND c.nr_order = '2'\nGROUP BY m.movie_id;": [
        1251.6,
        399.06,
        396.62,
        395.35,
        362.49,
        360.65,
        343.24,
        5.24,
        8.45,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '143') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '144'\n  AND m.movie_id <= '325'\n  AND t.production_year = '1919'\n  AND c.nr_order = '143'\nGROUP BY m.movie_id;": [
        5912.7,
        4974.96,
        4972.52,
        4971.25,
        4969.42,
        4955.25,
        4842.92,
        16.11,
        8.27,
        112.31,
        14.11,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '711') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '404'\n  AND m.movie_id <= '410'\n  AND t.production_year = '1912'\n  AND c.nr_order = '711'\nGROUP BY m.movie_id;": [
        1481.95,
        544.21,
        541.77,
        540.5,
        507.64,
        505.8,
        495.7,
        5.59,
        8.45,
        10.04,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '264') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '77'\n  AND m.movie_id <= '281'\n  AND t.production_year = '1944'\n  AND c.nr_order = '264'\nGROUP BY m.movie_id;": [
        6458.63,
        5520.9,
        5518.46,
        5517.19,
        5515.35,
        5416.76,
        5399.35,
        17.5,
        8.24,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '4006') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '112'\n  AND m.movie_id <= '448'\n  AND t.production_year = '1910'\n  AND c.nr_order = '4006'\nGROUP BY m.movie_id;": [
        9719.92,
        8782.18,
        8779.74,
        8778.47,
        8776.64,
        8763.53,
        8549.94,
        29.43,
        8.11,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '369') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '124'\n  AND m.movie_id <= '314'\n  AND t.production_year = '1912'\n  AND c.nr_order = '369'\nGROUP BY m.movie_id;": [
        6197.31,
        5259.58,
        5257.14,
        5255.87,
        5254.03,
        5243.92,
        5059.61,
        16.65,
        8.25,
        92.15,
        10.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '22000') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '333'\n  AND m.movie_id <= '516'\n  AND t.production_year = '2012'\n  AND c.nr_order = '22000'\nGROUP BY m.movie_id;": [
        7214.35,
        6276.61,
        6274.18,
        6272.91,
        6271.07,
        6266.41,
        4889.74,
        16.23,
        8.26,
        36.22,
        4.59,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '296') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '44'\n  AND m.movie_id <= '212'\n  AND t.production_year = '1987'\n  AND c.nr_order = '296'\nGROUP BY m.movie_id;": [
        5721.06,
        4783.33,
        4780.89,
        4779.62,
        4777.78,
        4770.67,
        4524.59,
        15.33,
        8.27,
        61.51,
        7.05,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1021') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '388'\n  AND m.movie_id <= '509'\n  AND t.production_year = '1974'\n  AND c.nr_order = '1021'\nGROUP BY m.movie_id;": [
        4468.25,
        3530.52,
        3528.08,
        3526.81,
        3524.98,
        3516.94,
        3374.32,
        12.51,
        8.32,
        71.3,
        7.97,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '77') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '72'\n  AND m.movie_id <= '508'\n  AND t.production_year = '1951'\n  AND c.nr_order = '77'\nGROUP BY m.movie_id;": [
        12146.3,
        11208.57,
        11206.13,
        11204.86,
        11203.02,
        11190.03,
        10870.94,
        35.44,
        8.03,
        106.35,
        12.93,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1305') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '297'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1910'\n  AND c.nr_order = '1305'\nGROUP BY m.movie_id;": [
        4021.53,
        3083.79,
        3081.35,
        3080.08,
        3078.25,
        3065.15,
        2958.35,
        11.5,
        8.35,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '273') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '2'\n  AND m.movie_id <= '470'\n  AND t.production_year = '2013'\n  AND c.nr_order = '273'\nGROUP BY m.movie_id;": [
        13987.66,
        13049.92,
        13047.48,
        13046.21,
        13044.38,
        13039.15,
        11600.06,
        37.36,
        8.0,
        42.31,
        5.17,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '147') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '336'\n  AND m.movie_id <= '422'\n  AND t.production_year = '1913'\n  AND c.nr_order = '147'\nGROUP BY m.movie_id;": [
        3551.64,
        2613.91,
        2611.47,
        2610.2,
        2608.36,
        2597.41,
        2500.5,
        10.4,
        8.36,
        96.9,
        10.89,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '27001') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '27'\n  AND m.movie_id <= '219'\n  AND t.production_year = '1970'\n  AND c.nr_order = '27001'\nGROUP BY m.movie_id;": [
        6335.25,
        5397.51,
        5395.07,
        5393.8,
        5391.97,
        5384.11,
        5106.43,
        16.77,
        8.25,
        69.41,
        7.8,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '829') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '16'\n  AND m.movie_id <= '31'\n  AND t.production_year = '1961'\n  AND c.nr_order = '829'\nGROUP BY m.movie_id;": [
        1742.44,
        804.71,
        802.27,
        801.0,
        799.16,
        733.43,
        724.39,
        6.13,
        8.45,
        8.99,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '390') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '219'\n  AND m.movie_id <= '433'\n  AND t.production_year = '1952'\n  AND c.nr_order = '390'\nGROUP BY m.movie_id;": [
        6793.68,
        5855.95,
        5853.51,
        5852.24,
        5850.4,
        5838.71,
        5637.45,
        18.09,
        8.23,
        100.62,
        11.63,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2198') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '276'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1893'\n  AND c.nr_order = '2198'\nGROUP BY m.movie_id;": [
        4498.38,
        3560.64,
        3558.2,
        3556.93,
        3555.1,
        3489.37,
        3471.96,
        12.76,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '106') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '3'\n  AND m.movie_id <= '473'\n  AND t.production_year = '1963'\n  AND c.nr_order = '106'\nGROUP BY m.movie_id;": [
        13157.04,
        12219.31,
        12216.87,
        12215.6,
        12213.76,
        12204.94,
        11646.88,
        37.48,
        8.0,
        79.71,
        8.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '436') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '4'\n  AND m.movie_id <= '330'\n  AND t.production_year = '1896'\n  AND c.nr_order = '436'\nGROUP BY m.movie_id;": [
        9404.03,
        8466.3,
        8463.86,
        8462.59,
        8460.75,
        8444.45,
        8315.84,
        28.84,
        8.12,
        128.59,
        16.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '831') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '50'\n  AND m.movie_id <= '334'\n  AND t.production_year = '1991'\n  AND c.nr_order = '831'\nGROUP BY m.movie_id;": [
        8714.71,
        7776.98,
        7774.54,
        7773.27,
        7771.43,
        7764.84,
        7316.15,
        26.29,
        8.16,
        56.07,
        6.53,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1009') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '475'\n  AND m.movie_id <= '485'\n  AND t.production_year = '1979'\n  AND c.nr_order = '1009'\nGROUP BY m.movie_id;": [
        1613.98,
        676.24,
        673.8,
        672.53,
        670.7,
        604.97,
        597.34,
        5.83,
        8.45,
        7.57,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2198') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '275'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1896'\n  AND c.nr_order = '2198'\nGROUP BY m.movie_id;": [
        4523.79,
        3586.05,
        3583.61,
        3582.34,
        3580.51,
        3514.78,
        3497.37,
        12.82,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1305') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '297'\n  AND m.movie_id <= '403'\n  AND t.production_year = '1909'\n  AND c.nr_order = '1305'\nGROUP BY m.movie_id;": [
        4029.83,
        3092.1,
        3089.66,
        3088.39,
        3086.55,
        3020.83,
        3005.17,
        11.62,
        8.34,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1025') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '387'\n  AND m.movie_id <= '509'\n  AND t.production_year = '1974'\n  AND c.nr_order = '1025'\nGROUP BY m.movie_id;": [
        4493.66,
        3555.93,
        3553.49,
        3552.22,
        3550.39,
        3542.35,
        3399.73,
        12.58,
        8.32,
        71.3,
        7.97,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2031') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '201'\n  AND m.movie_id <= '357'\n  AND t.production_year = '1934'\n  AND c.nr_order = '2031'\nGROUP BY m.movie_id;": [
        5258.09,
        4320.35,
        4317.91,
        4316.64,
        4314.81,
        4249.08,
        4231.67,
        14.62,
        8.28,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '10000') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '36'\n  AND m.movie_id <= '348'\n  AND t.production_year = '1920'\n  AND c.nr_order = '10000'\nGROUP BY m.movie_id;": [
        9165.15,
        8227.42,
        8224.98,
        8223.71,
        8221.87,
        8207.79,
        7984.1,
        28.0,
        8.14,
        111.83,
        14.02,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2037') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '203'\n  AND m.movie_id <= '358'\n  AND t.production_year = '1934'\n  AND c.nr_order = '2037'\nGROUP BY m.movie_id;": [
        5236.68,
        4298.94,
        4296.5,
        4295.23,
        4293.4,
        4227.67,
        4210.26,
        14.56,
        8.29,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '266') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '49'\n  AND m.movie_id <= '85'\n  AND t.production_year = '1941'\n  AND c.nr_order = '266'\nGROUP BY m.movie_id;": [
        2247.56,
        1309.82,
        1307.38,
        1306.11,
        1273.25,
        1271.41,
        1254.0,
        7.4,
        8.42,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '90') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '369'\n  AND m.movie_id <= '516'\n  AND t.production_year = '1908'\n  AND c.nr_order = '90'\nGROUP BY m.movie_id;": [
        5037.4,
        4099.66,
        4097.22,
        4095.95,
        4094.12,
        4028.39,
        4010.98,
        14.08,
        8.29,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '90') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '516'\n  AND t.production_year = '1908'\n  AND c.nr_order = '90'\nGROUP BY m.movie_id;": [
        4990.58,
        4052.84,
        4050.4,
        4049.13,
        4047.3,
        3981.57,
        3964.16,
        13.96,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '155') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '106'\n  AND m.movie_id <= '450'\n  AND t.production_year = '1909'\n  AND c.nr_order = '155'\nGROUP BY m.movie_id;": [
        9816.28,
        8878.54,
        8876.1,
        8874.83,
        8873.0,
        8857.34,
        8737.22,
        29.92,
        8.11,
        120.11,
        15.59,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1279') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '185'\n  AND m.movie_id <= '414'\n  AND t.production_year = '1988'\n  AND c.nr_order = '1279'\nGROUP BY m.movie_id;": [
        7303.97,
        6366.23,
        6363.79,
        6362.52,
        6360.69,
        6353.79,
        5998.6,
        19.0,
        8.21,
        59.19,
        6.83,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1279') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '186'\n  AND m.movie_id <= '414'\n  AND t.production_year = '1988'\n  AND c.nr_order = '1279'\nGROUP BY m.movie_id;": [
        7278.56,
        6340.82,
        6338.38,
        6337.11,
        6335.28,
        6328.38,
        5973.19,
        18.93,
        8.21,
        59.19,
        6.83,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '24001') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '188'\n  AND m.movie_id <= '507'\n  AND t.production_year = '1933'\n  AND c.nr_order = '24001'\nGROUP BY m.movie_id;": [
        9238.16,
        8300.43,
        8297.99,
        8296.72,
        8294.88,
        8278.58,
        8149.97,
        28.42,
        8.13,
        128.59,
        16.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1077') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '100'\n  AND m.movie_id <= '344'\n  AND t.production_year = '1973'\n  AND c.nr_order = '1077'\nGROUP BY m.movie_id;": [
        7655.98,
        6718.25,
        6715.81,
        6714.54,
        6712.7,
        6704.88,
        6359.75,
        19.89,
        8.2,
        69.01,
        7.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1046') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '56'\n  AND m.movie_id <= '159'\n  AND t.production_year = '1918'\n  AND c.nr_order = '1046'\nGROUP BY m.movie_id;": [
        3988.64,
        3050.9,
        3048.46,
        3047.19,
        3045.36,
        2946.77,
        2932.94,
        11.44,
        8.35,
        13.77,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1077') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '99'\n  AND m.movie_id <= '344'\n  AND t.production_year = '1974'\n  AND c.nr_order = '1077'\nGROUP BY m.movie_id;": [
        7617.72,
        6679.98,
        6677.54,
        6676.27,
        6674.44,
        6666.4,
        6381.16,
        19.95,
        8.2,
        71.3,
        7.97,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '23100') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '186'\n  AND m.movie_id <= '506'\n  AND t.production_year = '1932'\n  AND c.nr_order = '23100'\nGROUP BY m.movie_id;": [
        9254.44,
        8316.7,
        8314.26,
        8312.99,
        8311.16,
        8295.5,
        8175.38,
        28.47,
        8.13,
        120.11,
        15.59,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '4006') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '113'\n  AND m.movie_id <= '446'\n  AND t.production_year = '1909'\n  AND c.nr_order = '4006'\nGROUP BY m.movie_id;": [
        9560.77,
        8623.03,
        8620.59,
        8619.32,
        8617.49,
        8601.83,
        8481.71,
        29.25,
        8.12,
        120.11,
        15.59,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1016') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '475'\n  AND m.movie_id <= '483'\n  AND t.production_year = '1977'\n  AND c.nr_order = '1016'\nGROUP BY m.movie_id;": [
        1563.78,
        626.05,
        623.61,
        622.34,
        620.5,
        554.77,
        546.52,
        5.71,
        8.45,
        8.19,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '155') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '106'\n  AND m.movie_id <= '449'\n  AND t.production_year = '1911'\n  AND c.nr_order = '155'\nGROUP BY m.movie_id;": [
        9883.83,
        8946.1,
        8943.66,
        8942.39,
        8940.56,
        8927.67,
        8715.81,
        29.86,
        8.11,
        105.92,
        12.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1306') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '294'\n  AND m.movie_id <= '404'\n  AND t.production_year = '1908'\n  AND c.nr_order = '1306'\nGROUP BY m.movie_id;": [
        4100.36,
        3162.63,
        3160.19,
        3158.92,
        3126.06,
        3124.22,
        3106.81,
        11.86,
        8.34,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1400') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '299'\n  AND m.movie_id <= '405'\n  AND t.production_year = '1908'\n  AND c.nr_order = '1400'\nGROUP BY m.movie_id;": [
        3998.72,
        3060.99,
        3058.55,
        3057.28,
        3024.42,
        3022.58,
        3005.17,
        11.62,
        8.34,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2303') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '276'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1893'\n  AND c.nr_order = '2303'\nGROUP BY m.movie_id;": [
        4498.38,
        3560.64,
        3558.2,
        3556.93,
        3555.1,
        3489.37,
        3471.96,
        12.76,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '31') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '146'\n  AND m.movie_id <= '426'\n  AND t.production_year = '1940'\n  AND c.nr_order = '31'\nGROUP BY m.movie_id;": [
        8299.66,
        7361.92,
        7359.48,
        7358.21,
        7356.38,
        7351.12,
        7222.51,
        26.06,
        8.17,
        128.59,
        5.2,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2303') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '276'\n  AND m.movie_id <= '399'\n  AND t.production_year = '1895'\n  AND c.nr_order = '2303'\nGROUP BY m.movie_id;": [
        4451.56,
        3513.82,
        3511.38,
        3510.11,
        3508.28,
        3442.55,
        3425.14,
        12.63,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '95') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '518'\n  AND t.production_year = '1908'\n  AND c.nr_order = '95'\nGROUP BY m.movie_id;": [
        5037.4,
        4099.66,
        4097.22,
        4095.95,
        4094.12,
        4028.39,
        4010.98,
        14.08,
        8.29,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '89') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '518'\n  AND t.production_year = '1906'\n  AND c.nr_order = '89'\nGROUP BY m.movie_id;": [
        5037.4,
        4099.66,
        4097.22,
        4095.95,
        4094.12,
        4028.39,
        4010.98,
        14.08,
        8.29,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '463') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '459'\n  AND m.movie_id <= '488'\n  AND t.production_year = '2001'\n  AND c.nr_order = '463'\nGROUP BY m.movie_id;": [
        2153.93,
        1216.2,
        1213.76,
        1212.49,
        1210.65,
        1205.35,
        1076.13,
        6.97,
        8.42,
        43.06,
        5.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1036') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '389'\n  AND m.movie_id <= '509'\n  AND t.production_year = '1972'\n  AND c.nr_order = '1036'\nGROUP BY m.movie_id;": [
        4446.23,
        3508.49,
        3506.05,
        3504.78,
        3502.95,
        3494.76,
        3348.91,
        12.46,
        8.32,
        72.91,
        8.13,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1022') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '389'\n  AND m.movie_id <= '509'\n  AND t.production_year = '1972'\n  AND c.nr_order = '1022'\nGROUP BY m.movie_id;": [
        4446.23,
        3508.49,
        3506.05,
        3504.78,
        3502.95,
        3494.76,
        3348.91,
        12.46,
        8.32,
        72.91,
        8.13,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '224') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '311'\n  AND m.movie_id <= '386'\n  AND t.production_year = '1908'\n  AND c.nr_order = '224'\nGROUP BY m.movie_id;": [
        3226.54,
        2288.81,
        2286.37,
        2285.1,
        2252.24,
        2250.4,
        2232.99,
        9.74,
        8.39,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '218') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '312'\n  AND m.movie_id <= '385'\n  AND t.production_year = '1905'\n  AND c.nr_order = '218'\nGROUP BY m.movie_id;": [
        3175.72,
        2237.99,
        2235.55,
        2234.28,
        2201.42,
        2199.58,
        2182.17,
        9.62,
        8.39,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '4007') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '112'\n  AND m.movie_id <= '444'\n  AND t.production_year = '1907'\n  AND c.nr_order = '4007'\nGROUP BY m.movie_id;": [
        9544.49,
        8606.76,
        8604.32,
        8603.05,
        8601.21,
        8584.91,
        8456.3,
        29.2,
        8.12,
        128.59,
        16.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '795') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '38'\n  AND m.movie_id <= '45'\n  AND t.production_year = '1963'\n  AND c.nr_order = '795'\nGROUP BY m.movie_id;": [
        1506.07,
        568.34,
        565.9,
        564.63,
        531.76,
        529.93,
        521.11,
        5.66,
        8.45,
        8.76,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '65') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '191'\n  AND m.movie_id <= '236'\n  AND t.production_year = '1906'\n  AND c.nr_order = '65'\nGROUP BY m.movie_id;": [
        2472.24,
        1534.51,
        1532.07,
        1530.8,
        1497.94,
        1496.1,
        1478.69,
        7.93,
        8.4,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '27') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '332'\n  AND m.movie_id <= '427'\n  AND t.production_year = '2012'\n  AND c.nr_order = '27'\nGROUP BY m.movie_id;": [
        10115.75,
        3530.3,
        3513.23,
        3500.38,
        3495.72,
        3494.45,
        2733.66,
        10.96,
        8.35,
        36.22,
        1.12,
        4.59,
        1.84,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '60') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '192'\n  AND m.movie_id <= '238'\n  AND t.production_year = '1905'\n  AND c.nr_order = '60'\nGROUP BY m.movie_id;": [
        2497.65,
        1559.92,
        1557.48,
        1556.21,
        1523.35,
        1521.51,
        1504.1,
        8.0,
        8.41,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '280') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '147'\n  AND m.movie_id <= '468'\n  AND t.production_year = '1892'\n  AND c.nr_order = '280'\nGROUP BY m.movie_id;": [
        9288.98,
        8351.25,
        8348.81,
        8347.54,
        8345.7,
        8329.4,
        8200.79,
        28.54,
        8.13,
        128.59,
        16.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '280') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '148'\n  AND m.movie_id <= '469'\n  AND t.production_year = '1880'\n  AND c.nr_order = '280'\nGROUP BY m.movie_id;": [
        9288.98,
        8351.25,
        8348.81,
        8347.54,
        8345.7,
        8329.4,
        8200.79,
        28.54,
        8.13,
        128.59,
        16.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1175') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '63'\n  AND m.movie_id <= '153'\n  AND t.production_year = '1902'\n  AND c.nr_order = '1175'\nGROUP BY m.movie_id;": [
        3595.69,
        2657.96,
        2655.52,
        2654.25,
        2621.39,
        2619.55,
        2602.14,
        10.63,
        8.36,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '90') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '311'\n  AND m.movie_id <= '387'\n  AND t.production_year = '1978'\n  AND c.nr_order = '90'\nGROUP BY m.movie_id;": [
        3343.96,
        2406.23,
        2403.79,
        2402.52,
        2400.68,
        2392.84,
        2254.4,
        9.79,
        8.38,
        69.21,
        7.78,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '230') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '231'\n  AND m.movie_id <= '342'\n  AND t.production_year = '1960'\n  AND c.nr_order = '230'\nGROUP BY m.movie_id;": [
        4245.17,
        3307.44,
        3305.0,
        3303.73,
        3301.89,
        3293.01,
        3132.22,
        11.92,
        8.34,
        80.38,
        8.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1018') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '389'\n  AND m.movie_id <= '510'\n  AND t.production_year = '1973'\n  AND c.nr_order = '1018'\nGROUP BY m.movie_id;": [
        4463.47,
        3525.74,
        3523.3,
        3522.03,
        3520.19,
        3512.37,
        3374.32,
        12.51,
        8.32,
        69.01,
        7.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '226') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '180'\n  AND m.movie_id <= '505'\n  AND t.production_year = '2009'\n  AND c.nr_order = '226'\nGROUP BY m.movie_id;": [
        11203.71,
        10265.98,
        10263.54,
        10262.27,
        10260.43,
        10255.7,
        8290.43,
        28.78,
        8.12,
        37.07,
        4.67,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '263') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '100'\n  AND m.movie_id <= '473'\n  AND t.production_year = '1914'\n  AND c.nr_order = '263'\nGROUP BY m.movie_id;": [
        10660.24,
        9722.5,
        9720.06,
        9718.79,
        9716.96,
        9705.93,
        9414.11,
        31.65,
        8.08,
        97.26,
        10.96,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2198') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '275'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1895'\n  AND c.nr_order = '2198'\nGROUP BY m.movie_id;": [
        4523.79,
        3586.05,
        3583.61,
        3582.34,
        3580.51,
        3514.78,
        3497.37,
        12.82,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2153') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '275'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1893'\n  AND c.nr_order = '2153'\nGROUP BY m.movie_id;": [
        4523.79,
        3586.05,
        3583.61,
        3582.34,
        3580.51,
        3514.78,
        3497.37,
        12.82,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '317') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '53'\n  AND m.movie_id <= '105'\n  AND t.production_year = '2008'\n  AND c.nr_order = '317'\nGROUP BY m.movie_id;": [
        2977.06,
        2039.32,
        2036.88,
        2035.61,
        2033.78,
        2029.03,
        1656.56,
        8.36,
        8.41,
        37.23,
        4.69,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2303') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '276'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1895'\n  AND c.nr_order = '2303'\nGROUP BY m.movie_id;": [
        4498.38,
        3560.64,
        3558.2,
        3556.93,
        3555.1,
        3489.37,
        3471.96,
        12.76,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1092') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '8'\n  AND m.movie_id <= '488'\n  AND t.production_year = '1903'\n  AND c.nr_order = '1092'\nGROUP BY m.movie_id;": [
        12969.64,
        12031.91,
        12029.47,
        12028.2,
        12026.36,
        12010.06,
        11881.45,
        38.09,
        7.99,
        128.59,
        16.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2303') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '274'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1893'\n  AND c.nr_order = '2303'\nGROUP BY m.movie_id;": [
        4549.2,
        3611.46,
        3609.02,
        3607.75,
        3605.92,
        3540.19,
        3522.78,
        12.87,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '90') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '373'\n  AND m.movie_id <= '517'\n  AND t.production_year = '1908'\n  AND c.nr_order = '90'\nGROUP BY m.movie_id;": [
        4965.17,
        4027.43,
        4024.99,
        4023.72,
        4021.89,
        3956.16,
        3938.75,
        13.9,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '84') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '372'\n  AND m.movie_id <= '517'\n  AND t.production_year = '1907'\n  AND c.nr_order = '84'\nGROUP BY m.movie_id;": [
        4990.58,
        4052.84,
        4050.4,
        4049.13,
        4047.3,
        3981.57,
        3964.16,
        13.96,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '81') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '372'\n  AND m.movie_id <= '516'\n  AND t.production_year = '1907'\n  AND c.nr_order = '81'\nGROUP BY m.movie_id;": [
        4965.17,
        4027.43,
        4024.99,
        4023.72,
        4021.89,
        3956.16,
        3938.75,
        13.9,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '90') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '372'\n  AND m.movie_id <= '514'\n  AND t.production_year = '1908'\n  AND c.nr_order = '90'\nGROUP BY m.movie_id;": [
        4914.35,
        3976.61,
        3974.17,
        3972.9,
        3971.07,
        3905.34,
        3887.93,
        13.78,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '701') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '412'\n  AND m.movie_id <= '462'\n  AND t.production_year = '1901'\n  AND c.nr_order = '701'\nGROUP BY m.movie_id;": [
        2599.29,
        1661.56,
        1659.12,
        1657.85,
        1624.99,
        1623.15,
        1605.74,
        8.24,
        8.41,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1306') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '296'\n  AND m.movie_id <= '402'\n  AND t.production_year = '1908'\n  AND c.nr_order = '1306'\nGROUP BY m.movie_id;": [
        3998.72,
        3060.99,
        3058.55,
        3057.28,
        3024.42,
        3022.58,
        3005.17,
        11.62,
        8.34,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2034') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '139'\n  AND m.movie_id <= '171'\n  AND t.production_year = '1897'\n  AND c.nr_order = '2034'\nGROUP BY m.movie_id;": [
        2145.92,
        1208.18,
        1205.74,
        1204.47,
        1171.61,
        1169.77,
        1152.36,
        7.16,
        8.42,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1306') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '296'\n  AND m.movie_id <= '402'\n  AND t.production_year = '1907'\n  AND c.nr_order = '1306'\nGROUP BY m.movie_id;": [
        3998.72,
        3060.99,
        3058.55,
        3057.28,
        3024.42,
        3022.58,
        3005.17,
        11.62,
        8.34,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '57') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '406'\n  AND m.movie_id <= '478'\n  AND t.production_year = '1968'\n  AND c.nr_order = '57'\nGROUP BY m.movie_id;": [
        3180.63,
        2242.89,
        2240.45,
        2239.18,
        2237.35,
        2229.21,
        2156.76,
        9.56,
        8.39,
        72.44,
        8.08,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2303') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '276'\n  AND m.movie_id <= '400'\n  AND t.production_year = '1897'\n  AND c.nr_order = '2303'\nGROUP BY m.movie_id;": [
        4476.97,
        3539.23,
        3536.79,
        3535.52,
        3533.69,
        3467.96,
        3450.55,
        12.69,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '127') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '149'\n  AND m.movie_id <= '224'\n  AND t.production_year = '1926'\n  AND c.nr_order = '127'\nGROUP BY m.movie_id;": [
        3226.54,
        2288.81,
        2286.37,
        2285.1,
        2252.24,
        2250.4,
        2232.99,
        9.74,
        8.39,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '88') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '373'\n  AND m.movie_id <= '514'\n  AND t.production_year = '1907'\n  AND c.nr_order = '88'\nGROUP BY m.movie_id;": [
        4892.94,
        3955.2,
        3952.76,
        3951.49,
        3949.66,
        3883.93,
        3866.52,
        13.72,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '81') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '372'\n  AND m.movie_id <= '517'\n  AND t.production_year = '1906'\n  AND c.nr_order = '81'\nGROUP BY m.movie_id;": [
        4990.58,
        4052.84,
        4050.4,
        4049.13,
        4047.3,
        3981.57,
        3964.16,
        13.96,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1305') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '298'\n  AND m.movie_id <= '403'\n  AND t.production_year = '1909'\n  AND c.nr_order = '1305'\nGROUP BY m.movie_id;": [
        4008.42,
        3070.69,
        3068.25,
        3066.98,
        3065.14,
        2999.42,
        2983.76,
        11.56,
        8.35,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1306') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '298'\n  AND m.movie_id <= '403'\n  AND t.production_year = '1909'\n  AND c.nr_order = '1306'\nGROUP BY m.movie_id;": [
        4008.42,
        3070.69,
        3068.25,
        3066.98,
        3065.14,
        2999.42,
        2983.76,
        11.56,
        8.35,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1030') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '30'\n  AND m.movie_id <= '186'\n  AND t.production_year = '1990'\n  AND c.nr_order = '1030'\nGROUP BY m.movie_id;": [
        5411.67,
        4473.94,
        4471.5,
        4470.23,
        4468.39,
        4461.66,
        4231.67,
        14.62,
        8.28,
        57.49,
        6.67,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1303') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '294'\n  AND m.movie_id <= '404'\n  AND t.production_year = '1909'\n  AND c.nr_order = '1303'\nGROUP BY m.movie_id;": [
        4131.47,
        3193.74,
        3191.3,
        3190.03,
        3188.19,
        3122.47,
        3106.81,
        11.86,
        8.34,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1018') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '390'\n  AND m.movie_id <= '508'\n  AND t.production_year = '1969'\n  AND c.nr_order = '1018'\nGROUP BY m.movie_id;": [
        4452.44,
        3514.7,
        3512.26,
        3510.99,
        3509.16,
        3501.57,
        3302.09,
        12.34,
        8.33,
        66.48,
        7.52,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1038') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '388'\n  AND m.movie_id <= '508'\n  AND t.production_year = '1974'\n  AND c.nr_order = '1038'\nGROUP BY m.movie_id;": [
        4442.84,
        3505.11,
        3502.67,
        3501.4,
        3499.57,
        3491.53,
        3348.91,
        12.46,
        8.32,
        71.3,
        7.97,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1021') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '389'\n  AND m.movie_id <= '508'\n  AND t.production_year = '1972'\n  AND c.nr_order = '1021'\nGROUP BY m.movie_id;": [
        4420.82,
        3483.08,
        3480.64,
        3479.37,
        3477.54,
        3469.35,
        3323.5,
        12.4,
        8.32,
        72.91,
        8.13,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1802') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '379'\n  AND m.movie_id <= '461'\n  AND t.production_year = '1958'\n  AND c.nr_order = '1802'\nGROUP BY m.movie_id;": [
        3443.72,
        2505.98,
        2503.54,
        2502.27,
        2500.44,
        2490.85,
        2402.86,
        10.15,
        8.37,
        87.98,
        9.52,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '89') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '374'\n  AND m.movie_id <= '518'\n  AND t.production_year = '1906'\n  AND c.nr_order = '89'\nGROUP BY m.movie_id;": [
        4965.17,
        4027.43,
        4024.99,
        4023.72,
        4021.89,
        3956.16,
        3938.75,
        13.9,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '89') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '374'\n  AND m.movie_id <= '518'\n  AND t.production_year = '1907'\n  AND c.nr_order = '89'\nGROUP BY m.movie_id;": [
        4965.17,
        4027.43,
        4024.99,
        4023.72,
        4021.89,
        3956.16,
        3938.75,
        13.9,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '182') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '397'\n  AND m.movie_id <= '486'\n  AND t.production_year = '1938'\n  AND c.nr_order = '182'\nGROUP BY m.movie_id;": [
        3570.28,
        2632.55,
        2630.11,
        2628.84,
        2595.98,
        2594.14,
        2576.73,
        10.58,
        8.36,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '230') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '235'\n  AND m.movie_id <= '344'\n  AND t.production_year = '1961'\n  AND c.nr_order = '230'\nGROUP BY m.movie_id;": [
        4198.09,
        3260.35,
        3257.91,
        3256.64,
        3254.81,
        3245.76,
        3081.4,
        11.79,
        8.34,
        82.17,
        8.99,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '10101') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '63'\n  AND m.movie_id <= '105'\n  AND t.production_year = '1983'\n  AND c.nr_order = '10101'\nGROUP BY m.movie_id;": [
        2424.38,
        1486.64,
        1484.2,
        1482.93,
        1481.1,
        1473.46,
        1406.46,
        7.75,
        8.43,
        66.99,
        7.57,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '91') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '369'\n  AND m.movie_id <= '516'\n  AND t.production_year = '1907'\n  AND c.nr_order = '91'\nGROUP BY m.movie_id;": [
        5037.4,
        4099.66,
        4097.22,
        4095.95,
        4094.12,
        4028.39,
        4010.98,
        14.08,
        8.29,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '59') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '278'\n  AND m.movie_id <= '494'\n  AND t.production_year = '1982'\n  AND c.nr_order = '59'\nGROUP BY m.movie_id;": [
        6921.29,
        5983.55,
        5981.11,
        5979.84,
        5978.01,
        5970.05,
        5688.27,
        18.21,
        8.23,
        70.43,
        7.89,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '89') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1909'\n  AND c.nr_order = '89'\nGROUP BY m.movie_id;": [
        4996.28,
        4058.54,
        4056.1,
        4054.83,
        4053.0,
        3954.41,
        3938.75,
        13.9,
        8.3,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1022') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '386'\n  AND m.movie_id <= '509'\n  AND t.production_year = '1975'\n  AND c.nr_order = '1022'\nGROUP BY m.movie_id;": [
        4524.0,
        3586.27,
        3583.83,
        3582.56,
        3580.72,
        3572.46,
        3425.14,
        12.63,
        8.32,
        73.65,
        8.19,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1008') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '391'\n  AND m.movie_id <= '509'\n  AND t.production_year = '1974'\n  AND c.nr_order = '1008'\nGROUP BY m.movie_id;": [
        4396.02,
        3458.29,
        3455.85,
        3454.58,
        3452.75,
        3444.71,
        3302.09,
        12.34,
        8.33,
        71.3,
        7.97,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2121') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '359'\n  AND m.movie_id <= '392'\n  AND t.production_year = '1955'\n  AND c.nr_order = '2121'\nGROUP BY m.movie_id;": [
        2198.02,
        1260.29,
        1257.85,
        1256.58,
        1254.74,
        1189.01,
        1177.77,
        7.22,
        8.42,
        11.18,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2147') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '361'\n  AND m.movie_id <= '394'\n  AND t.production_year = '1957'\n  AND c.nr_order = '2147'\nGROUP BY m.movie_id;": [
        2197.4,
        1259.66,
        1257.22,
        1255.95,
        1254.12,
        1188.39,
        1177.77,
        7.22,
        8.42,
        10.56,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '232') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '233'\n  AND m.movie_id <= '342'\n  AND t.production_year = '1960'\n  AND c.nr_order = '232'\nGROUP BY m.movie_id;": [
        4194.35,
        3256.62,
        3254.18,
        3252.91,
        3251.07,
        3242.19,
        3081.4,
        11.79,
        8.34,
        80.38,
        8.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '233') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '233'\n  AND m.movie_id <= '346'\n  AND t.production_year = '1963'\n  AND c.nr_order = '233'\nGROUP BY m.movie_id;": [
        4290.58,
        3352.85,
        3350.41,
        3349.14,
        3347.3,
        3338.48,
        3179.04,
        12.04,
        8.33,
        79.71,
        8.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1021') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '390'\n  AND m.movie_id <= '507'\n  AND t.production_year = '1970'\n  AND c.nr_order = '1021'\nGROUP BY m.movie_id;": [
        4366.66,
        3428.92,
        3426.48,
        3425.21,
        3423.38,
        3415.52,
        3276.68,
        12.28,
        8.33,
        69.41,
        7.8,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '89') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '517'\n  AND t.production_year = '1905'\n  AND c.nr_order = '89'\nGROUP BY m.movie_id;": [
        5015.99,
        4078.25,
        4075.81,
        4074.54,
        4072.71,
        4006.98,
        3989.57,
        14.01,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1301') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '297'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1910'\n  AND c.nr_order = '1301'\nGROUP BY m.movie_id;": [
        4021.53,
        3083.79,
        3081.35,
        3080.08,
        3078.25,
        3065.15,
        2958.35,
        11.5,
        8.35,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2198') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '280'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1897'\n  AND c.nr_order = '2198'\nGROUP BY m.movie_id;": [
        4400.74,
        3463.0,
        3460.56,
        3459.29,
        3457.46,
        3391.73,
        3374.32,
        12.51,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2402') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '275'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1892'\n  AND c.nr_order = '2402'\nGROUP BY m.movie_id;": [
        4523.79,
        3586.05,
        3583.61,
        3582.34,
        3580.51,
        3514.78,
        3497.37,
        12.82,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2147') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '274'\n  AND m.movie_id <= '402'\n  AND t.production_year = '1894'\n  AND c.nr_order = '2147'\nGROUP BY m.movie_id;": [
        4574.61,
        3636.87,
        3634.43,
        3633.16,
        3631.33,
        3565.6,
        3548.19,
        12.94,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2302') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '274'\n  AND m.movie_id <= '402'\n  AND t.production_year = '1895'\n  AND c.nr_order = '2302'\nGROUP BY m.movie_id;": [
        4574.61,
        3636.87,
        3634.43,
        3633.16,
        3631.33,
        3565.6,
        3548.19,
        12.94,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1301') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '298'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1910'\n  AND c.nr_order = '1301'\nGROUP BY m.movie_id;": [
        3996.12,
        3058.38,
        3055.94,
        3054.67,
        3052.84,
        3039.74,
        2932.94,
        11.44,
        8.35,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1401') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '296'\n  AND m.movie_id <= '404'\n  AND t.production_year = '1910'\n  AND c.nr_order = '1401'\nGROUP BY m.movie_id;": [
        4119.17,
        3181.43,
        3178.99,
        3177.72,
        3175.89,
        3162.79,
        3055.99,
        11.74,
        8.34,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '93') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '374'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1906'\n  AND c.nr_order = '93'\nGROUP BY m.movie_id;": [
        4892.94,
        3955.2,
        3952.76,
        3951.49,
        3949.66,
        3883.93,
        3866.52,
        13.72,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '90') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '370'\n  AND m.movie_id <= '514'\n  AND t.production_year = '1905'\n  AND c.nr_order = '90'\nGROUP BY m.movie_id;": [
        4965.17,
        4027.43,
        4024.99,
        4023.72,
        4021.89,
        3956.16,
        3938.75,
        13.9,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '90') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '374'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1908'\n  AND c.nr_order = '90'\nGROUP BY m.movie_id;": [
        4892.94,
        3955.2,
        3952.76,
        3951.49,
        3949.66,
        3883.93,
        3866.52,
        13.72,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '90') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '374'\n  AND m.movie_id <= '517'\n  AND t.production_year = '1904'\n  AND c.nr_order = '90'\nGROUP BY m.movie_id;": [
        4939.76,
        4002.02,
        3999.58,
        3998.31,
        3996.48,
        3930.75,
        3913.34,
        13.83,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1400') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '293'\n  AND m.movie_id <= '404'\n  AND t.production_year = '1908'\n  AND c.nr_order = '1400'\nGROUP BY m.movie_id;": [
        4158.64,
        3220.9,
        3218.46,
        3217.19,
        3215.36,
        3149.63,
        3132.22,
        11.92,
        8.34,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1009') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '389'\n  AND m.movie_id <= '511'\n  AND t.production_year = '1973'\n  AND c.nr_order = '1009'\nGROUP BY m.movie_id;": [
        4488.88,
        3551.15,
        3548.71,
        3547.44,
        3545.6,
        3537.78,
        3399.73,
        12.58,
        8.32,
        69.01,
        7.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1305') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '292'\n  AND m.movie_id <= '406'\n  AND t.production_year = '1910'\n  AND c.nr_order = '1305'\nGROUP BY m.movie_id;": [
        4263.63,
        3325.89,
        3323.45,
        3322.18,
        3320.35,
        3307.25,
        3200.45,
        12.1,
        8.32,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2147') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '274'\n  AND m.movie_id <= '403'\n  AND t.production_year = '1895'\n  AND c.nr_order = '2147'\nGROUP BY m.movie_id;": [
        4600.02,
        3662.28,
        3659.84,
        3658.57,
        3656.74,
        3591.01,
        3573.6,
        13.0,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2303') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '275'\n  AND m.movie_id <= '403'\n  AND t.production_year = '1892'\n  AND c.nr_order = '2303'\nGROUP BY m.movie_id;": [
        4574.61,
        3636.87,
        3634.43,
        3633.16,
        3631.33,
        3565.6,
        3548.19,
        12.94,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1021') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '383'\n  AND m.movie_id <= '507'\n  AND t.production_year = '1974'\n  AND c.nr_order = '1021'\nGROUP BY m.movie_id;": [
        4544.48,
        3606.75,
        3604.31,
        3603.04,
        3601.21,
        3593.17,
        3450.55,
        12.69,
        8.32,
        71.3,
        7.97,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '70') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '202'\n  AND m.movie_id <= '442'\n  AND t.production_year = '1956'\n  AND c.nr_order = '70'\nGROUP BY m.movie_id;": [
        7493.95,
        6556.22,
        6553.78,
        6552.51,
        6550.67,
        6540.67,
        6266.11,
        19.65,
        8.21,
        91.51,
        9.94,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '88') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '512'\n  AND t.production_year = '1910'\n  AND c.nr_order = '88'\nGROUP BY m.movie_id;": [
        4929.7,
        3991.96,
        3989.52,
        3988.25,
        3986.42,
        3973.32,
        3866.52,
        13.72,
        8.3,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '89') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '512'\n  AND t.production_year = '1907'\n  AND c.nr_order = '89'\nGROUP BY m.movie_id;": [
        4892.94,
        3955.2,
        3952.76,
        3951.49,
        3949.66,
        3883.93,
        3866.52,
        13.72,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '84') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '514'\n  AND t.production_year = '1909'\n  AND c.nr_order = '84'\nGROUP BY m.movie_id;": [
        4970.87,
        4033.13,
        4030.69,
        4029.42,
        4027.59,
        3929.0,
        3913.34,
        13.83,
        8.3,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '88') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '514'\n  AND t.production_year = '1907'\n  AND c.nr_order = '88'\nGROUP BY m.movie_id;": [
        4939.76,
        4002.02,
        3999.58,
        3998.31,
        3996.48,
        3930.75,
        3913.34,
        13.83,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '89') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1910'\n  AND c.nr_order = '89'\nGROUP BY m.movie_id;": [
        5001.93,
        4064.19,
        4061.75,
        4060.48,
        4058.65,
        4045.55,
        3938.75,
        13.9,
        8.3,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '417') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '109'\n  AND m.movie_id <= '217'\n  AND t.production_year = '1926'\n  AND c.nr_order = '417'\nGROUP BY m.movie_id;": [
        4049.54,
        3111.81,
        3109.37,
        3108.1,
        3075.24,
        3073.4,
        3055.99,
        11.74,
        8.34,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '90') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '373'\n  AND m.movie_id <= '517'\n  AND t.production_year = '1904'\n  AND c.nr_order = '90'\nGROUP BY m.movie_id;": [
        4965.17,
        4027.43,
        4024.99,
        4023.72,
        4021.89,
        3956.16,
        3938.75,
        13.9,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1606') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '295'\n  AND m.movie_id <= '403'\n  AND t.production_year = '1909'\n  AND c.nr_order = '1606'\nGROUP BY m.movie_id;": [
        4080.65,
        3142.92,
        3140.48,
        3139.21,
        3137.37,
        3071.65,
        3055.99,
        11.74,
        8.34,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1305') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '296'\n  AND m.movie_id <= '400'\n  AND t.production_year = '1910'\n  AND c.nr_order = '1305'\nGROUP BY m.movie_id;": [
        4021.53,
        3083.79,
        3081.35,
        3080.08,
        3078.25,
        3065.15,
        2958.35,
        11.5,
        8.35,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '505') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '297'\n  AND m.movie_id <= '388'\n  AND t.production_year = '1948'\n  AND c.nr_order = '505'\nGROUP BY m.movie_id;": [
        3621.1,
        2683.37,
        2680.93,
        2679.66,
        2646.8,
        2644.96,
        2627.55,
        10.7,
        8.36,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '503') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '297'\n  AND m.movie_id <= '390'\n  AND t.production_year = '1949'\n  AND c.nr_order = '503'\nGROUP BY m.movie_id;": [
        3730.59,
        2792.86,
        2790.42,
        2789.15,
        2787.31,
        2688.72,
        2674.37,
        10.81,
        8.35,
        14.29,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1305') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '298'\n  AND m.movie_id <= '404'\n  AND t.production_year = '1909'\n  AND c.nr_order = '1305'\nGROUP BY m.movie_id;": [
        4029.83,
        3092.1,
        3089.66,
        3088.39,
        3086.55,
        3020.83,
        3005.17,
        11.62,
        8.34,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1279') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '293'\n  AND m.movie_id <= '403'\n  AND t.production_year = '1908'\n  AND c.nr_order = '1279'\nGROUP BY m.movie_id;": [
        4100.36,
        3162.63,
        3160.19,
        3158.92,
        3126.06,
        3124.22,
        3106.81,
        11.86,
        8.34,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1301') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '297'\n  AND m.movie_id <= '404'\n  AND t.production_year = '1907'\n  AND c.nr_order = '1301'\nGROUP BY m.movie_id;": [
        4024.13,
        3086.4,
        3083.96,
        3082.69,
        3049.83,
        3047.99,
        3030.58,
        11.68,
        8.34,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2303') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '270'\n  AND m.movie_id <= '402'\n  AND t.production_year = '1894'\n  AND c.nr_order = '2303'\nGROUP BY m.movie_id;": [
        4672.25,
        3734.51,
        3732.07,
        3730.8,
        3728.97,
        3663.24,
        3645.83,
        13.18,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1007') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '393'\n  AND m.movie_id <= '507'\n  AND t.production_year = '1973'\n  AND c.nr_order = '1007'\nGROUP BY m.movie_id;": [
        4289.6,
        3351.87,
        3349.43,
        3348.16,
        3346.32,
        3338.5,
        3200.45,
        12.1,
        8.32,
        69.01,
        7.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1015') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '392'\n  AND m.movie_id <= '513'\n  AND t.production_year = '1972'\n  AND c.nr_order = '1015'\nGROUP BY m.movie_id;": [
        4471.64,
        3533.9,
        3531.46,
        3530.19,
        3528.36,
        3520.17,
        3374.32,
        12.51,
        8.32,
        72.91,
        8.13,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '230') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '231'\n  AND m.movie_id <= '344'\n  AND t.production_year = '1960'\n  AND c.nr_order = '230'\nGROUP BY m.movie_id;": [
        4291.99,
        3354.26,
        3351.82,
        3350.55,
        3348.71,
        3339.83,
        3179.04,
        12.04,
        8.33,
        80.38,
        8.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '65') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '8'\n  AND m.movie_id <= '504'\n  AND t.production_year = '1999'\n  AND c.nr_order = '65'\nGROUP BY m.movie_id;": [
        14524.58,
        13586.85,
        13584.41,
        13583.14,
        13581.3,
        13575.88,
        12244.01,
        39.06,
        7.97,
        44.38,
        5.36,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '232') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '233'\n  AND m.movie_id <= '346'\n  AND t.production_year = '1962'\n  AND c.nr_order = '232'\nGROUP BY m.movie_id;": [
        4218.41,
        3280.67,
        3278.23,
        3276.96,
        3275.13,
        3265.67,
        3179.04,
        12.04,
        8.33,
        86.62,
        9.4,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '232') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '236'\n  AND m.movie_id <= '344'\n  AND t.production_year = '1961'\n  AND c.nr_order = '232'\nGROUP BY m.movie_id;": [
        4172.68,
        3234.94,
        3232.5,
        3231.23,
        3229.4,
        3220.35,
        3055.99,
        11.74,
        8.34,
        82.17,
        8.99,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1700') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '295'\n  AND m.movie_id <= '405'\n  AND t.production_year = '1910'\n  AND c.nr_order = '1700'\nGROUP BY m.movie_id;": [
        4169.99,
        3232.25,
        3229.81,
        3228.54,
        3226.71,
        3213.61,
        3106.81,
        11.86,
        8.34,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '99') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '163'\n  AND m.movie_id <= '316'\n  AND t.production_year = '1888'\n  AND c.nr_order = '99'\nGROUP BY m.movie_id;": [
        5185.86,
        4248.12,
        4245.68,
        4244.41,
        4242.58,
        4176.85,
        4159.44,
        14.44,
        8.29,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1022') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '390'\n  AND m.movie_id <= '511'\n  AND t.production_year = '1967'\n  AND c.nr_order = '1022'\nGROUP BY m.movie_id;": [
        4512.76,
        3575.03,
        3572.59,
        3571.32,
        3569.48,
        3562.26,
        3374.32,
        12.51,
        8.32,
        62.64,
        7.16,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '195') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '31'\n  AND m.movie_id <= '182'\n  AND t.production_year = '1969'\n  AND c.nr_order = '195'\nGROUP BY m.movie_id;": [
        5262.97,
        4325.23,
        4322.79,
        4321.52,
        4319.69,
        4312.1,
        4112.62,
        14.32,
        8.3,
        66.48,
        7.52,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '93') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '373'\n  AND m.movie_id <= '516'\n  AND t.production_year = '1906'\n  AND c.nr_order = '93'\nGROUP BY m.movie_id;": [
        4939.76,
        4002.02,
        3999.58,
        3998.31,
        3996.48,
        3930.75,
        3913.34,
        13.83,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '366') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '226'\n  AND m.movie_id <= '485'\n  AND t.production_year = '1905'\n  AND c.nr_order = '366'\nGROUP BY m.movie_id;": [
        7780.18,
        6842.45,
        6840.01,
        6838.74,
        6836.9,
        6738.31,
        6720.9,
        24.79,
        8.19,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '90') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '375'\n  AND m.movie_id <= '517'\n  AND t.production_year = '1905'\n  AND c.nr_order = '90'\nGROUP BY m.movie_id;": [
        4914.35,
        3976.61,
        3974.17,
        3972.9,
        3971.07,
        3905.34,
        3887.93,
        13.78,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '90') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '372'\n  AND m.movie_id <= '516'\n  AND t.production_year = '1905'\n  AND c.nr_order = '90'\nGROUP BY m.movie_id;": [
        4965.17,
        4027.43,
        4024.99,
        4023.72,
        4021.89,
        3956.16,
        3938.75,
        13.9,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '89') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '374'\n  AND m.movie_id <= '517'\n  AND t.production_year = '1908'\n  AND c.nr_order = '89'\nGROUP BY m.movie_id;": [
        4939.76,
        4002.02,
        3999.58,
        3998.31,
        3996.48,
        3930.75,
        3913.34,
        13.83,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '360') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '140'\n  AND m.movie_id <= '222'\n  AND t.production_year = '1964'\n  AND c.nr_order = '360'\nGROUP BY m.movie_id;": [
        3430.36,
        2492.63,
        2490.19,
        2488.92,
        2487.08,
        2478.63,
        2402.86,
        10.15,
        8.37,
        75.76,
        8.39,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1301') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '298'\n  AND m.movie_id <= '403'\n  AND t.production_year = '1909'\n  AND c.nr_order = '1301'\nGROUP BY m.movie_id;": [
        4008.42,
        3070.69,
        3068.25,
        3066.98,
        3065.14,
        2999.42,
        2983.76,
        11.56,
        8.35,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1047') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '388'\n  AND m.movie_id <= '507'\n  AND t.production_year = '1975'\n  AND c.nr_order = '1047'\nGROUP BY m.movie_id;": [
        4422.36,
        3484.63,
        3482.19,
        3480.92,
        3479.08,
        3470.82,
        3323.5,
        12.4,
        8.32,
        73.65,
        8.19,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2108') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '326'\n  AND m.movie_id <= '373'\n  AND t.production_year = '1902'\n  AND c.nr_order = '2108'\nGROUP BY m.movie_id;": [
        2523.06,
        1585.33,
        1582.89,
        1581.62,
        1548.76,
        1546.92,
        1529.51,
        8.06,
        8.41,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2303') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '276'\n  AND m.movie_id <= '398'\n  AND t.production_year = '1895'\n  AND c.nr_order = '2303'\nGROUP BY m.movie_id;": [
        4426.15,
        3488.41,
        3485.97,
        3484.7,
        3482.87,
        3417.14,
        3399.73,
        12.58,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '230') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '228'\n  AND m.movie_id <= '341'\n  AND t.production_year = '1962'\n  AND c.nr_order = '230'\nGROUP BY m.movie_id;": [
        4218.41,
        3280.67,
        3278.23,
        3276.96,
        3275.13,
        3265.67,
        3179.04,
        12.04,
        8.33,
        86.62,
        9.4,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1202') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '86'\n  AND m.movie_id <= '482'\n  AND t.production_year = '1918'\n  AND c.nr_order = '1202'\nGROUP BY m.movie_id;": [
        11124.49,
        10186.75,
        10184.31,
        10183.04,
        10181.21,
        10167.38,
        9946.54,
        33.04,
        8.06,
        110.41,
        13.77,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '93') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '374'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1908'\n  AND c.nr_order = '93'\nGROUP BY m.movie_id;": [
        4892.94,
        3955.2,
        3952.76,
        3951.49,
        3949.66,
        3883.93,
        3866.52,
        13.72,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '94') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '373'\n  AND m.movie_id <= '514'\n  AND t.production_year = '1907'\n  AND c.nr_order = '94'\nGROUP BY m.movie_id;": [
        4892.94,
        3955.2,
        3952.76,
        3951.49,
        3949.66,
        3883.93,
        3866.52,
        13.72,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '441875') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '243'\n  AND m.movie_id <= '339'\n  AND t.production_year = '1969'\n  AND c.nr_order = '441875'\nGROUP BY m.movie_id;": [
        3842.92,
        2905.19,
        2902.75,
        2901.48,
        2899.64,
        2892.06,
        2759.07,
        11.02,
        8.35,
        66.48,
        7.52,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '91') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '372'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1905'\n  AND c.nr_order = '91'\nGROUP BY m.movie_id;": [
        4939.76,
        4002.02,
        3999.58,
        3998.31,
        3996.48,
        3930.75,
        3913.34,
        13.83,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1075') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '38'\n  AND m.movie_id <= '178'\n  AND t.production_year = '1971'\n  AND c.nr_order = '1075'\nGROUP BY m.movie_id;": [
        4942.93,
        4005.2,
        4002.76,
        4001.49,
        3999.65,
        3991.44,
        3845.11,
        13.65,
        8.31,
        73.16,
        8.15,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1003') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '53'\n  AND m.movie_id <= '200'\n  AND t.production_year = '1976'\n  AND c.nr_order = '1003'\nGROUP BY m.movie_id;": [
        5182.74,
        4245.0,
        4242.56,
        4241.29,
        4239.46,
        4231.22,
        4010.98,
        14.08,
        8.29,
        73.4,
        8.17,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '57') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '290'\n  AND m.movie_id <= '510'\n  AND t.production_year = '1892'\n  AND c.nr_order = '57'\nGROUP BY m.movie_id;": [
        6845.19,
        5907.46,
        5905.02,
        5903.75,
        5901.91,
        5803.32,
        5785.91,
        18.45,
        8.23,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '90') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '375'\n  AND m.movie_id <= '518'\n  AND t.production_year = '1904'\n  AND c.nr_order = '90'\nGROUP BY m.movie_id;": [
        4939.76,
        4002.02,
        3999.58,
        3998.31,
        3996.48,
        3930.75,
        3913.34,
        13.83,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '91') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '372'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1903'\n  AND c.nr_order = '91'\nGROUP BY m.movie_id;": [
        4939.76,
        4002.02,
        3999.58,
        3998.31,
        3996.48,
        3930.75,
        3913.34,
        13.83,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '88') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '370'\n  AND m.movie_id <= '514'\n  AND t.production_year = '1905'\n  AND c.nr_order = '88'\nGROUP BY m.movie_id;": [
        4965.17,
        4027.43,
        4024.99,
        4023.72,
        4021.89,
        3956.16,
        3938.75,
        13.9,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '84') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1904'\n  AND c.nr_order = '84'\nGROUP BY m.movie_id;": [
        4965.17,
        4027.43,
        4024.99,
        4023.72,
        4021.89,
        3956.16,
        3938.75,
        13.9,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '228') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '235'\n  AND m.movie_id <= '343'\n  AND t.production_year = '1960'\n  AND c.nr_order = '228'\nGROUP BY m.movie_id;": [
        4168.94,
        3231.21,
        3228.77,
        3227.5,
        3225.66,
        3216.78,
        3055.99,
        11.74,
        8.34,
        80.38,
        8.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '793') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '271'\n  AND m.movie_id <= '411'\n  AND t.production_year = '1894'\n  AND c.nr_order = '793'\nGROUP BY m.movie_id;": [
        4871.53,
        3933.79,
        3931.35,
        3930.08,
        3928.25,
        3862.52,
        3845.11,
        13.65,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '36') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '89'\n  AND m.movie_id <= '334'\n  AND t.production_year = '1951'\n  AND c.nr_order = '36'\nGROUP BY m.movie_id;": [
        7543.73,
        6605.99,
        6603.55,
        6602.28,
        6600.45,
        6593.89,
        6381.16,
        19.95,
        8.2,
        106.35,
        6.5,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '88') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '514'\n  AND t.production_year = '1908'\n  AND c.nr_order = '88'\nGROUP BY m.movie_id;": [
        4939.76,
        4002.02,
        3999.58,
        3998.31,
        3996.48,
        3930.75,
        3913.34,
        13.83,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '78') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '372'\n  AND m.movie_id <= '517'\n  AND t.production_year = '1908'\n  AND c.nr_order = '78'\nGROUP BY m.movie_id;": [
        4990.58,
        4052.84,
        4050.4,
        4049.13,
        4047.3,
        3981.57,
        3964.16,
        13.96,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '88') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '373'\n  AND m.movie_id <= '512'\n  AND t.production_year = '1910'\n  AND c.nr_order = '88'\nGROUP BY m.movie_id;": [
        4882.88,
        3945.14,
        3942.7,
        3941.43,
        3939.6,
        3926.5,
        3819.7,
        13.6,
        8.31,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2198') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '276'\n  AND m.movie_id <= '398'\n  AND t.production_year = '1897'\n  AND c.nr_order = '2198'\nGROUP BY m.movie_id;": [
        4426.15,
        3488.41,
        3485.97,
        3484.7,
        3482.87,
        3417.14,
        3399.73,
        12.58,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2303') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '277'\n  AND m.movie_id <= '396'\n  AND t.production_year = '1895'\n  AND c.nr_order = '2303'\nGROUP BY m.movie_id;": [
        4349.92,
        3412.18,
        3409.74,
        3408.47,
        3406.64,
        3340.91,
        3323.5,
        12.4,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '795') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '272'\n  AND m.movie_id <= '409'\n  AND t.production_year = '1895'\n  AND c.nr_order = '795'\nGROUP BY m.movie_id;": [
        4795.3,
        3857.56,
        3855.12,
        3853.85,
        3852.02,
        3786.29,
        3768.88,
        13.47,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '90') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '372'\n  AND m.movie_id <= '517'\n  AND t.production_year = '1908'\n  AND c.nr_order = '90'\nGROUP BY m.movie_id;": [
        4990.58,
        4052.84,
        4050.4,
        4049.13,
        4047.3,
        3981.57,
        3964.16,
        13.96,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '84') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '372'\n  AND m.movie_id <= '512'\n  AND t.production_year = '1908'\n  AND c.nr_order = '84'\nGROUP BY m.movie_id;": [
        4871.53,
        3933.79,
        3931.35,
        3930.08,
        3928.25,
        3862.52,
        3845.11,
        13.65,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '88') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '377'\n  AND m.movie_id <= '518'\n  AND t.production_year = '1902'\n  AND c.nr_order = '88'\nGROUP BY m.movie_id;": [
        4892.94,
        3955.2,
        3952.76,
        3951.49,
        3949.66,
        3883.93,
        3866.52,
        13.72,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '78') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '372'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1908'\n  AND c.nr_order = '78'\nGROUP BY m.movie_id;": [
        4939.76,
        4002.02,
        3999.58,
        3998.31,
        3996.48,
        3930.75,
        3913.34,
        13.83,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '93') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '372'\n  AND m.movie_id <= '512'\n  AND t.production_year = '1908'\n  AND c.nr_order = '93'\nGROUP BY m.movie_id;": [
        4871.53,
        3933.79,
        3931.35,
        3930.08,
        3928.25,
        3862.52,
        3845.11,
        13.65,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '441') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '169'\n  AND m.movie_id <= '254'\n  AND t.production_year = '1963'\n  AND c.nr_order = '441'\nGROUP BY m.movie_id;": [
        3506.91,
        2569.18,
        2566.74,
        2565.47,
        2563.63,
        2554.81,
        2475.09,
        10.34,
        8.36,
        79.71,
        8.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '91') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '372'\n  AND m.movie_id <= '517'\n  AND t.production_year = '1908'\n  AND c.nr_order = '91'\nGROUP BY m.movie_id;": [
        4990.58,
        4052.84,
        4050.4,
        4049.13,
        4047.3,
        3981.57,
        3964.16,
        13.96,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '89') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '372'\n  AND m.movie_id <= '517'\n  AND t.production_year = '1905'\n  AND c.nr_order = '89'\nGROUP BY m.movie_id;": [
        4990.58,
        4052.84,
        4050.4,
        4049.13,
        4047.3,
        3981.57,
        3964.16,
        13.96,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1279') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '296'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1910'\n  AND c.nr_order = '1279'\nGROUP BY m.movie_id;": [
        4046.94,
        3109.2,
        3106.76,
        3105.49,
        3103.66,
        3090.56,
        2983.76,
        11.56,
        8.35,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1305') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '293'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1910'\n  AND c.nr_order = '1305'\nGROUP BY m.movie_id;": [
        4119.17,
        3181.43,
        3178.99,
        3177.72,
        3175.89,
        3162.79,
        3055.99,
        11.74,
        8.34,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1279') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '297'\n  AND m.movie_id <= '398'\n  AND t.production_year = '1910'\n  AND c.nr_order = '1279'\nGROUP BY m.movie_id;": [
        3945.3,
        3007.56,
        3005.12,
        3003.85,
        3002.02,
        2988.92,
        2882.12,
        11.31,
        8.35,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '23100') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '26'\n  AND m.movie_id <= '240'\n  AND t.production_year = '1986'\n  AND c.nr_order = '23100'\nGROUP BY m.movie_id;": [
        6886.79,
        5949.05,
        5946.62,
        5945.35,
        5943.51,
        5936.56,
        5637.45,
        18.09,
        8.23,
        59.81,
        6.89,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '90') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '370'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1905'\n  AND c.nr_order = '90'\nGROUP BY m.movie_id;": [
        4990.58,
        4052.84,
        4050.4,
        4049.13,
        4047.3,
        3981.57,
        3964.16,
        13.96,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1703') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '296'\n  AND m.movie_id <= '404'\n  AND t.production_year = '1909'\n  AND c.nr_order = '1703'\nGROUP BY m.movie_id;": [
        4080.65,
        3142.92,
        3140.48,
        3139.21,
        3137.37,
        3071.65,
        3055.99,
        11.74,
        8.34,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1306') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '294'\n  AND m.movie_id <= '406'\n  AND t.production_year = '1908'\n  AND c.nr_order = '1306'\nGROUP BY m.movie_id;": [
        4184.05,
        3246.31,
        3243.87,
        3242.6,
        3240.77,
        3175.04,
        3157.63,
        11.97,
        8.34,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1025') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '383'\n  AND m.movie_id <= '502'\n  AND t.production_year = '1974'\n  AND c.nr_order = '1025'\nGROUP BY m.movie_id;": [
        4417.43,
        3479.7,
        3477.26,
        3475.99,
        3474.16,
        3466.12,
        3323.5,
        12.4,
        8.32,
        71.3,
        7.97,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '138') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '60'\n  AND m.movie_id <= '335'\n  AND t.production_year = '1916'\n  AND c.nr_order = '138'\nGROUP BY m.movie_id;": [
        8274.44,
        7336.7,
        7334.26,
        7332.99,
        7331.16,
        7317.94,
        7103.46,
        25.75,
        8.17,
        107.23,
        13.16,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1168') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '33'\n  AND m.movie_id <= '344'\n  AND t.production_year = '1980'\n  AND c.nr_order = '1168'\nGROUP BY m.movie_id;": [
        9263.23,
        8325.5,
        8323.06,
        8321.79,
        8319.95,
        8311.98,
        7958.69,
        27.93,
        8.13,
        70.65,
        7.91,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '428') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '370'\n  AND m.movie_id <= '496'\n  AND t.production_year = '1955'\n  AND c.nr_order = '428'\nGROUP BY m.movie_id;": [
        4550.26,
        3612.52,
        3610.08,
        3608.81,
        3606.98,
        3595.73,
        3497.37,
        12.82,
        8.32,
        98.35,
        11.18,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2401') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '278'\n  AND m.movie_id <= '403'\n  AND t.production_year = '1892'\n  AND c.nr_order = '2401'\nGROUP BY m.movie_id;": [
        4498.38,
        3560.64,
        3558.2,
        3556.93,
        3555.1,
        3489.37,
        3471.96,
        12.76,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1022') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '391'\n  AND m.movie_id <= '512'\n  AND t.production_year = '1963'\n  AND c.nr_order = '1022'\nGROUP BY m.movie_id;": [
        4485.86,
        3548.13,
        3545.69,
        3544.42,
        3542.58,
        3533.76,
        3374.32,
        12.51,
        8.32,
        79.71,
        8.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1038') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '391'\n  AND m.movie_id <= '508'\n  AND t.production_year = '1967'\n  AND c.nr_order = '1038'\nGROUP BY m.movie_id;": [
        4415.12,
        3477.39,
        3474.95,
        3473.68,
        3471.84,
        3464.62,
        3276.68,
        12.28,
        8.33,
        62.64,
        7.16,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2401') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '276'\n  AND m.movie_id <= '403'\n  AND t.production_year = '1895'\n  AND c.nr_order = '2401'\nGROUP BY m.movie_id;": [
        4549.2,
        3611.46,
        3609.02,
        3607.75,
        3605.92,
        3540.19,
        3522.78,
        12.87,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '232') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '228'\n  AND m.movie_id <= '341'\n  AND t.production_year = '1965'\n  AND c.nr_order = '232'\nGROUP BY m.movie_id;": [
        4285.94,
        3348.21,
        3345.77,
        3344.5,
        3342.66,
        3334.05,
        3179.04,
        12.04,
        8.33,
        77.49,
        8.55,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1303') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '295'\n  AND m.movie_id <= '405'\n  AND t.production_year = '1911'\n  AND c.nr_order = '1303'\nGROUP BY m.movie_id;": [
        4168.9,
        3231.17,
        3228.73,
        3227.46,
        3225.62,
        3212.74,
        3106.81,
        11.86,
        8.34,
        105.92,
        12.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1234') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '295'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1911'\n  AND c.nr_order = '1234'\nGROUP BY m.movie_id;": [
        4067.26,
        3129.53,
        3127.09,
        3125.82,
        3123.98,
        3111.1,
        3005.17,
        11.62,
        8.34,
        105.92,
        12.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1025') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '382'\n  AND m.movie_id <= '502'\n  AND t.production_year = '1973'\n  AND c.nr_order = '1025'\nGROUP BY m.movie_id;": [
        4438.06,
        3500.33,
        3497.89,
        3496.62,
        3494.78,
        3486.96,
        3348.91,
        12.46,
        8.32,
        69.01,
        7.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1173') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '242'\n  AND m.movie_id <= '405'\n  AND t.production_year = '1922'\n  AND c.nr_order = '1173'\nGROUP BY m.movie_id;": [
        5431.96,
        4494.22,
        4491.78,
        4490.51,
        4488.68,
        4422.95,
        4405.54,
        15.04,
        8.28,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1022') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '384'\n  AND m.movie_id <= '505'\n  AND t.production_year = '1973'\n  AND c.nr_order = '1022'\nGROUP BY m.movie_id;": [
        4463.47,
        3525.74,
        3523.3,
        3522.03,
        3520.19,
        3512.37,
        3374.32,
        12.51,
        8.32,
        69.01,
        7.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '81') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '370'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1906'\n  AND c.nr_order = '81'\nGROUP BY m.movie_id;": [
        4990.58,
        4052.84,
        4050.4,
        4049.13,
        4047.3,
        3981.57,
        3964.16,
        13.96,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1305') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '295'\n  AND m.movie_id <= '397'\n  AND t.production_year = '1910'\n  AND c.nr_order = '1305'\nGROUP BY m.movie_id;": [
        3970.71,
        3032.97,
        3030.53,
        3029.26,
        3027.43,
        3014.33,
        2907.53,
        11.38,
        8.35,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1305') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '295'\n  AND m.movie_id <= '399'\n  AND t.production_year = '1910'\n  AND c.nr_order = '1305'\nGROUP BY m.movie_id;": [
        4021.53,
        3083.79,
        3081.35,
        3080.08,
        3078.25,
        3065.15,
        2958.35,
        11.5,
        8.35,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '77') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '372'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1910'\n  AND c.nr_order = '77'\nGROUP BY m.movie_id;": [
        4976.52,
        4038.78,
        4036.34,
        4035.07,
        4033.24,
        4020.14,
        3913.34,
        13.83,
        8.3,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '88') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '374'\n  AND m.movie_id <= '511'\n  AND t.production_year = '1911'\n  AND c.nr_order = '88'\nGROUP BY m.movie_id;": [
        4830.97,
        3893.24,
        3890.8,
        3889.53,
        3887.69,
        3874.81,
        3768.88,
        13.47,
        8.31,
        105.92,
        12.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '89') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '369'\n  AND m.movie_id <= '513'\n  AND t.production_year = '1905'\n  AND c.nr_order = '89'\nGROUP BY m.movie_id;": [
        4965.17,
        4027.43,
        4024.99,
        4023.72,
        4021.89,
        3956.16,
        3938.75,
        13.9,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '78') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '516'\n  AND t.production_year = '1909'\n  AND c.nr_order = '78'\nGROUP BY m.movie_id;": [
        5021.69,
        4083.95,
        4081.51,
        4080.24,
        4078.41,
        3979.82,
        3964.16,
        13.96,
        8.3,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2001110') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '208'\n  AND m.movie_id <= '375'\n  AND t.production_year = '1965'\n  AND c.nr_order = '2001110'\nGROUP BY m.movie_id;": [
        5683.59,
        4745.86,
        4743.42,
        4742.15,
        4740.31,
        4731.7,
        4499.18,
        15.28,
        8.27,
        77.49,
        8.55,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2303') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '280'\n  AND m.movie_id <= '404'\n  AND t.production_year = '1893'\n  AND c.nr_order = '2303'\nGROUP BY m.movie_id;": [
        4476.97,
        3539.23,
        3536.79,
        3535.52,
        3533.69,
        3467.96,
        3450.55,
        12.69,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2198') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '280'\n  AND m.movie_id <= '403'\n  AND t.production_year = '1898'\n  AND c.nr_order = '2198'\nGROUP BY m.movie_id;": [
        4451.56,
        3513.82,
        3511.38,
        3510.11,
        3508.28,
        3442.55,
        3425.14,
        12.63,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '800') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '273'\n  AND m.movie_id <= '409'\n  AND t.production_year = '1895'\n  AND c.nr_order = '800'\nGROUP BY m.movie_id;": [
        4769.89,
        3832.15,
        3829.71,
        3828.44,
        3826.61,
        3760.88,
        3743.47,
        13.42,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1007') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '396'\n  AND m.movie_id <= '507'\n  AND t.production_year = '1973'\n  AND c.nr_order = '1007'\nGROUP BY m.movie_id;": [
        4221.37,
        3283.64,
        3281.2,
        3279.93,
        3278.09,
        3270.27,
        3132.22,
        11.92,
        8.34,
        69.01,
        7.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2402') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '267'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1893'\n  AND c.nr_order = '2402'\nGROUP BY m.movie_id;": [
        4723.07,
        3785.33,
        3782.89,
        3781.62,
        3779.79,
        3714.06,
        3696.65,
        13.29,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '230') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '231'\n  AND m.movie_id <= '339'\n  AND t.production_year = '1962'\n  AND c.nr_order = '230'\nGROUP BY m.movie_id;": [
        4095.36,
        3157.62,
        3155.18,
        3153.91,
        3152.08,
        3142.62,
        3055.99,
        11.74,
        8.34,
        86.62,
        9.4,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1234') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '296'\n  AND m.movie_id <= '402'\n  AND t.production_year = '1910'\n  AND c.nr_order = '1234'\nGROUP BY m.movie_id;": [
        4068.35,
        3130.61,
        3128.17,
        3126.9,
        3125.07,
        3111.97,
        3005.17,
        11.62,
        8.34,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1305') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '294'\n  AND m.movie_id <= '400'\n  AND t.production_year = '1910'\n  AND c.nr_order = '1305'\nGROUP BY m.movie_id;": [
        4068.35,
        3130.61,
        3128.17,
        3126.9,
        3125.07,
        3111.97,
        3005.17,
        11.62,
        8.34,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '360') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '339'\n  AND m.movie_id <= '497'\n  AND t.production_year = '1899'\n  AND c.nr_order = '360'\nGROUP BY m.movie_id;": [
        5308.91,
        4371.17,
        4368.73,
        4367.46,
        4365.63,
        4299.9,
        4282.49,
        14.74,
        8.29,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1301') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '296'\n  AND m.movie_id <= '402'\n  AND t.production_year = '1910'\n  AND c.nr_order = '1301'\nGROUP BY m.movie_id;": [
        4068.35,
        3130.61,
        3128.17,
        3126.9,
        3125.07,
        3111.97,
        3005.17,
        11.62,
        8.34,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '94') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '373'\n  AND m.movie_id <= '513'\n  AND t.production_year = '1908'\n  AND c.nr_order = '94'\nGROUP BY m.movie_id;": [
        4871.53,
        3933.79,
        3931.35,
        3930.08,
        3928.25,
        3862.52,
        3845.11,
        13.65,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '91') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '373'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1908'\n  AND c.nr_order = '91'\nGROUP BY m.movie_id;": [
        4914.35,
        3976.61,
        3974.17,
        3972.9,
        3971.07,
        3905.34,
        3887.93,
        13.78,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '90') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '368'\n  AND m.movie_id <= '513'\n  AND t.production_year = '1905'\n  AND c.nr_order = '90'\nGROUP BY m.movie_id;": [
        4990.58,
        4052.84,
        4050.4,
        4049.13,
        4047.3,
        3981.57,
        3964.16,
        13.96,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '78') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '514'\n  AND t.production_year = '1908'\n  AND c.nr_order = '78'\nGROUP BY m.movie_id;": [
        4939.76,
        4002.02,
        3999.58,
        3998.31,
        3996.48,
        3930.75,
        3913.34,
        13.83,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '88') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1904'\n  AND c.nr_order = '88'\nGROUP BY m.movie_id;": [
        4965.17,
        4027.43,
        4024.99,
        4023.72,
        4021.89,
        3956.16,
        3938.75,
        13.9,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1009') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '389'\n  AND m.movie_id <= '510'\n  AND t.production_year = '1976'\n  AND c.nr_order = '1009'\nGROUP BY m.movie_id;": [
        4472.66,
        3534.93,
        3532.49,
        3531.22,
        3529.38,
        3521.15,
        3374.32,
        12.51,
        8.32,
        73.4,
        8.17,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '8001') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '100'\n  AND m.movie_id <= '231'\n  AND t.production_year = '1977'\n  AND c.nr_order = '8001'\nGROUP BY m.movie_id;": [
        4719.28,
        3781.55,
        3779.11,
        3777.84,
        3776.0,
        3767.74,
        3620.42,
        13.12,
        8.31,
        73.65,
        8.19,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '228') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '236'\n  AND m.movie_id <= '342'\n  AND t.production_year = '1959'\n  AND c.nr_order = '228'\nGROUP BY m.movie_id;": [
        4123.43,
        3185.7,
        3183.26,
        3181.99,
        3180.16,
        3171.04,
        3005.17,
        11.62,
        8.34,
        82.92,
        9.06,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1018') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '55'\n  AND m.movie_id <= '380'\n  AND t.production_year = '1992'\n  AND c.nr_order = '1018'\nGROUP BY m.movie_id;": [
        9793.54,
        8855.8,
        8853.36,
        8852.09,
        8850.26,
        8843.73,
        8290.43,
        28.78,
        8.12,
        55.32,
        6.46,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1165') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '308'\n  AND m.movie_id <= '492'\n  AND t.production_year = '1905'\n  AND c.nr_order = '1165'\nGROUP BY m.movie_id;": [
        5941.57,
        5003.83,
        5001.39,
        5000.12,
        4998.29,
        4932.56,
        4915.15,
        16.29,
        8.26,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1400') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '296'\n  AND m.movie_id <= '404'\n  AND t.production_year = '1911'\n  AND c.nr_order = '1400'\nGROUP BY m.movie_id;": [
        4118.08,
        3180.35,
        3177.91,
        3176.64,
        3174.8,
        3161.92,
        3055.99,
        11.74,
        8.34,
        105.92,
        12.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1200') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '294'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1911'\n  AND c.nr_order = '1200'\nGROUP BY m.movie_id;": [
        4092.67,
        3154.94,
        3152.5,
        3151.23,
        3149.39,
        3136.51,
        3030.58,
        11.68,
        8.34,
        105.92,
        12.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1104') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '90'\n  AND m.movie_id <= '311'\n  AND t.production_year = '1984'\n  AND c.nr_order = '1104'\nGROUP BY m.movie_id;": [
        7077.3,
        6139.57,
        6137.13,
        6135.86,
        6134.02,
        6126.68,
        5807.32,
        18.51,
        8.22,
        63.86,
        7.28,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '370') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '60'\n  AND m.movie_id <= '367'\n  AND t.production_year = '1901'\n  AND c.nr_order = '370'\nGROUP BY m.movie_id;": [
        8957.24,
        8019.51,
        8017.07,
        8015.8,
        8013.96,
        7997.66,
        7869.05,
        27.7,
        8.14,
        128.59,
        16.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1305') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '296'\n  AND m.movie_id <= '400'\n  AND t.production_year = '1911'\n  AND c.nr_order = '1305'\nGROUP BY m.movie_id;": [
        4020.44,
        3082.71,
        3080.27,
        3079.0,
        3077.16,
        3064.28,
        2958.35,
        11.5,
        8.35,
        105.92,
        12.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1303') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '295'\n  AND m.movie_id <= '402'\n  AND t.production_year = '1911'\n  AND c.nr_order = '1303'\nGROUP BY m.movie_id;": [
        4092.67,
        3154.94,
        3152.5,
        3151.23,
        3149.39,
        3136.51,
        3030.58,
        11.68,
        8.34,
        105.92,
        12.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1303') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '296'\n  AND m.movie_id <= '406'\n  AND t.production_year = '1911'\n  AND c.nr_order = '1303'\nGROUP BY m.movie_id;": [
        4168.9,
        3231.17,
        3228.73,
        3227.46,
        3225.62,
        3212.74,
        3106.81,
        11.86,
        8.34,
        105.92,
        12.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '90') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '514'\n  AND t.production_year = '1903'\n  AND c.nr_order = '90'\nGROUP BY m.movie_id;": [
        4939.76,
        4002.02,
        3999.58,
        3998.31,
        3996.48,
        3930.75,
        3913.34,
        13.83,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '793') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '270'\n  AND m.movie_id <= '411'\n  AND t.production_year = '1891'\n  AND c.nr_order = '793'\nGROUP BY m.movie_id;": [
        4892.94,
        3955.2,
        3952.76,
        3951.49,
        3949.66,
        3883.93,
        3866.52,
        13.72,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '225') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '228'\n  AND m.movie_id <= '339'\n  AND t.production_year = '1963'\n  AND c.nr_order = '225'\nGROUP BY m.movie_id;": [
        4243.76,
        3306.03,
        3303.59,
        3302.32,
        3300.48,
        3291.66,
        3132.22,
        11.92,
        8.34,
        79.71,
        8.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '980102') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '17'\n  AND m.movie_id <= '45'\n  AND t.production_year = '1996'\n  AND c.nr_order = '980102'\nGROUP BY m.movie_id;": [
        2097.46,
        1159.72,
        1157.28,
        1156.01,
        1154.18,
        1148.32,
        1050.72,
        6.92,
        8.42,
        48.79,
        5.8,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '228') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '228'\n  AND m.movie_id <= '338'\n  AND t.production_year = '1962'\n  AND c.nr_order = '228'\nGROUP BY m.movie_id;": [
        4146.18,
        3208.44,
        3206.0,
        3204.73,
        3202.9,
        3193.44,
        3106.81,
        11.86,
        8.34,
        86.62,
        9.4,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '230') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '228'\n  AND m.movie_id <= '343'\n  AND t.production_year = '1967'\n  AND c.nr_order = '230'\nGROUP BY m.movie_id;": [
        4364.3,
        3426.57,
        3424.13,
        3422.86,
        3421.02,
        3413.8,
        3225.86,
        12.15,
        8.33,
        62.64,
        7.16,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2402') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '267'\n  AND m.movie_id <= '400'\n  AND t.production_year = '1892'\n  AND c.nr_order = '2402'\nGROUP BY m.movie_id;": [
        4697.66,
        3759.92,
        3757.48,
        3756.21,
        3754.38,
        3688.65,
        3671.24,
        13.24,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '93') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '516'\n  AND t.production_year = '1908'\n  AND c.nr_order = '93'\nGROUP BY m.movie_id;": [
        4990.58,
        4052.84,
        4050.4,
        4049.13,
        4047.3,
        3981.57,
        3964.16,
        13.96,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1303') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '294'\n  AND m.movie_id <= '400'\n  AND t.production_year = '1909'\n  AND c.nr_order = '1303'\nGROUP BY m.movie_id;": [
        4029.83,
        3092.1,
        3089.66,
        3088.39,
        3086.55,
        3020.83,
        3005.17,
        11.62,
        8.34,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '225') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '431'\n  AND m.movie_id <= '485'\n  AND t.production_year = '1897'\n  AND c.nr_order = '225'\nGROUP BY m.movie_id;": [
        2700.93,
        1763.2,
        1760.76,
        1759.49,
        1726.63,
        1724.79,
        1707.38,
        8.47,
        8.41,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '93') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '79'\n  AND m.movie_id <= '106'\n  AND t.production_year = '1986'\n  AND c.nr_order = '93'\nGROUP BY m.movie_id;": [
        2035.36,
        1097.63,
        1095.19,
        1093.92,
        1092.08,
        1085.13,
        1025.31,
        6.85,
        8.42,
        59.81,
        6.89,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1301') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '292'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1909'\n  AND c.nr_order = '1301'\nGROUP BY m.movie_id;": [
        4106.06,
        3168.33,
        3165.89,
        3164.62,
        3162.78,
        3097.06,
        3081.4,
        11.79,
        8.34,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1303') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '295'\n  AND m.movie_id <= '408'\n  AND t.production_year = '1908'\n  AND c.nr_order = '1303'\nGROUP BY m.movie_id;": [
        4205.46,
        3267.72,
        3265.28,
        3264.01,
        3262.18,
        3196.45,
        3179.04,
        12.04,
        8.33,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '88') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '368'\n  AND m.movie_id <= '513'\n  AND t.production_year = '1902'\n  AND c.nr_order = '88'\nGROUP BY m.movie_id;": [
        4990.58,
        4052.84,
        4050.4,
        4049.13,
        4047.3,
        3981.57,
        3964.16,
        13.96,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '88') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '374'\n  AND m.movie_id <= '517'\n  AND t.production_year = '1903'\n  AND c.nr_order = '88'\nGROUP BY m.movie_id;": [
        4939.76,
        4002.02,
        3999.58,
        3998.31,
        3996.48,
        3930.75,
        3913.34,
        13.83,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1046') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '201'\n  AND m.movie_id <= '327'\n  AND t.production_year = '1944'\n  AND c.nr_order = '1046'\nGROUP BY m.movie_id;": [
        4523.79,
        3586.05,
        3583.61,
        3582.34,
        3580.51,
        3514.78,
        3497.37,
        12.82,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '89') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '513'\n  AND t.production_year = '1902'\n  AND c.nr_order = '89'\nGROUP BY m.movie_id;": [
        4914.35,
        3976.61,
        3974.17,
        3972.9,
        3971.07,
        3905.34,
        3887.93,
        13.78,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '75') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '374'\n  AND m.movie_id <= '510'\n  AND t.production_year = '1906'\n  AND c.nr_order = '75'\nGROUP BY m.movie_id;": [
        4769.89,
        3832.15,
        3829.71,
        3828.44,
        3826.61,
        3760.88,
        3743.47,
        13.42,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '81') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '377'\n  AND m.movie_id <= '518'\n  AND t.production_year = '1903'\n  AND c.nr_order = '81'\nGROUP BY m.movie_id;": [
        4892.94,
        3955.2,
        3952.76,
        3951.49,
        3949.66,
        3883.93,
        3866.52,
        13.72,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '81') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '370'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1908'\n  AND c.nr_order = '81'\nGROUP BY m.movie_id;": [
        4990.58,
        4052.84,
        4050.4,
        4049.13,
        4047.3,
        3981.57,
        3964.16,
        13.96,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1400') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '291'\n  AND m.movie_id <= '403'\n  AND t.production_year = '1908'\n  AND c.nr_order = '1400'\nGROUP BY m.movie_id;": [
        4184.05,
        3246.31,
        3243.87,
        3242.6,
        3240.77,
        3175.04,
        3157.63,
        11.97,
        8.34,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1306') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '290'\n  AND m.movie_id <= '408'\n  AND t.production_year = '1908'\n  AND c.nr_order = '1306'\nGROUP BY m.movie_id;": [
        4328.51,
        3390.77,
        3388.33,
        3387.06,
        3385.23,
        3319.5,
        3302.09,
        12.34,
        8.33,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1401') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '294'\n  AND m.movie_id <= '407'\n  AND t.production_year = '1908'\n  AND c.nr_order = '1401'\nGROUP BY m.movie_id;": [
        4205.46,
        3267.72,
        3265.28,
        3264.01,
        3262.18,
        3196.45,
        3179.04,
        12.04,
        8.33,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1301') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '296'\n  AND m.movie_id <= '406'\n  AND t.production_year = '1908'\n  AND c.nr_order = '1301'\nGROUP BY m.movie_id;": [
        4100.36,
        3162.63,
        3160.19,
        3158.92,
        3126.06,
        3124.22,
        3106.81,
        11.86,
        8.34,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1279') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '297'\n  AND m.movie_id <= '406'\n  AND t.production_year = '1908'\n  AND c.nr_order = '1279'\nGROUP BY m.movie_id;": [
        4074.95,
        3137.22,
        3134.78,
        3133.51,
        3100.65,
        3098.81,
        3081.4,
        11.79,
        8.34,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1008') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '391'\n  AND m.movie_id <= '509'\n  AND t.production_year = '1976'\n  AND c.nr_order = '1008'\nGROUP BY m.movie_id;": [
        4400.43,
        3462.7,
        3460.26,
        3458.99,
        3457.15,
        3448.92,
        3302.09,
        12.34,
        8.33,
        73.4,
        8.17,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1234') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '294'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1912'\n  AND c.nr_order = '1234'\nGROUP BY m.movie_id;": [
        4076.12,
        3138.39,
        3135.95,
        3134.68,
        3132.84,
        3122.74,
        3030.58,
        11.68,
        8.34,
        92.15,
        10.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1305') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '297'\n  AND m.movie_id <= '404'\n  AND t.production_year = '1912'\n  AND c.nr_order = '1305'\nGROUP BY m.movie_id;": [
        4076.12,
        3138.39,
        3135.95,
        3134.68,
        3132.84,
        3122.74,
        3030.58,
        11.68,
        8.34,
        92.15,
        10.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1200') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '290'\n  AND m.movie_id <= '400'\n  AND t.production_year = '1912'\n  AND c.nr_order = '1200'\nGROUP BY m.movie_id;": [
        4152.35,
        3214.62,
        3212.18,
        3210.91,
        3209.07,
        3198.97,
        3106.81,
        11.86,
        8.34,
        92.15,
        10.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '461') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '317'\n  AND m.movie_id <= '440'\n  AND t.production_year = '1971'\n  AND c.nr_order = '461'\nGROUP BY m.movie_id;": [
        4522.96,
        3585.23,
        3582.79,
        3581.52,
        3579.68,
        3571.47,
        3425.14,
        12.63,
        8.32,
        73.16,
        8.15,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '322') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '287'\n  AND m.movie_id <= '312'\n  AND t.production_year = '2000'\n  AND c.nr_order = '322'\nGROUP BY m.movie_id;": [
        2013.86,
        1076.13,
        1073.69,
        1072.42,
        1070.59,
        1065.26,
        978.49,
        6.74,
        8.45,
        43.37,
        5.27,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '469') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '317'\n  AND m.movie_id <= '441'\n  AND t.production_year = '1969'\n  AND c.nr_order = '469'\nGROUP BY m.movie_id;": [
        4600.9,
        3663.16,
        3660.72,
        3659.45,
        3657.62,
        3650.03,
        3450.55,
        12.69,
        8.32,
        66.48,
        7.52,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '970713') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '113'\n  AND m.movie_id <= '286'\n  AND t.production_year = '1906'\n  AND c.nr_order = '970713'\nGROUP BY m.movie_id;": [
        5674.06,
        4736.32,
        4733.88,
        4732.61,
        4730.78,
        4665.05,
        4647.64,
        15.64,
        8.27,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1009') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '391'\n  AND m.movie_id <= '506'\n  AND t.production_year = '1976'\n  AND c.nr_order = '1009'\nGROUP BY m.movie_id;": [
        4324.2,
        3386.47,
        3384.03,
        3382.76,
        3380.92,
        3372.69,
        3225.86,
        12.15,
        8.33,
        73.4,
        8.17,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1009') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '391'\n  AND m.movie_id <= '507'\n  AND t.production_year = '1976'\n  AND c.nr_order = '1009'\nGROUP BY m.movie_id;": [
        4349.61,
        3411.88,
        3409.44,
        3408.17,
        3406.33,
        3398.1,
        3251.27,
        12.21,
        8.33,
        73.4,
        8.17,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1025') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '390'\n  AND m.movie_id <= '508'\n  AND t.production_year = '1967'\n  AND c.nr_order = '1025'\nGROUP BY m.movie_id;": [
        4440.53,
        3502.8,
        3500.36,
        3499.09,
        3497.25,
        3490.03,
        3302.09,
        12.34,
        8.33,
        62.64,
        7.16,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1010') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '390'\n  AND m.movie_id <= '509'\n  AND t.production_year = '1968'\n  AND c.nr_order = '1010'\nGROUP BY m.movie_id;": [
        4419.82,
        3482.08,
        3479.64,
        3478.37,
        3476.54,
        3468.4,
        3323.5,
        12.4,
        8.32,
        72.44,
        8.08,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2108') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '272'\n  AND m.movie_id <= '405'\n  AND t.production_year = '1895'\n  AND c.nr_order = '2108'\nGROUP BY m.movie_id;": [
        4697.66,
        3759.92,
        3757.48,
        3756.21,
        3754.38,
        3688.65,
        3671.24,
        13.24,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1057') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '204'\n  AND m.movie_id <= '341'\n  AND t.production_year = '1967'\n  AND c.nr_order = '1057'\nGROUP BY m.movie_id;": [
        4907.32,
        3969.59,
        3967.15,
        3965.88,
        3964.04,
        3956.82,
        3768.88,
        13.47,
        8.31,
        62.64,
        7.16,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '409') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '109'\n  AND m.movie_id <= '216'\n  AND t.production_year = '1925'\n  AND c.nr_order = '409'\nGROUP BY m.movie_id;": [
        4024.13,
        3086.4,
        3083.96,
        3082.69,
        3049.83,
        3047.99,
        3030.58,
        11.68,
        8.34,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '6002') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '118'\n  AND m.movie_id <= '465'\n  AND t.production_year = '1907'\n  AND c.nr_order = '6002'\nGROUP BY m.movie_id;": [
        9893.64,
        8955.91,
        8953.47,
        8952.2,
        8950.36,
        8934.06,
        8805.45,
        30.09,
        8.1,
        128.59,
        16.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1800') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '293'\n  AND m.movie_id <= '405'\n  AND t.production_year = '1910'\n  AND c.nr_order = '1800'\nGROUP BY m.movie_id;": [
        4220.81,
        3283.07,
        3280.63,
        3279.36,
        3277.53,
        3264.43,
        3157.63,
        11.97,
        8.34,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1202') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '295'\n  AND m.movie_id <= '400'\n  AND t.production_year = '1913'\n  AND c.nr_order = '1202'\nGROUP BY m.movie_id;": [
        4034.9,
        3097.17,
        3094.73,
        3093.46,
        3091.62,
        3080.67,
        2983.76,
        11.56,
        8.35,
        96.9,
        10.89,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2037') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '279'\n  AND m.movie_id <= '424'\n  AND t.production_year = '1911'\n  AND c.nr_order = '2037'\nGROUP BY m.movie_id;": [
        5026.25,
        4088.52,
        4086.08,
        4084.81,
        4082.97,
        4070.09,
        3964.16,
        13.96,
        8.3,
        105.92,
        12.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '469') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '315'\n  AND m.movie_id <= '438'\n  AND t.production_year = '1970'\n  AND c.nr_order = '469'\nGROUP BY m.movie_id;": [
        4515.12,
        3577.38,
        3574.94,
        3573.67,
        3571.84,
        3563.98,
        3425.14,
        12.63,
        8.32,
        69.41,
        7.8,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '469') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '318'\n  AND m.movie_id <= '441'\n  AND t.production_year = '1971'\n  AND c.nr_order = '469'\nGROUP BY m.movie_id;": [
        4522.96,
        3585.23,
        3582.79,
        3581.52,
        3579.68,
        3571.47,
        3425.14,
        12.63,
        8.32,
        73.16,
        8.15,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '89') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '366'\n  AND m.movie_id <= '513'\n  AND t.production_year = '1905'\n  AND c.nr_order = '89'\nGROUP BY m.movie_id;": [
        5037.4,
        4099.66,
        4097.22,
        4095.95,
        4094.12,
        4028.39,
        4010.98,
        14.08,
        8.29,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '78') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '372'\n  AND m.movie_id <= '518'\n  AND t.production_year = '1901'\n  AND c.nr_order = '78'\nGROUP BY m.movie_id;": [
        5015.99,
        4078.25,
        4075.81,
        4074.54,
        4072.71,
        4006.98,
        3989.57,
        14.01,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '91') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '516'\n  AND t.production_year = '1907'\n  AND c.nr_order = '91'\nGROUP BY m.movie_id;": [
        4990.58,
        4052.84,
        4050.4,
        4049.13,
        4047.3,
        3981.57,
        3964.16,
        13.96,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '84') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '374'\n  AND m.movie_id <= '518'\n  AND t.production_year = '1908'\n  AND c.nr_order = '84'\nGROUP BY m.movie_id;": [
        4965.17,
        4027.43,
        4024.99,
        4023.72,
        4021.89,
        3956.16,
        3938.75,
        13.9,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '179'\n  AND m.movie_id <= '259'\n  AND t.production_year = '2016'\n  AND c.nr_order = '2'\nGROUP BY m.movie_id;": [
        3345.59,
        2407.86,
        2405.42,
        2404.15,
        2371.29,
        2369.45,
        2352.04,
        10.04,
        8.36,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '94') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '375'\n  AND m.movie_id <= '514'\n  AND t.production_year = '1908'\n  AND c.nr_order = '94'\nGROUP BY m.movie_id;": [
        4846.12,
        3908.38,
        3905.94,
        3904.67,
        3902.84,
        3837.11,
        3819.7,
        13.6,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '94') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '374'\n  AND m.movie_id <= '511'\n  AND t.production_year = '1907'\n  AND c.nr_order = '94'\nGROUP BY m.movie_id;": [
        4795.3,
        3857.56,
        3855.12,
        3853.85,
        3852.02,
        3786.29,
        3768.88,
        13.47,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '25100') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '1'\n  AND m.movie_id <= '77'\n  AND t.production_year = '1968'\n  AND c.nr_order = '25100'\nGROUP BY m.movie_id;": [
        3278.27,
        2340.53,
        2338.09,
        2336.82,
        2334.99,
        2326.85,
        2254.4,
        9.79,
        8.38,
        72.44,
        8.08,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '172') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '360'\n  AND m.movie_id <= '454'\n  AND t.production_year = '1920'\n  AND c.nr_order = '172'\nGROUP BY m.movie_id;": [
        3755.73,
        2818.0,
        2815.56,
        2814.29,
        2812.46,
        2713.86,
        2699.78,
        10.88,
        8.35,
        14.02,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '98') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '375'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1910'\n  AND c.nr_order = '98'\nGROUP BY m.movie_id;": [
        4908.29,
        3970.55,
        3968.11,
        3966.84,
        3965.01,
        3951.91,
        3845.11,
        13.65,
        8.31,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '360') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '163'\n  AND m.movie_id <= '224'\n  AND t.production_year = '1929'\n  AND c.nr_order = '360'\nGROUP BY m.movie_id;": [
        2874.8,
        1937.07,
        1934.63,
        1933.36,
        1900.5,
        1898.66,
        1881.25,
        8.9,
        8.4,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '81') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '369'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1907'\n  AND c.nr_order = '81'\nGROUP BY m.movie_id;": [
        5015.99,
        4078.25,
        4075.81,
        4074.54,
        4072.71,
        4006.98,
        3989.57,
        14.01,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1153') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '64'\n  AND m.movie_id <= '441'\n  AND t.production_year = '1950'\n  AND c.nr_order = '1153'\nGROUP BY m.movie_id;": [
        10784.52,
        9846.79,
        9844.35,
        9843.08,
        9841.24,
        9828.14,
        9507.75,
        31.89,
        8.08,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '322') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '171'\n  AND m.movie_id <= '278'\n  AND t.production_year = '1999'\n  AND c.nr_order = '322'\nGROUP BY m.movie_id;": [
        4290.05,
        3352.31,
        3349.87,
        3348.6,
        3346.77,
        3341.35,
        3030.58,
        11.68,
        8.34,
        44.38,
        5.36,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '950508') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '107'\n  AND m.movie_id <= '509'\n  AND t.production_year = '1969'\n  AND c.nr_order = '950508'\nGROUP BY m.movie_id;": [
        11565.82,
        10628.09,
        10625.65,
        10624.38,
        10622.54,
        10614.96,
        10083.0,
        33.4,
        8.05,
        66.48,
        7.52,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '90') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '368'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1907'\n  AND c.nr_order = '90'\nGROUP BY m.movie_id;": [
        5037.4,
        4099.66,
        4097.22,
        4095.95,
        4094.12,
        4028.39,
        4010.98,
        14.08,
        8.29,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '89') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1908'\n  AND c.nr_order = '89'\nGROUP BY m.movie_id;": [
        4965.17,
        4027.43,
        4024.99,
        4023.72,
        4021.89,
        3956.16,
        3938.75,
        13.9,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '88') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '370'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1907'\n  AND c.nr_order = '88'\nGROUP BY m.movie_id;": [
        4990.58,
        4052.84,
        4050.4,
        4049.13,
        4047.3,
        3981.57,
        3964.16,
        13.96,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '93') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '512'\n  AND t.production_year = '1909'\n  AND c.nr_order = '93'\nGROUP BY m.movie_id;": [
        4924.05,
        3986.31,
        3983.87,
        3982.6,
        3980.77,
        3882.18,
        3866.52,
        13.72,
        8.3,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '84') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '368'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1908'\n  AND c.nr_order = '84'\nGROUP BY m.movie_id;": [
        5037.4,
        4099.66,
        4097.22,
        4095.95,
        4094.12,
        4028.39,
        4010.98,
        14.08,
        8.29,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '823') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '286'\n  AND m.movie_id <= '296'\n  AND t.production_year = '1961'\n  AND c.nr_order = '823'\nGROUP BY m.movie_id;": [
        1615.39,
        677.66,
        675.22,
        673.95,
        672.11,
        606.38,
        597.34,
        5.83,
        8.45,
        8.99,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '89') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '376'\n  AND m.movie_id <= '517'\n  AND t.production_year = '1905'\n  AND c.nr_order = '89'\nGROUP BY m.movie_id;": [
        4892.94,
        3955.2,
        3952.76,
        3951.49,
        3949.66,
        3883.93,
        3866.52,
        13.72,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '26001') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '156'\n  AND m.movie_id <= '199'\n  AND t.production_year = '1969'\n  AND c.nr_order = '26001'\nGROUP BY m.movie_id;": [
        2445.23,
        1507.49,
        1505.05,
        1503.78,
        1501.95,
        1494.36,
        1427.87,
        7.81,
        8.4,
        66.48,
        7.52,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2198') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '14'\n  AND m.movie_id <= '47'\n  AND t.production_year = '1908'\n  AND c.nr_order = '2198'\nGROUP BY m.movie_id;": [
        2171.33,
        1233.59,
        1231.15,
        1229.88,
        1197.02,
        1195.18,
        1177.77,
        7.22,
        8.42,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '77') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '372'\n  AND m.movie_id <= '510'\n  AND t.production_year = '1908'\n  AND c.nr_order = '77'\nGROUP BY m.movie_id;": [
        4820.71,
        3882.97,
        3880.53,
        3879.26,
        3877.43,
        3811.7,
        3794.29,
        13.54,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '89') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1902'\n  AND c.nr_order = '89'\nGROUP BY m.movie_id;": [
        4965.17,
        4027.43,
        4024.99,
        4023.72,
        4021.89,
        3956.16,
        3938.75,
        13.9,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '88') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '377'\n  AND m.movie_id <= '517'\n  AND t.production_year = '1905'\n  AND c.nr_order = '88'\nGROUP BY m.movie_id;": [
        4871.53,
        3933.79,
        3931.35,
        3930.08,
        3928.25,
        3862.52,
        3845.11,
        13.65,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '803') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '272'\n  AND m.movie_id <= '409'\n  AND t.production_year = '1895'\n  AND c.nr_order = '803'\nGROUP BY m.movie_id;": [
        4795.3,
        3857.56,
        3855.12,
        3853.85,
        3852.02,
        3786.29,
        3768.88,
        13.47,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '800') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '271'\n  AND m.movie_id <= '410'\n  AND t.production_year = '1894'\n  AND c.nr_order = '800'\nGROUP BY m.movie_id;": [
        4846.12,
        3908.38,
        3905.94,
        3904.67,
        3902.84,
        3837.11,
        3819.7,
        13.6,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '800') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '275'\n  AND m.movie_id <= '408'\n  AND t.production_year = '1894'\n  AND c.nr_order = '800'\nGROUP BY m.movie_id;": [
        4697.66,
        3759.92,
        3757.48,
        3756.21,
        3754.38,
        3688.65,
        3671.24,
        13.24,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '793') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '271'\n  AND m.movie_id <= '411'\n  AND t.production_year = '1890'\n  AND c.nr_order = '793'\nGROUP BY m.movie_id;": [
        4871.53,
        3933.79,
        3931.35,
        3930.08,
        3928.25,
        3862.52,
        3845.11,
        13.65,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '134') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '409'\n  AND m.movie_id <= '501'\n  AND t.production_year = '1976'\n  AND c.nr_order = '134'\nGROUP BY m.movie_id;": [
        3747.3,
        2809.57,
        2807.13,
        2805.86,
        2804.02,
        2795.79,
        2648.96,
        10.76,
        8.35,
        73.4,
        8.17,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2302') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '266'\n  AND m.movie_id <= '403'\n  AND t.production_year = '1891'\n  AND c.nr_order = '2302'\nGROUP BY m.movie_id;": [
        4795.3,
        3857.56,
        3855.12,
        3853.85,
        3852.02,
        3786.29,
        3768.88,
        13.47,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1025') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '124'\n  AND m.movie_id <= '430'\n  AND t.production_year = '1964'\n  AND c.nr_order = '1025'\nGROUP BY m.movie_id;": [
        9174.22,
        8236.49,
        8234.05,
        8232.78,
        8230.94,
        8222.49,
        7843.64,
        27.64,
        8.14,
        75.76,
        8.39,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '74') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '376'\n  AND m.movie_id <= '509'\n  AND t.production_year = '1908'\n  AND c.nr_order = '74'\nGROUP BY m.movie_id;": [
        4697.66,
        3759.92,
        3757.48,
        3756.21,
        3754.38,
        3688.65,
        3671.24,
        13.24,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1203') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '293'\n  AND m.movie_id <= '400'\n  AND t.production_year = '1914'\n  AND c.nr_order = '1203'\nGROUP BY m.movie_id;": [
        4082.16,
        3144.42,
        3141.98,
        3140.71,
        3138.88,
        3127.85,
        3030.58,
        11.68,
        8.34,
        97.26,
        10.96,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2303') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '280'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1898'\n  AND c.nr_order = '2303'\nGROUP BY m.movie_id;": [
        4400.74,
        3463.0,
        3460.56,
        3459.29,
        3457.46,
        3391.73,
        3374.32,
        12.51,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '89') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '377'\n  AND m.movie_id <= '518'\n  AND t.production_year = '1908'\n  AND c.nr_order = '89'\nGROUP BY m.movie_id;": [
        4892.94,
        3955.2,
        3952.76,
        3951.49,
        3949.66,
        3883.93,
        3866.52,
        13.72,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '89') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '375'\n  AND m.movie_id <= '518'\n  AND t.production_year = '1907'\n  AND c.nr_order = '89'\nGROUP BY m.movie_id;": [
        4939.76,
        4002.02,
        3999.58,
        3998.31,
        3996.48,
        3930.75,
        3913.34,
        13.83,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '90') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '368'\n  AND m.movie_id <= '511'\n  AND t.production_year = '1902'\n  AND c.nr_order = '90'\nGROUP BY m.movie_id;": [
        4939.76,
        4002.02,
        3999.58,
        3998.31,
        3996.48,
        3930.75,
        3913.34,
        13.83,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '91') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '374'\n  AND m.movie_id <= '518'\n  AND t.production_year = '1907'\n  AND c.nr_order = '91'\nGROUP BY m.movie_id;": [
        4965.17,
        4027.43,
        4024.99,
        4023.72,
        4021.89,
        3956.16,
        3938.75,
        13.9,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1303') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '295'\n  AND m.movie_id <= '404'\n  AND t.production_year = '1910'\n  AND c.nr_order = '1303'\nGROUP BY m.movie_id;": [
        4144.58,
        3206.84,
        3204.4,
        3203.13,
        3201.3,
        3188.2,
        3081.4,
        11.79,
        8.34,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '962') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '80'\n  AND m.movie_id <= '147'\n  AND t.production_year = '1963'\n  AND c.nr_order = '962'\nGROUP BY m.movie_id;": [
        3061.53,
        2123.8,
        2121.36,
        2120.09,
        2118.25,
        2109.43,
        2029.71,
        9.26,
        8.38,
        79.71,
        8.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '91') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '368'\n  AND m.movie_id <= '513'\n  AND t.production_year = '1905'\n  AND c.nr_order = '91'\nGROUP BY m.movie_id;": [
        4990.58,
        4052.84,
        4050.4,
        4049.13,
        4047.3,
        3981.57,
        3964.16,
        13.96,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '527') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '161'\n  AND m.movie_id <= '276'\n  AND t.production_year = '1925'\n  AND c.nr_order = '527'\nGROUP BY m.movie_id;": [
        4252.28,
        3314.54,
        3312.1,
        3310.83,
        3309.0,
        3243.27,
        3225.86,
        12.15,
        8.33,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '199') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '396'\n  AND m.movie_id <= '473'\n  AND t.production_year = '1963'\n  AND c.nr_order = '199'\nGROUP BY m.movie_id;": [
        3307.63,
        2369.9,
        2367.46,
        2366.19,
        2364.35,
        2355.53,
        2275.81,
        9.86,
        8.36,
        79.71,
        8.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '249') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '161'\n  AND m.movie_id <= '294'\n  AND t.production_year = '1913'\n  AND c.nr_order = '249'\nGROUP BY m.movie_id;": [
        4722.38,
        3784.65,
        3782.21,
        3780.94,
        3779.1,
        3768.15,
        3671.24,
        13.24,
        8.31,
        96.9,
        10.89,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '75') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '375'\n  AND m.movie_id <= '507'\n  AND t.production_year = '1907'\n  AND c.nr_order = '75'\nGROUP BY m.movie_id;": [
        4672.25,
        3734.51,
        3732.07,
        3730.8,
        3728.97,
        3663.24,
        3645.83,
        13.18,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '77') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '372'\n  AND m.movie_id <= '511'\n  AND t.production_year = '1907'\n  AND c.nr_order = '77'\nGROUP BY m.movie_id;": [
        4846.12,
        3908.38,
        3905.94,
        3904.67,
        3902.84,
        3837.11,
        3819.7,
        13.6,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '417') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '110'\n  AND m.movie_id <= '217'\n  AND t.production_year = '1926'\n  AND c.nr_order = '417'\nGROUP BY m.movie_id;": [
        4024.13,
        3086.4,
        3083.96,
        3082.69,
        3049.83,
        3047.99,
        3030.58,
        11.68,
        8.34,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '396') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '110'\n  AND m.movie_id <= '216'\n  AND t.production_year = '1924'\n  AND c.nr_order = '396'\nGROUP BY m.movie_id;": [
        4029.95,
        3092.21,
        3089.77,
        3088.5,
        3086.67,
        3020.94,
        3005.17,
        11.62,
        8.34,
        15.71,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '526') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '159'\n  AND m.movie_id <= '277'\n  AND t.production_year = '1927'\n  AND c.nr_order = '526'\nGROUP BY m.movie_id;": [
        4328.51,
        3390.77,
        3388.33,
        3387.06,
        3385.23,
        3319.5,
        3302.09,
        12.34,
        8.33,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '58') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '210'\n  AND m.movie_id <= '292'\n  AND t.production_year = '1891'\n  AND c.nr_order = '58'\nGROUP BY m.movie_id;": [
        3396.41,
        2458.68,
        2456.24,
        2454.97,
        2422.11,
        2420.27,
        2402.86,
        10.15,
        8.37,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1010') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '391'\n  AND m.movie_id <= '505'\n  AND t.production_year = '1976'\n  AND c.nr_order = '1010'\nGROUP BY m.movie_id;": [
        4298.79,
        3361.06,
        3358.62,
        3357.35,
        3355.51,
        3347.28,
        3200.45,
        12.1,
        8.32,
        73.4,
        8.17,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1010') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '392'\n  AND m.movie_id <= '508'\n  AND t.production_year = '1976'\n  AND c.nr_order = '1010'\nGROUP BY m.movie_id;": [
        4349.61,
        3411.88,
        3409.44,
        3408.17,
        3406.33,
        3398.1,
        3251.27,
        12.21,
        8.33,
        73.4,
        8.17,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1008') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '393'\n  AND m.movie_id <= '508'\n  AND t.production_year = '1976'\n  AND c.nr_order = '1008'\nGROUP BY m.movie_id;": [
        4324.2,
        3386.47,
        3384.03,
        3382.76,
        3380.92,
        3372.69,
        3225.86,
        12.15,
        8.33,
        73.4,
        8.17,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1279') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '296'\n  AND m.movie_id <= '399'\n  AND t.production_year = '1911'\n  AND c.nr_order = '1279'\nGROUP BY m.movie_id;": [
        3995.03,
        3057.3,
        3054.86,
        3053.59,
        3051.75,
        3038.87,
        2932.94,
        11.44,
        8.35,
        105.92,
        12.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '90') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '367'\n  AND m.movie_id <= '512'\n  AND t.production_year = '1902'\n  AND c.nr_order = '90'\nGROUP BY m.movie_id;": [
        4990.58,
        4052.84,
        4050.4,
        4049.13,
        4047.3,
        3981.57,
        3964.16,
        13.96,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1199') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '402'\n  AND m.movie_id <= '409'\n  AND t.production_year = '1927'\n  AND c.nr_order = '1199'\nGROUP BY m.movie_id;": [
        1514.67,
        576.93,
        574.49,
        573.22,
        540.36,
        538.52,
        521.11,
        5.66,
        8.45,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '90') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '368'\n  AND m.movie_id <= '512'\n  AND t.production_year = '1904'\n  AND c.nr_order = '90'\nGROUP BY m.movie_id;": [
        4965.17,
        4027.43,
        4024.99,
        4023.72,
        4021.89,
        3956.16,
        3938.75,
        13.9,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1800') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '71'\n  AND m.movie_id <= '369'\n  AND t.production_year = '1894'\n  AND c.nr_order = '1800'\nGROUP BY m.movie_id;": [
        8740.55,
        7802.82,
        7800.38,
        7799.11,
        7797.27,
        7780.97,
        7652.36,
        27.15,
        8.15,
        128.59,
        16.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '88') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '514'\n  AND t.production_year = '1910'\n  AND c.nr_order = '88'\nGROUP BY m.movie_id;": [
        4976.52,
        4038.78,
        4036.34,
        4035.07,
        4033.24,
        4020.14,
        3913.34,
        13.83,
        8.3,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1305') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '295'\n  AND m.movie_id <= '407'\n  AND t.production_year = '1908'\n  AND c.nr_order = '1305'\nGROUP BY m.movie_id;": [
        4184.05,
        3246.31,
        3243.87,
        3242.6,
        3240.77,
        3175.04,
        3157.63,
        11.97,
        8.34,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '715') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '272'\n  AND m.movie_id <= '406'\n  AND t.production_year = '1894'\n  AND c.nr_order = '715'\nGROUP BY m.movie_id;": [
        4723.07,
        3785.33,
        3782.89,
        3781.62,
        3779.79,
        3714.06,
        3696.65,
        13.29,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '89') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '513'\n  AND t.production_year = '1901'\n  AND c.nr_order = '89'\nGROUP BY m.movie_id;": [
        4914.35,
        3976.61,
        3974.17,
        3972.9,
        3971.07,
        3905.34,
        3887.93,
        13.78,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '78') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '372'\n  AND m.movie_id <= '514'\n  AND t.production_year = '1909'\n  AND c.nr_order = '78'\nGROUP BY m.movie_id;": [
        4945.46,
        4007.72,
        4005.28,
        4004.01,
        4002.18,
        3903.59,
        3887.93,
        13.78,
        8.3,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1606') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '297'\n  AND m.movie_id <= '405'\n  AND t.production_year = '1908'\n  AND c.nr_order = '1606'\nGROUP BY m.movie_id;": [
        4049.54,
        3111.81,
        3109.37,
        3108.1,
        3075.24,
        3073.4,
        3055.99,
        11.74,
        8.34,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1306') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '297'\n  AND m.movie_id <= '403'\n  AND t.production_year = '1912'\n  AND c.nr_order = '1306'\nGROUP BY m.movie_id;": [
        4050.71,
        3112.98,
        3110.54,
        3109.27,
        3107.43,
        3097.33,
        3005.17,
        11.62,
        8.34,
        92.15,
        10.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '226') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '233'\n  AND m.movie_id <= '337'\n  AND t.production_year = '1961'\n  AND c.nr_order = '226'\nGROUP BY m.movie_id;": [
        4075.04,
        3137.3,
        3134.86,
        3133.59,
        3131.76,
        3122.71,
        2958.35,
        11.5,
        8.35,
        82.17,
        8.99,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '225') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '235'\n  AND m.movie_id <= '342'\n  AND t.production_year = '1960'\n  AND c.nr_order = '225'\nGROUP BY m.movie_id;": [
        4143.53,
        3205.8,
        3203.36,
        3202.09,
        3200.25,
        3191.37,
        3030.58,
        11.68,
        8.34,
        80.38,
        8.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '98') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '375'\n  AND m.movie_id <= '514'\n  AND t.production_year = '1911'\n  AND c.nr_order = '98'\nGROUP BY m.movie_id;": [
        4881.79,
        3944.06,
        3941.62,
        3940.35,
        3938.51,
        3925.63,
        3819.7,
        13.6,
        8.31,
        105.92,
        12.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2302') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '263'\n  AND m.movie_id <= '402'\n  AND t.production_year = '1894'\n  AND c.nr_order = '2302'\nGROUP BY m.movie_id;": [
        4846.12,
        3908.38,
        3905.94,
        3904.67,
        3902.84,
        3837.11,
        3819.7,
        13.6,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2401') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '276'\n  AND m.movie_id <= '402'\n  AND t.production_year = '1900'\n  AND c.nr_order = '2401'\nGROUP BY m.movie_id;": [
        4523.79,
        3586.05,
        3583.61,
        3582.34,
        3580.51,
        3514.78,
        3497.37,
        12.82,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1279') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '297'\n  AND m.movie_id <= '402'\n  AND t.production_year = '1909'\n  AND c.nr_order = '1279'\nGROUP BY m.movie_id;": [
        4008.42,
        3070.69,
        3068.25,
        3066.98,
        3065.14,
        2999.42,
        2983.76,
        11.56,
        8.35,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '194') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '84'\n  AND m.movie_id <= '364'\n  AND t.production_year = '2005'\n  AND c.nr_order = '194'\nGROUP BY m.movie_id;": [
        9483.77,
        8546.04,
        8543.6,
        8542.33,
        8540.49,
        8535.61,
        7222.51,
        26.06,
        8.17,
        38.61,
        4.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '91') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1905'\n  AND c.nr_order = '91'\nGROUP BY m.movie_id;": [
        4965.17,
        4027.43,
        4024.99,
        4023.72,
        4021.89,
        3956.16,
        3938.75,
        13.9,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '93') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1906'\n  AND c.nr_order = '93'\nGROUP BY m.movie_id;": [
        4965.17,
        4027.43,
        4024.99,
        4023.72,
        4021.89,
        3956.16,
        3938.75,
        13.9,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '89') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '377'\n  AND m.movie_id <= '516'\n  AND t.production_year = '1902'\n  AND c.nr_order = '89'\nGROUP BY m.movie_id;": [
        4846.12,
        3908.38,
        3905.94,
        3904.67,
        3902.84,
        3837.11,
        3819.7,
        13.6,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1303') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '296'\n  AND m.movie_id <= '400'\n  AND t.production_year = '1911'\n  AND c.nr_order = '1303'\nGROUP BY m.movie_id;": [
        4020.44,
        3082.71,
        3080.27,
        3079.0,
        3077.16,
        3064.28,
        2958.35,
        11.5,
        8.35,
        105.92,
        12.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1305') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '296'\n  AND m.movie_id <= '400'\n  AND t.production_year = '1910'\n  AND c.nr_order = '1305'\nGROUP BY m.movie_id;": [
        4021.53,
        3083.79,
        3081.35,
        3080.08,
        3078.25,
        3065.15,
        2958.35,
        11.5,
        8.35,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '469') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '238'\n  AND m.movie_id <= '353'\n  AND t.production_year = '1954'\n  AND c.nr_order = '469'\nGROUP BY m.movie_id;": [
        4276.16,
        3338.42,
        3335.99,
        3334.72,
        3332.88,
        3322.06,
        3225.86,
        12.15,
        8.33,
        96.19,
        10.75,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '453') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '236'\n  AND m.movie_id <= '353'\n  AND t.production_year = '1950'\n  AND c.nr_order = '453'\nGROUP BY m.movie_id;": [
        4339.86,
        3402.12,
        3399.68,
        3398.41,
        3396.58,
        3383.48,
        3276.68,
        12.28,
        8.33,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2125') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '209'\n  AND m.movie_id <= '284'\n  AND t.production_year = '1915'\n  AND c.nr_order = '2125'\nGROUP BY m.movie_id;": [
        3285.88,
        2348.14,
        2345.7,
        2344.43,
        2342.6,
        2331.35,
        2232.99,
        9.74,
        8.39,
        98.35,
        11.18,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2125') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '210'\n  AND m.movie_id <= '283'\n  AND t.production_year = '1911'\n  AND c.nr_order = '2125'\nGROUP BY m.movie_id;": [
        3236.92,
        2299.18,
        2296.75,
        2295.48,
        2293.64,
        2195.05,
        2182.17,
        9.62,
        8.39,
        12.82,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '809') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '158'\n  AND m.movie_id <= '454'\n  AND t.production_year = '1916'\n  AND c.nr_order = '809'\nGROUP BY m.movie_id;": [
        8780.52,
        7842.78,
        7840.34,
        7839.07,
        7837.24,
        7824.02,
        7609.54,
        27.04,
        8.15,
        107.23,
        13.16,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '338') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '118'\n  AND m.movie_id <= '279'\n  AND t.production_year = '1949'\n  AND c.nr_order = '338'\nGROUP BY m.movie_id;": [
        5425.66,
        4487.93,
        4485.49,
        4484.22,
        4482.38,
        4468.03,
        4354.72,
        14.92,
        8.28,
        113.3,
        14.29,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '813') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '158'\n  AND m.movie_id <= '451'\n  AND t.production_year = '1915'\n  AND c.nr_order = '813'\nGROUP BY m.movie_id;": [
        8786.93,
        7849.19,
        7846.76,
        7845.49,
        7843.65,
        7832.4,
        7537.31,
        26.86,
        8.15,
        98.35,
        11.18,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1004') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '396'\n  AND m.movie_id <= '507'\n  AND t.production_year = '1973'\n  AND c.nr_order = '1004'\nGROUP BY m.movie_id;": [
        4221.37,
        3283.64,
        3281.2,
        3279.93,
        3278.09,
        3270.27,
        3132.22,
        11.92,
        8.34,
        69.01,
        7.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '27001') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '189'\n  AND m.movie_id <= '432'\n  AND t.production_year = '1900'\n  AND c.nr_order = '27001'\nGROUP BY m.movie_id;": [
        7393.62,
        6455.89,
        6453.45,
        6452.18,
        6450.34,
        6351.75,
        6334.34,
        19.83,
        8.2,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '74') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '376'\n  AND m.movie_id <= '508'\n  AND t.production_year = '1906'\n  AND c.nr_order = '74'\nGROUP BY m.movie_id;": [
        4672.25,
        3734.51,
        3732.07,
        3730.8,
        3728.97,
        3663.24,
        3645.83,
        13.18,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1036') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '382'\n  AND m.movie_id <= '503'\n  AND t.production_year = '1974'\n  AND c.nr_order = '1036'\nGROUP BY m.movie_id;": [
        4468.25,
        3530.52,
        3528.08,
        3526.81,
        3524.98,
        3516.94,
        3374.32,
        12.51,
        8.32,
        71.3,
        7.97,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1038') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '379'\n  AND m.movie_id <= '503'\n  AND t.production_year = '1972'\n  AND c.nr_order = '1038'\nGROUP BY m.movie_id;": [
        4547.87,
        3610.13,
        3607.69,
        3606.42,
        3604.59,
        3596.4,
        3450.55,
        12.69,
        8.32,
        72.91,
        8.13,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '20010208') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '90'\n  AND m.movie_id <= '94'\n  AND t.production_year = '2010'\n  AND c.nr_order = '20010208'\nGROUP BY m.movie_id;": [
        1503.14,
        565.4,
        562.96,
        561.69,
        559.86,
        555.15,
        444.88,
        5.47,
        8.45,
        36.75,
        4.64,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1047') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '199'\n  AND m.movie_id <= '324'\n  AND t.production_year = '1943'\n  AND c.nr_order = '1047'\nGROUP BY m.movie_id;": [
        4498.38,
        3560.64,
        3558.2,
        3556.93,
        3555.1,
        3489.37,
        3471.96,
        12.76,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1200') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '292'\n  AND m.movie_id <= '400'\n  AND t.production_year = '1914'\n  AND c.nr_order = '1200'\nGROUP BY m.movie_id;": [
        4107.57,
        3169.83,
        3167.39,
        3166.12,
        3164.29,
        3153.26,
        3055.99,
        11.74,
        8.34,
        97.26,
        10.96,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '98') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '374'\n  AND m.movie_id <= '512'\n  AND t.production_year = '1910'\n  AND c.nr_order = '98'\nGROUP BY m.movie_id;": [
        4857.47,
        3919.73,
        3917.29,
        3916.02,
        3914.19,
        3901.09,
        3794.29,
        13.54,
        8.31,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '119') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '177'\n  AND m.movie_id <= '335'\n  AND t.production_year = '1926'\n  AND c.nr_order = '119'\nGROUP BY m.movie_id;": [
        5308.91,
        4371.17,
        4368.73,
        4367.46,
        4365.63,
        4299.9,
        4282.49,
        14.74,
        8.29,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1199') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '26'\n  AND m.movie_id <= '460'\n  AND t.production_year = '1919'\n  AND c.nr_order = '1199'\nGROUP BY m.movie_id;": [
        12006.22,
        11068.49,
        11066.05,
        11064.78,
        11062.95,
        11048.77,
        10824.12,
        35.31,
        8.03,
        112.31,
        14.11,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '3007') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '119'\n  AND m.movie_id <= '453'\n  AND t.production_year = '1978'\n  AND c.nr_order = '3007'\nGROUP BY m.movie_id;": [
        9869.57,
        8931.84,
        8929.4,
        8928.13,
        8926.29,
        8918.45,
        8503.12,
        29.31,
        8.12,
        69.21,
        7.78,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1800') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '291'\n  AND m.movie_id <= '406'\n  AND t.production_year = '1911'\n  AND c.nr_order = '1800'\nGROUP BY m.movie_id;": [
        4287.95,
        3350.22,
        3347.78,
        3346.51,
        3344.67,
        3331.79,
        3225.86,
        12.15,
        8.33,
        105.92,
        12.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '77') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '370'\n  AND m.movie_id <= '512'\n  AND t.production_year = '1907'\n  AND c.nr_order = '77'\nGROUP BY m.movie_id;": [
        4914.35,
        3976.61,
        3974.17,
        3972.9,
        3971.07,
        3905.34,
        3887.93,
        13.78,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '93') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '370'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1909'\n  AND c.nr_order = '93'\nGROUP BY m.movie_id;": [
        5021.69,
        4083.95,
        4081.51,
        4080.24,
        4078.41,
        3979.82,
        3964.16,
        13.96,
        8.3,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '428') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '108'\n  AND m.movie_id <= '217'\n  AND t.production_year = '1927'\n  AND c.nr_order = '428'\nGROUP BY m.movie_id;": [
        4074.95,
        3137.22,
        3134.78,
        3133.51,
        3100.65,
        3098.81,
        3081.4,
        11.79,
        8.34,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1202') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '297'\n  AND m.movie_id <= '405'\n  AND t.production_year = '1910'\n  AND c.nr_order = '1202'\nGROUP BY m.movie_id;": [
        4119.17,
        3181.43,
        3178.99,
        3177.72,
        3175.89,
        3162.79,
        3055.99,
        11.74,
        8.34,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1279') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '298'\n  AND m.movie_id <= '408'\n  AND t.production_year = '1909'\n  AND c.nr_order = '1279'\nGROUP BY m.movie_id;": [
        4131.47,
        3193.74,
        3191.3,
        3190.03,
        3188.19,
        3122.47,
        3106.81,
        11.86,
        8.34,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '353') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '119'\n  AND m.movie_id <= '188'\n  AND t.production_year = '1972'\n  AND c.nr_order = '353'\nGROUP BY m.movie_id;": [
        3104.92,
        2167.19,
        2164.75,
        2163.48,
        2161.64,
        2153.45,
        2080.53,
        9.38,
        8.39,
        72.91,
        8.13,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1021') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '137'\n  AND m.movie_id <= '205'\n  AND t.production_year = '1889'\n  AND c.nr_order = '1021'\nGROUP BY m.movie_id;": [
        3048.67,
        2110.94,
        2108.5,
        2107.23,
        2074.37,
        2072.53,
        2055.12,
        9.31,
        8.38,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '526') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '159'\n  AND m.movie_id <= '276'\n  AND t.production_year = '1926'\n  AND c.nr_order = '526'\nGROUP BY m.movie_id;": [
        4303.1,
        3365.36,
        3362.92,
        3361.65,
        3359.82,
        3294.09,
        3276.68,
        12.28,
        8.33,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '373') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '426'\n  AND m.movie_id <= '503'\n  AND t.production_year = '2019'\n  AND c.nr_order = '373'\nGROUP BY m.movie_id;": [
        3269.36,
        2331.63,
        2329.19,
        2327.92,
        2295.06,
        2293.22,
        2275.81,
        9.86,
        8.36,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1015') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '393'\n  AND m.movie_id <= '508'\n  AND t.production_year = '1976'\n  AND c.nr_order = '1015'\nGROUP BY m.movie_id;": [
        4324.2,
        3386.47,
        3384.03,
        3382.76,
        3380.92,
        3372.69,
        3225.86,
        12.15,
        8.33,
        73.4,
        8.17,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '226') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '231'\n  AND m.movie_id <= '337'\n  AND t.production_year = '1961'\n  AND c.nr_order = '226'\nGROUP BY m.movie_id;": [
        4121.86,
        3184.12,
        3181.68,
        3180.41,
        3178.58,
        3169.53,
        3005.17,
        11.62,
        8.34,
        82.17,
        8.99,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '230') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '236'\n  AND m.movie_id <= '343'\n  AND t.production_year = '1961'\n  AND c.nr_order = '230'\nGROUP BY m.movie_id;": [
        4147.27,
        3209.53,
        3207.09,
        3205.82,
        3203.99,
        3194.94,
        3030.58,
        11.68,
        8.34,
        82.17,
        8.99,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '50') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '357'\n  AND m.movie_id <= '391'\n  AND t.production_year = '2015'\n  AND c.nr_order = '50'\nGROUP BY m.movie_id;": [
        2196.74,
        1259.0,
        1256.56,
        1255.29,
        1222.43,
        1220.59,
        1203.18,
        7.27,
        8.42,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '106') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '447'\n  AND m.movie_id <= '502'\n  AND t.production_year = '1941'\n  AND c.nr_order = '106'\nGROUP BY m.movie_id;": [
        2726.34,
        1788.61,
        1786.17,
        1784.9,
        1752.04,
        1750.2,
        1732.79,
        8.54,
        8.41,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '259') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '333'\n  AND m.movie_id <= '351'\n  AND t.production_year = '1987'\n  AND c.nr_order = '259'\nGROUP BY m.movie_id;": [
        1812.53,
        874.8,
        872.36,
        871.09,
        869.25,
        862.14,
        800.62,
        6.32,
        8.45,
        61.51,
        7.05,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2402') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '275'\n  AND m.movie_id <= '398'\n  AND t.production_year = '1893'\n  AND c.nr_order = '2402'\nGROUP BY m.movie_id;": [
        4451.56,
        3513.82,
        3511.38,
        3510.11,
        3508.28,
        3442.55,
        3425.14,
        12.63,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2303') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '274'\n  AND m.movie_id <= '398'\n  AND t.production_year = '1896'\n  AND c.nr_order = '2303'\nGROUP BY m.movie_id;": [
        4476.97,
        3539.23,
        3536.79,
        3535.52,
        3533.69,
        3467.96,
        3450.55,
        12.69,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2302') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '275'\n  AND m.movie_id <= '398'\n  AND t.production_year = '1896'\n  AND c.nr_order = '2302'\nGROUP BY m.movie_id;": [
        4451.56,
        3513.82,
        3511.38,
        3510.11,
        3508.28,
        3442.55,
        3425.14,
        12.63,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2198') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '265'\n  AND m.movie_id <= '403'\n  AND t.production_year = '1892'\n  AND c.nr_order = '2198'\nGROUP BY m.movie_id;": [
        4820.71,
        3882.97,
        3880.53,
        3879.26,
        3877.43,
        3811.7,
        3794.29,
        13.54,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '15003') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '109'\n  AND m.movie_id <= '238'\n  AND t.production_year = '1880'\n  AND c.nr_order = '15003'\nGROUP BY m.movie_id;": [
        4600.02,
        3662.28,
        3659.84,
        3658.57,
        3656.74,
        3591.01,
        3573.6,
        13.0,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1025') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '393'\n  AND m.movie_id <= '510'\n  AND t.production_year = '1963'\n  AND c.nr_order = '1025'\nGROUP BY m.movie_id;": [
        4388.22,
        3450.49,
        3448.05,
        3446.78,
        3444.94,
        3436.12,
        3276.68,
        12.28,
        8.33,
        79.71,
        8.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1049') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '198'\n  AND m.movie_id <= '326'\n  AND t.production_year = '1941'\n  AND c.nr_order = '1049'\nGROUP BY m.movie_id;": [
        4574.61,
        3636.87,
        3634.43,
        3633.16,
        3631.33,
        3565.6,
        3548.19,
        12.94,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1703') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '295'\n  AND m.movie_id <= '405'\n  AND t.production_year = '1911'\n  AND c.nr_order = '1703'\nGROUP BY m.movie_id;": [
        4168.9,
        3231.17,
        3228.73,
        3227.46,
        3225.62,
        3212.74,
        3106.81,
        11.86,
        8.34,
        105.92,
        12.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1046') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '107'\n  AND m.movie_id <= '363'\n  AND t.production_year = '1962'\n  AND c.nr_order = '1046'\nGROUP BY m.movie_id;": [
        7865.3,
        6927.57,
        6925.13,
        6923.86,
        6922.02,
        6912.56,
        6652.67,
        24.61,
        8.19,
        86.62,
        9.4,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '461') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '319'\n  AND m.movie_id <= '439'\n  AND t.production_year = '1971'\n  AND c.nr_order = '461'\nGROUP BY m.movie_id;": [
        4446.73,
        3509.0,
        3506.56,
        3505.29,
        3503.45,
        3495.24,
        3348.91,
        12.46,
        8.32,
        73.16,
        8.15,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1045') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '203'\n  AND m.movie_id <= '327'\n  AND t.production_year = '1946'\n  AND c.nr_order = '1045'\nGROUP BY m.movie_id;": [
        4476.97,
        3539.23,
        3536.79,
        3535.52,
        3533.69,
        3467.96,
        3450.55,
        12.69,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '84') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '368'\n  AND m.movie_id <= '511'\n  AND t.production_year = '1905'\n  AND c.nr_order = '84'\nGROUP BY m.movie_id;": [
        4939.76,
        4002.02,
        3999.58,
        3998.31,
        3996.48,
        3930.75,
        3913.34,
        13.83,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1022') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '393'\n  AND m.movie_id <= '509'\n  AND t.production_year = '1961'\n  AND c.nr_order = '1022'\nGROUP BY m.movie_id;": [
        4367.96,
        3430.22,
        3427.78,
        3426.51,
        3424.68,
        3415.63,
        3251.27,
        12.21,
        8.33,
        82.17,
        8.99,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1025') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '391'\n  AND m.movie_id <= '511'\n  AND t.production_year = '1960'\n  AND c.nr_order = '1025'\nGROUP BY m.movie_id;": [
        4461.86,
        3524.13,
        3521.69,
        3520.42,
        3518.58,
        3509.7,
        3348.91,
        12.46,
        8.32,
        80.38,
        8.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '228') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '238'\n  AND m.movie_id <= '342'\n  AND t.production_year = '1956'\n  AND c.nr_order = '228'\nGROUP BY m.movie_id;": [
        4003.15,
        3065.42,
        3062.98,
        3061.71,
        3059.87,
        3049.87,
        2958.35,
        11.5,
        8.35,
        91.51,
        9.94,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '225') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '233'\n  AND m.movie_id <= '343'\n  AND t.production_year = '1961'\n  AND c.nr_order = '225'\nGROUP BY m.movie_id;": [
        4223.5,
        3285.76,
        3283.32,
        3282.05,
        3280.22,
        3271.17,
        3106.81,
        11.86,
        8.34,
        82.17,
        8.99,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '225') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '231'\n  AND m.movie_id <= '339'\n  AND t.production_year = '1961'\n  AND c.nr_order = '225'\nGROUP BY m.movie_id;": [
        4172.68,
        3234.94,
        3232.5,
        3231.23,
        3229.4,
        3220.35,
        3055.99,
        11.74,
        8.34,
        82.17,
        8.99,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '15101') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '110'\n  AND m.movie_id <= '238'\n  AND t.production_year = '1880'\n  AND c.nr_order = '15101'\nGROUP BY m.movie_id;": [
        4574.61,
        3636.87,
        3634.43,
        3633.16,
        3631.33,
        3565.6,
        3548.19,
        12.94,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '461') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '316'\n  AND m.movie_id <= '440'\n  AND t.production_year = '1969'\n  AND c.nr_order = '461'\nGROUP BY m.movie_id;": [
        4600.9,
        3663.16,
        3660.72,
        3659.45,
        3657.62,
        3650.03,
        3450.55,
        12.69,
        8.32,
        66.48,
        7.52,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2153') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '261'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1890'\n  AND c.nr_order = '2153'\nGROUP BY m.movie_id;": [
        4871.53,
        3933.79,
        3931.35,
        3930.08,
        3928.25,
        3862.52,
        3845.11,
        13.65,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2198') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '263'\n  AND m.movie_id <= '402'\n  AND t.production_year = '1893'\n  AND c.nr_order = '2198'\nGROUP BY m.movie_id;": [
        4846.12,
        3908.38,
        3905.94,
        3904.67,
        3902.84,
        3837.11,
        3819.7,
        13.6,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1010') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '389'\n  AND m.movie_id <= '508'\n  AND t.production_year = '1976'\n  AND c.nr_order = '1010'\nGROUP BY m.movie_id;": [
        4421.84,
        3484.11,
        3481.67,
        3480.4,
        3478.56,
        3470.33,
        3323.5,
        12.4,
        8.32,
        73.4,
        8.17,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1009') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '394'\n  AND m.movie_id <= '510'\n  AND t.production_year = '1976'\n  AND c.nr_order = '1009'\nGROUP BY m.movie_id;": [
        4349.61,
        3411.88,
        3409.44,
        3408.17,
        3406.33,
        3398.1,
        3251.27,
        12.21,
        8.33,
        73.4,
        8.17,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1305') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '290'\n  AND m.movie_id <= '405'\n  AND t.production_year = '1910'\n  AND c.nr_order = '1305'\nGROUP BY m.movie_id;": [
        4289.04,
        3351.3,
        3348.86,
        3347.59,
        3345.76,
        3332.66,
        3225.86,
        12.15,
        8.33,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '6002') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '88'\n  AND m.movie_id <= '271'\n  AND t.production_year = '2010'\n  AND c.nr_order = '6002'\nGROUP BY m.movie_id;": [
        7050.77,
        6113.03,
        6110.59,
        6109.32,
        6107.49,
        6102.78,
        4889.74,
        16.23,
        8.26,
        36.75,
        4.64,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1279') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '295'\n  AND m.movie_id <= '400'\n  AND t.production_year = '1909'\n  AND c.nr_order = '1279'\nGROUP BY m.movie_id;": [
        4008.42,
        3070.69,
        3068.25,
        3066.98,
        3065.14,
        2999.42,
        2983.76,
        11.56,
        8.35,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1279') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '296'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1912'\n  AND c.nr_order = '1279'\nGROUP BY m.movie_id;": [
        4029.3,
        3091.57,
        3089.13,
        3087.86,
        3086.02,
        3075.92,
        2983.76,
        11.56,
        8.35,
        92.15,
        10.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '90') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '377'\n  AND m.movie_id <= '517'\n  AND t.production_year = '1909'\n  AND c.nr_order = '90'\nGROUP BY m.movie_id;": [
        4902.64,
        3964.9,
        3962.46,
        3961.19,
        3959.36,
        3860.77,
        3845.11,
        13.65,
        8.31,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '81') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '378'\n  AND m.movie_id <= '518'\n  AND t.production_year = '1897'\n  AND c.nr_order = '81'\nGROUP BY m.movie_id;": [
        4871.53,
        3933.79,
        3931.35,
        3930.08,
        3928.25,
        3862.52,
        3845.11,
        13.65,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '527') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '226'\n  AND m.movie_id <= '233'\n  AND t.production_year = '1963'\n  AND c.nr_order = '527'\nGROUP BY m.movie_id;": [
        1506.07,
        568.34,
        565.9,
        564.63,
        531.76,
        529.93,
        521.11,
        5.66,
        8.45,
        8.76,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1004') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '345'\n  AND m.movie_id <= '477'\n  AND t.production_year = '1951'\n  AND c.nr_order = '1004'\nGROUP BY m.movie_id;": [
        4708.46,
        3770.73,
        3768.29,
        3767.02,
        3765.18,
        3752.19,
        3645.83,
        13.18,
        8.31,
        106.35,
        12.93,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '428') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '110'\n  AND m.movie_id <= '218'\n  AND t.production_year = '1926'\n  AND c.nr_order = '428'\nGROUP BY m.movie_id;": [
        4049.54,
        3111.81,
        3109.37,
        3108.1,
        3075.24,
        3073.4,
        3055.99,
        11.74,
        8.34,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '328') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '170'\n  AND m.movie_id <= '280'\n  AND t.production_year = '1998'\n  AND c.nr_order = '328'\nGROUP BY m.movie_id;": [
        4373.89,
        3436.16,
        3433.72,
        3432.45,
        3430.61,
        3425.09,
        3106.81,
        11.86,
        8.34,
        45.46,
        5.46,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1306') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '297'\n  AND m.movie_id <= '406'\n  AND t.production_year = '1912'\n  AND c.nr_order = '1306'\nGROUP BY m.movie_id;": [
        4126.94,
        3189.21,
        3186.77,
        3185.5,
        3183.66,
        3173.56,
        3081.4,
        11.79,
        8.34,
        92.15,
        10.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2125') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '76'\n  AND m.movie_id <= '446'\n  AND t.production_year = '1924'\n  AND c.nr_order = '2125'\nGROUP BY m.movie_id;": [
        10421.61,
        9483.88,
        9481.44,
        9480.17,
        9478.33,
        9462.57,
        9341.88,
        31.47,
        8.08,
        120.67,
        15.71,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '525') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '159'\n  AND m.movie_id <= '277'\n  AND t.production_year = '1930'\n  AND c.nr_order = '525'\nGROUP BY m.movie_id;": [
        4359.62,
        3421.88,
        3419.44,
        3418.17,
        3416.34,
        3317.75,
        3302.09,
        12.34,
        8.33,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '396') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '252'\n  AND m.movie_id <= '354'\n  AND t.production_year = '1942'\n  AND c.nr_order = '396'\nGROUP BY m.movie_id;": [
        3901.08,
        2963.35,
        2960.91,
        2959.64,
        2926.78,
        2924.94,
        2907.53,
        11.38,
        8.35,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '396') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '253'\n  AND m.movie_id <= '355'\n  AND t.production_year = '1941'\n  AND c.nr_order = '396'\nGROUP BY m.movie_id;": [
        3901.08,
        2963.35,
        2960.91,
        2959.64,
        2926.78,
        2924.94,
        2907.53,
        11.38,
        8.35,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '38000') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '130'\n  AND m.movie_id <= '490'\n  AND t.production_year = '1945'\n  AND c.nr_order = '38000'\nGROUP BY m.movie_id;": [
        10199.97,
        9262.24,
        9259.8,
        9258.53,
        9256.69,
        9240.39,
        9111.78,
        30.87,
        8.09,
        128.59,
        16.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '417') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '108'\n  AND m.movie_id <= '218'\n  AND t.production_year = '1928'\n  AND c.nr_order = '417'\nGROUP BY m.movie_id;": [
        4131.59,
        3193.85,
        3191.41,
        3190.14,
        3188.31,
        3122.58,
        3106.81,
        11.86,
        8.34,
        15.71,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1301') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '297'\n  AND m.movie_id <= '400'\n  AND t.production_year = '1912'\n  AND c.nr_order = '1301'\nGROUP BY m.movie_id;": [
        3978.48,
        3040.75,
        3038.31,
        3037.04,
        3035.2,
        3025.1,
        2932.94,
        11.44,
        8.35,
        92.15,
        10.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1279') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '297'\n  AND m.movie_id <= '402'\n  AND t.production_year = '1912'\n  AND c.nr_order = '1279'\nGROUP BY m.movie_id;": [
        4029.3,
        3091.57,
        3089.13,
        3087.86,
        3086.02,
        3075.92,
        2983.76,
        11.56,
        8.35,
        92.15,
        10.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '88') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '367'\n  AND m.movie_id <= '512'\n  AND t.production_year = '1900'\n  AND c.nr_order = '88'\nGROUP BY m.movie_id;": [
        4990.58,
        4052.84,
        4050.4,
        4049.13,
        4047.3,
        3981.57,
        3964.16,
        13.96,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '77') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '373'\n  AND m.movie_id <= '518'\n  AND t.production_year = '1908'\n  AND c.nr_order = '77'\nGROUP BY m.movie_id;": [
        4990.58,
        4052.84,
        4050.4,
        4049.13,
        4047.3,
        3981.57,
        3964.16,
        13.96,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '89') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '367'\n  AND m.movie_id <= '513'\n  AND t.production_year = '1901'\n  AND c.nr_order = '89'\nGROUP BY m.movie_id;": [
        5015.99,
        4078.25,
        4075.81,
        4074.54,
        4072.71,
        4006.98,
        3989.57,
        14.01,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '78') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '370'\n  AND m.movie_id <= '512'\n  AND t.production_year = '1906'\n  AND c.nr_order = '78'\nGROUP BY m.movie_id;": [
        4914.35,
        3976.61,
        3974.17,
        3972.9,
        3971.07,
        3905.34,
        3887.93,
        13.78,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '264') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '438'\n  AND m.movie_id <= '488'\n  AND t.production_year = '1911'\n  AND c.nr_order = '264'\nGROUP BY m.movie_id;": [
        2627.63,
        1689.89,
        1687.45,
        1686.18,
        1684.35,
        1618.62,
        1605.74,
        8.24,
        8.41,
        12.82,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '78') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '370'\n  AND m.movie_id <= '512'\n  AND t.production_year = '1906'\n  AND c.nr_order = '78'\nGROUP BY m.movie_id;": [
        4914.35,
        3976.61,
        3974.17,
        3972.9,
        3971.07,
        3905.34,
        3887.93,
        13.78,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '81') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '370'\n  AND m.movie_id <= '511'\n  AND t.production_year = '1909'\n  AND c.nr_order = '81'\nGROUP BY m.movie_id;": [
        4924.05,
        3986.31,
        3983.87,
        3982.6,
        3980.77,
        3882.18,
        3866.52,
        13.72,
        8.3,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '91') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '370'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1901'\n  AND c.nr_order = '91'\nGROUP BY m.movie_id;": [
        4990.58,
        4052.84,
        4050.4,
        4049.13,
        4047.3,
        3981.57,
        3964.16,
        13.96,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1045') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '202'\n  AND m.movie_id <= '328'\n  AND t.production_year = '1944'\n  AND c.nr_order = '1045'\nGROUP BY m.movie_id;": [
        4523.79,
        3586.05,
        3583.61,
        3582.34,
        3580.51,
        3514.78,
        3497.37,
        12.82,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '90') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '369'\n  AND m.movie_id <= '513'\n  AND t.production_year = '1906'\n  AND c.nr_order = '90'\nGROUP BY m.movie_id;": [
        4965.17,
        4027.43,
        4024.99,
        4023.72,
        4021.89,
        3956.16,
        3938.75,
        13.9,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '715') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '275'\n  AND m.movie_id <= '407'\n  AND t.production_year = '1894'\n  AND c.nr_order = '715'\nGROUP BY m.movie_id;": [
        4672.25,
        3734.51,
        3732.07,
        3730.8,
        3728.97,
        3663.24,
        3645.83,
        13.18,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '525') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '161'\n  AND m.movie_id <= '276'\n  AND t.production_year = '1925'\n  AND c.nr_order = '525'\nGROUP BY m.movie_id;": [
        4252.28,
        3314.54,
        3312.1,
        3310.83,
        3309.0,
        3243.27,
        3225.86,
        12.15,
        8.33,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1279') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '295'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1913'\n  AND c.nr_order = '1279'\nGROUP BY m.movie_id;": [
        4056.31,
        3118.58,
        3116.14,
        3114.87,
        3113.03,
        3102.08,
        3005.17,
        11.62,
        8.34,
        96.9,
        10.89,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '418') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '107'\n  AND m.movie_id <= '217'\n  AND t.production_year = '1925'\n  AND c.nr_order = '418'\nGROUP BY m.movie_id;": [
        4100.36,
        3162.63,
        3160.19,
        3158.92,
        3126.06,
        3124.22,
        3106.81,
        11.86,
        8.34,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '527') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '160'\n  AND m.movie_id <= '272'\n  AND t.production_year = '1925'\n  AND c.nr_order = '527'\nGROUP BY m.movie_id;": [
        4184.05,
        3246.31,
        3243.87,
        3242.6,
        3240.77,
        3175.04,
        3157.63,
        11.97,
        8.34,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '417') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '109'\n  AND m.movie_id <= '214'\n  AND t.production_year = '1924'\n  AND c.nr_order = '417'\nGROUP BY m.movie_id;": [
        4008.54,
        3070.8,
        3068.36,
        3067.09,
        3065.26,
        2999.53,
        2983.76,
        11.56,
        8.35,
        15.71,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '417') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '109'\n  AND m.movie_id <= '218'\n  AND t.production_year = '1927'\n  AND c.nr_order = '417'\nGROUP BY m.movie_id;": [
        4074.95,
        3137.22,
        3134.78,
        3133.51,
        3100.65,
        3098.81,
        3081.4,
        11.79,
        8.34,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1050') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '199'\n  AND m.movie_id <= '325'\n  AND t.production_year = '1942'\n  AND c.nr_order = '1050'\nGROUP BY m.movie_id;": [
        4523.79,
        3586.05,
        3583.61,
        3582.34,
        3580.51,
        3514.78,
        3497.37,
        12.82,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '392') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '107'\n  AND m.movie_id <= '215'\n  AND t.production_year = '1925'\n  AND c.nr_order = '392'\nGROUP BY m.movie_id;": [
        4049.54,
        3111.81,
        3109.37,
        3108.1,
        3075.24,
        3073.4,
        3055.99,
        11.74,
        8.34,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '606') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '33'\n  AND m.movie_id <= '202'\n  AND t.production_year = '1899'\n  AND c.nr_order = '606'\nGROUP BY m.movie_id;": [
        5576.42,
        4638.68,
        4636.24,
        4634.97,
        4633.14,
        4567.41,
        4550.0,
        15.4,
        8.27,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '14002') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '109'\n  AND m.movie_id <= '236'\n  AND t.production_year = '1880'\n  AND c.nr_order = '14002'\nGROUP BY m.movie_id;": [
        4549.2,
        3611.46,
        3609.02,
        3607.75,
        3605.92,
        3540.19,
        3522.78,
        12.87,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1700') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '138'\n  AND m.movie_id <= '275'\n  AND t.production_year = '1907'\n  AND c.nr_order = '1700'\nGROUP BY m.movie_id;": [
        4795.3,
        3857.56,
        3855.12,
        3853.85,
        3852.02,
        3786.29,
        3768.88,
        13.47,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '418') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '370'\n  AND m.movie_id <= '492'\n  AND t.production_year = '1954'\n  AND c.nr_order = '418'\nGROUP BY m.movie_id;": [
        4450.03,
        3512.29,
        3509.86,
        3508.59,
        3506.75,
        3495.93,
        3399.73,
        12.58,
        8.32,
        96.19,
        10.75,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '4000') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '97'\n  AND m.movie_id <= '436'\n  AND t.production_year = '1904'\n  AND c.nr_order = '4000'\nGROUP BY m.movie_id;": [
        9706.36,
        8768.63,
        8766.19,
        8764.92,
        8763.08,
        8746.78,
        8618.17,
        29.61,
        8.11,
        128.59,
        16.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2147') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '275'\n  AND m.movie_id <= '406'\n  AND t.production_year = '1897'\n  AND c.nr_order = '2147'\nGROUP BY m.movie_id;": [
        4646.84,
        3709.1,
        3706.66,
        3705.39,
        3703.56,
        3637.83,
        3620.42,
        13.12,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '78') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '513'\n  AND t.production_year = '1909'\n  AND c.nr_order = '78'\nGROUP BY m.movie_id;": [
        4945.46,
        4007.72,
        4005.28,
        4004.01,
        4002.18,
        3903.59,
        3887.93,
        13.78,
        8.3,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '78') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1908'\n  AND c.nr_order = '78'\nGROUP BY m.movie_id;": [
        4965.17,
        4027.43,
        4024.99,
        4023.72,
        4021.89,
        3956.16,
        3938.75,
        13.9,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '91') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '514'\n  AND t.production_year = '1908'\n  AND c.nr_order = '91'\nGROUP BY m.movie_id;": [
        4939.76,
        4002.02,
        3999.58,
        3998.31,
        3996.48,
        3930.75,
        3913.34,
        13.83,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1306') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '293'\n  AND m.movie_id <= '403'\n  AND t.production_year = '1908'\n  AND c.nr_order = '1306'\nGROUP BY m.movie_id;": [
        4100.36,
        3162.63,
        3160.19,
        3158.92,
        3126.06,
        3124.22,
        3106.81,
        11.86,
        8.34,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '72') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '347'\n  AND m.movie_id <= '492'\n  AND t.production_year = '1959'\n  AND c.nr_order = '72'\nGROUP BY m.movie_id;": [
        5082.42,
        4144.69,
        4142.25,
        4140.98,
        4139.15,
        4130.03,
        3964.16,
        13.96,
        8.3,
        82.92,
        9.06,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '793') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '273'\n  AND m.movie_id <= '410'\n  AND t.production_year = '1896'\n  AND c.nr_order = '793'\nGROUP BY m.movie_id;": [
        4795.3,
        3857.56,
        3855.12,
        3853.85,
        3852.02,
        3786.29,
        3768.88,
        13.47,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '806') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '271'\n  AND m.movie_id <= '411'\n  AND t.production_year = '1895'\n  AND c.nr_order = '806'\nGROUP BY m.movie_id;": [
        4871.53,
        3933.79,
        3931.35,
        3930.08,
        3928.25,
        3862.52,
        3845.11,
        13.65,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '233') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '233'\n  AND m.movie_id <= '344'\n  AND t.production_year = '1958'\n  AND c.nr_order = '233'\nGROUP BY m.movie_id;": [
        4173.08,
        3235.34,
        3232.9,
        3231.63,
        3229.8,
        3220.21,
        3132.22,
        11.92,
        8.34,
        87.98,
        9.52,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2401') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '271'\n  AND m.movie_id <= '403'\n  AND t.production_year = '1900'\n  AND c.nr_order = '2401'\nGROUP BY m.movie_id;": [
        4672.25,
        3734.51,
        3732.07,
        3730.8,
        3728.97,
        3663.24,
        3645.83,
        13.18,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1036') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '390'\n  AND m.movie_id <= '510'\n  AND t.production_year = '1960'\n  AND c.nr_order = '1036'\nGROUP BY m.movie_id;": [
        4461.86,
        3524.13,
        3521.69,
        3520.42,
        3518.58,
        3509.7,
        3348.91,
        12.46,
        8.32,
        80.38,
        8.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1025') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '395'\n  AND m.movie_id <= '510'\n  AND t.production_year = '1959'\n  AND c.nr_order = '1025'\nGROUP BY m.movie_id;": [
        4344.12,
        3406.39,
        3403.95,
        3402.68,
        3400.85,
        3391.73,
        3225.86,
        12.15,
        8.33,
        82.92,
        9.06,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '338') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '169'\n  AND m.movie_id <= '282'\n  AND t.production_year = '1998'\n  AND c.nr_order = '338'\nGROUP BY m.movie_id;": [
        4446.12,
        3508.39,
        3505.95,
        3504.68,
        3502.84,
        3497.32,
        3179.04,
        12.04,
        8.33,
        45.46,
        5.46,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '329') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '170'\n  AND m.movie_id <= '277'\n  AND t.production_year = '1998'\n  AND c.nr_order = '329'\nGROUP BY m.movie_id;": [
        4252.2,
        3314.46,
        3312.02,
        3310.75,
        3308.92,
        3303.39,
        3030.58,
        11.68,
        8.34,
        45.46,
        5.46,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1055') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '206'\n  AND m.movie_id <= '339'\n  AND t.production_year = '1967'\n  AND c.nr_order = '1055'\nGROUP BY m.movie_id;": [
        4809.68,
        3871.95,
        3869.51,
        3868.24,
        3866.4,
        3859.18,
        3671.24,
        13.24,
        8.31,
        62.64,
        7.16,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1050') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '196'\n  AND m.movie_id <= '326'\n  AND t.production_year = '1940'\n  AND c.nr_order = '1050'\nGROUP BY m.movie_id;": [
        4625.43,
        3687.69,
        3685.25,
        3683.98,
        3682.15,
        3616.42,
        3599.01,
        13.06,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1046') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '200'\n  AND m.movie_id <= '326'\n  AND t.production_year = '1943'\n  AND c.nr_order = '1046'\nGROUP BY m.movie_id;": [
        4523.79,
        3586.05,
        3583.61,
        3582.34,
        3580.51,
        3514.78,
        3497.37,
        12.82,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '97') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '374'\n  AND m.movie_id <= '512'\n  AND t.production_year = '1909'\n  AND c.nr_order = '97'\nGROUP BY m.movie_id;": [
        4851.82,
        3914.08,
        3911.64,
        3910.37,
        3908.54,
        3809.95,
        3794.29,
        13.54,
        8.31,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '93') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '513'\n  AND t.production_year = '1907'\n  AND c.nr_order = '93'\nGROUP BY m.movie_id;": [
        4914.35,
        3976.61,
        3974.17,
        3972.9,
        3971.07,
        3905.34,
        3887.93,
        13.78,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '89') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '375'\n  AND m.movie_id <= '517'\n  AND t.production_year = '1911'\n  AND c.nr_order = '89'\nGROUP BY m.movie_id;": [
        4950.02,
        4012.29,
        4009.85,
        4008.58,
        4006.74,
        3993.86,
        3887.93,
        13.78,
        8.3,
        105.92,
        12.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1901') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '294'\n  AND m.movie_id <= '407'\n  AND t.production_year = '1909'\n  AND c.nr_order = '1901'\nGROUP BY m.movie_id;": [
        4203.7,
        3265.97,
        3263.53,
        3262.26,
        3260.42,
        3194.7,
        3179.04,
        12.04,
        8.33,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '84') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '367'\n  AND m.movie_id <= '507'\n  AND t.production_year = '1904'\n  AND c.nr_order = '84'\nGROUP BY m.movie_id;": [
        4871.53,
        3933.79,
        3931.35,
        3930.08,
        3928.25,
        3862.52,
        3845.11,
        13.65,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1167') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '26'\n  AND m.movie_id <= '180'\n  AND t.production_year = '1972'\n  AND c.nr_order = '1167'\nGROUP BY m.movie_id;": [
        5355.09,
        4417.36,
        4414.92,
        4413.65,
        4411.81,
        4403.63,
        4184.85,
        14.5,
        8.29,
        72.91,
        8.13,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '497') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '260'\n  AND m.movie_id <= '294'\n  AND t.production_year = '1891'\n  AND c.nr_order = '497'\nGROUP BY m.movie_id;": [
        2196.74,
        1259.0,
        1256.56,
        1255.29,
        1222.43,
        1220.59,
        1203.18,
        7.27,
        8.42,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '27') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '19'\n  AND m.movie_id <= '274'\n  AND t.production_year = '1919'\n  AND c.nr_order = '27'\nGROUP BY m.movie_id;": [
        7688.05,
        6750.32,
        6747.88,
        6746.61,
        6744.77,
        6739.59,
        6627.26,
        24.56,
        8.19,
        112.31,
        5.12,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '15101') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '179'\n  AND m.movie_id <= '512'\n  AND t.production_year = '1880'\n  AND c.nr_order = '15101'\nGROUP BY m.movie_id;": [
        9569.9,
        8632.17,
        8629.73,
        8628.46,
        8626.62,
        8610.32,
        8481.71,
        29.25,
        8.12,
        128.59,
        16.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '428') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '370'\n  AND m.movie_id <= '492'\n  AND t.production_year = '1954'\n  AND c.nr_order = '428'\nGROUP BY m.movie_id;": [
        4450.03,
        3512.29,
        3509.86,
        3508.59,
        3506.75,
        3495.93,
        3399.73,
        12.58,
        8.32,
        96.19,
        10.75,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '428') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '374'\n  AND m.movie_id <= '498'\n  AND t.production_year = '1954'\n  AND c.nr_order = '428'\nGROUP BY m.movie_id;": [
        4500.85,
        3563.11,
        3560.68,
        3559.41,
        3557.57,
        3546.75,
        3450.55,
        12.69,
        8.32,
        96.19,
        10.75,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '8000') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '99'\n  AND m.movie_id <= '233'\n  AND t.production_year = '1976'\n  AND c.nr_order = '8000'\nGROUP BY m.movie_id;": [
        4794.99,
        3857.26,
        3854.82,
        3853.55,
        3851.71,
        3843.48,
        3696.65,
        13.29,
        8.31,
        73.4,
        8.17,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1003') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '346'\n  AND m.movie_id <= '477'\n  AND t.production_year = '1955'\n  AND c.nr_order = '1003'\nGROUP BY m.movie_id;": [
        4671.08,
        3733.34,
        3730.9,
        3729.63,
        3727.8,
        3718.78,
        3620.42,
        13.12,
        8.31,
        98.35,
        8.95,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '15003') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '110'\n  AND m.movie_id <= '236'\n  AND t.production_year = '1888'\n  AND c.nr_order = '15003'\nGROUP BY m.movie_id;": [
        4523.79,
        3586.05,
        3583.61,
        3582.34,
        3580.51,
        3514.78,
        3497.37,
        12.82,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '15003') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '110'\n  AND m.movie_id <= '236'\n  AND t.production_year = '1880'\n  AND c.nr_order = '15003'\nGROUP BY m.movie_id;": [
        4523.79,
        3586.05,
        3583.61,
        3582.34,
        3580.51,
        3514.78,
        3497.37,
        12.82,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '14101') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '109'\n  AND m.movie_id <= '238'\n  AND t.production_year = '1889'\n  AND c.nr_order = '14101'\nGROUP BY m.movie_id;": [
        4600.02,
        3662.28,
        3659.84,
        3658.57,
        3656.74,
        3591.01,
        3573.6,
        13.0,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '95') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '377'\n  AND m.movie_id <= '511'\n  AND t.production_year = '1908'\n  AND c.nr_order = '95'\nGROUP BY m.movie_id;": [
        4723.07,
        3785.33,
        3782.89,
        3781.62,
        3779.79,
        3714.06,
        3696.65,
        13.29,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '222') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '235'\n  AND m.movie_id <= '341'\n  AND t.production_year = '1961'\n  AND c.nr_order = '222'\nGROUP BY m.movie_id;": [
        4121.86,
        3184.12,
        3181.68,
        3180.41,
        3178.58,
        3169.53,
        3005.17,
        11.62,
        8.34,
        82.17,
        8.99,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '324') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '172'\n  AND m.movie_id <= '278'\n  AND t.production_year = '2001'\n  AND c.nr_order = '324'\nGROUP BY m.movie_id;": [
        4298.35,
        3360.62,
        3358.18,
        3356.91,
        3355.07,
        3349.77,
        3005.17,
        11.62,
        8.34,
        43.06,
        5.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '328') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '168'\n  AND m.movie_id <= '277'\n  AND t.production_year = '1999'\n  AND c.nr_order = '328'\nGROUP BY m.movie_id;": [
        4340.87,
        3403.13,
        3400.69,
        3399.42,
        3397.59,
        3392.17,
        3081.4,
        11.79,
        8.34,
        44.38,
        5.36,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '50') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '206'\n  AND m.movie_id <= '518'\n  AND t.production_year = '1892'\n  AND c.nr_order = '50'\nGROUP BY m.movie_id;": [
        9065.0,
        8127.27,
        8124.83,
        8123.56,
        8121.72,
        8112.71,
        7984.1,
        28.0,
        8.14,
        128.59,
        8.95,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2198') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '261'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1891'\n  AND c.nr_order = '2198'\nGROUP BY m.movie_id;": [
        4871.53,
        3933.79,
        3931.35,
        3930.08,
        3928.25,
        3862.52,
        3845.11,
        13.65,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '806') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '95'\n  AND m.movie_id <= '423'\n  AND t.production_year = '1926'\n  AND c.nr_order = '806'\nGROUP BY m.movie_id;": [
        9450.85,
        8513.12,
        8510.68,
        8509.41,
        8507.57,
        8491.27,
        8362.66,
        28.95,
        8.12,
        128.59,
        16.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '91') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '370'\n  AND m.movie_id <= '513'\n  AND t.production_year = '1901'\n  AND c.nr_order = '91'\nGROUP BY m.movie_id;": [
        4939.76,
        4002.02,
        3999.58,
        3998.31,
        3996.48,
        3930.75,
        3913.34,
        13.83,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '418') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '109'\n  AND m.movie_id <= '217'\n  AND t.production_year = '1929'\n  AND c.nr_order = '418'\nGROUP BY m.movie_id;": [
        4049.54,
        3111.81,
        3109.37,
        3108.1,
        3075.24,
        3073.4,
        3055.99,
        11.74,
        8.34,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '312') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '280'\n  AND m.movie_id <= '294'\n  AND t.production_year = '1953'\n  AND c.nr_order = '312'\nGROUP BY m.movie_id;": [
        1688.11,
        750.38,
        747.94,
        746.67,
        713.8,
        711.97,
        698.98,
        6.08,
        8.45,
        12.93,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '149') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '48'\n  AND m.movie_id <= '72'\n  AND t.production_year = '2016'\n  AND c.nr_order = '149'\nGROUP BY m.movie_id;": [
        1946.64,
        1008.9,
        1006.46,
        1005.19,
        972.33,
        970.49,
        953.08,
        6.67,
        8.45,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '527') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '157'\n  AND m.movie_id <= '275'\n  AND t.production_year = '1927'\n  AND c.nr_order = '527'\nGROUP BY m.movie_id;": [
        4328.51,
        3390.77,
        3388.33,
        3387.06,
        3385.23,
        3319.5,
        3302.09,
        12.34,
        8.33,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '10623') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '61'\n  AND m.movie_id <= '239'\n  AND t.production_year = '1902'\n  AND c.nr_order = '10623'\nGROUP BY m.movie_id;": [
        5797.11,
        4859.37,
        4856.93,
        4855.66,
        4853.83,
        4788.1,
        4770.69,
        15.94,
        8.27,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1066') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '201'\n  AND m.movie_id <= '341'\n  AND t.production_year = '1967'\n  AND c.nr_order = '1066'\nGROUP BY m.movie_id;": [
        4983.55,
        4045.82,
        4043.38,
        4042.11,
        4040.27,
        4033.05,
        3845.11,
        13.65,
        8.31,
        62.64,
        7.16,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1056') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '204'\n  AND m.movie_id <= '338'\n  AND t.production_year = '1968'\n  AND c.nr_order = '1056'\nGROUP BY m.movie_id;": [
        4792.97,
        3855.23,
        3852.79,
        3851.52,
        3849.69,
        3841.55,
        3696.65,
        13.29,
        8.31,
        72.44,
        8.08,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '232') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '236'\n  AND m.movie_id <= '343'\n  AND t.production_year = '1956'\n  AND c.nr_order = '232'\nGROUP BY m.movie_id;": [
        4075.38,
        3137.65,
        3135.21,
        3133.94,
        3132.1,
        3122.1,
        3030.58,
        11.68,
        8.34,
        91.51,
        9.94,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '230') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '231'\n  AND m.movie_id <= '345'\n  AND t.production_year = '1963'\n  AND c.nr_order = '230'\nGROUP BY m.movie_id;": [
        4311.99,
        3374.26,
        3371.82,
        3370.55,
        3368.71,
        3359.89,
        3200.45,
        12.1,
        8.32,
        79.71,
        8.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1606') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '118'\n  AND m.movie_id <= '348'\n  AND t.production_year = '1968'\n  AND c.nr_order = '1606'\nGROUP BY m.movie_id;": [
        7265.23,
        6327.49,
        6325.05,
        6323.78,
        6321.95,
        6313.8,
        6024.01,
        19.05,
        8.21,
        72.44,
        8.08,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '230') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '231'\n  AND m.movie_id <= '346'\n  AND t.production_year = '1961'\n  AND c.nr_order = '230'\nGROUP BY m.movie_id;": [
        4342.55,
        3404.81,
        3402.37,
        3401.1,
        3399.27,
        3390.22,
        3225.86,
        12.15,
        8.33,
        82.17,
        8.99,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '527') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '157'\n  AND m.movie_id <= '275'\n  AND t.production_year = '1926'\n  AND c.nr_order = '527'\nGROUP BY m.movie_id;": [
        4328.51,
        3390.77,
        3388.33,
        3387.06,
        3385.23,
        3319.5,
        3302.09,
        12.34,
        8.33,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '7100') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '103'\n  AND m.movie_id <= '233'\n  AND t.production_year = '1975'\n  AND c.nr_order = '7100'\nGROUP BY m.movie_id;": [
        4697.87,
        3760.14,
        3757.7,
        3756.43,
        3754.59,
        3746.33,
        3599.01,
        13.06,
        8.32,
        73.65,
        8.19,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '7003') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '101'\n  AND m.movie_id <= '233'\n  AND t.production_year = '1976'\n  AND c.nr_order = '7003'\nGROUP BY m.movie_id;": [
        4744.17,
        3806.44,
        3804.0,
        3802.73,
        3800.89,
        3792.66,
        3645.83,
        13.18,
        8.31,
        73.4,
        8.17,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '21002') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '28'\n  AND m.movie_id <= '285'\n  AND t.production_year = '2015'\n  AND c.nr_order = '21002'\nGROUP BY m.movie_id;": [
        7733.36,
        6795.63,
        6793.19,
        6791.92,
        6790.08,
        6691.49,
        6674.08,
        24.68,
        8.19,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '95') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '375'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1905'\n  AND c.nr_order = '95'\nGROUP BY m.movie_id;": [
        4871.53,
        3933.79,
        3931.35,
        3930.08,
        3928.25,
        3862.52,
        3845.11,
        13.65,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '249') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '162'\n  AND m.movie_id <= '296'\n  AND t.production_year = '1914'\n  AND c.nr_order = '249'\nGROUP BY m.movie_id;": [
        4748.23,
        3810.49,
        3808.05,
        3806.78,
        3804.95,
        3793.92,
        3696.65,
        13.29,
        8.31,
        97.26,
        10.96,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1301') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '298'\n  AND m.movie_id <= '403'\n  AND t.production_year = '1907'\n  AND c.nr_order = '1301'\nGROUP BY m.movie_id;": [
        3977.31,
        3039.58,
        3037.14,
        3035.87,
        3003.01,
        3001.17,
        2983.76,
        11.56,
        8.35,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2501') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '277'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1898'\n  AND c.nr_order = '2501'\nGROUP BY m.movie_id;": [
        4476.97,
        3539.23,
        3536.79,
        3535.52,
        3533.69,
        3467.96,
        3450.55,
        12.69,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '18615') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '147'\n  AND m.movie_id <= '261'\n  AND t.production_year = '1977'\n  AND c.nr_order = '18615'\nGROUP BY m.movie_id;": [
        4299.31,
        3361.58,
        3359.14,
        3357.87,
        3356.03,
        3347.77,
        3200.45,
        12.1,
        8.32,
        73.65,
        8.19,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1279') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '297'\n  AND m.movie_id <= '402'\n  AND t.production_year = '1911'\n  AND c.nr_order = '1279'\nGROUP BY m.movie_id;": [
        4045.85,
        3108.12,
        3105.68,
        3104.41,
        3102.57,
        3089.69,
        2983.76,
        11.56,
        8.35,
        105.92,
        12.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1279') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '298'\n  AND m.movie_id <= '403'\n  AND t.production_year = '1911'\n  AND c.nr_order = '1279'\nGROUP BY m.movie_id;": [
        4045.85,
        3108.12,
        3105.68,
        3104.41,
        3102.57,
        3089.69,
        2983.76,
        11.56,
        8.35,
        105.92,
        12.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '78') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '376'\n  AND m.movie_id <= '516'\n  AND t.production_year = '1902'\n  AND c.nr_order = '78'\nGROUP BY m.movie_id;": [
        4871.53,
        3933.79,
        3931.35,
        3930.08,
        3928.25,
        3862.52,
        3845.11,
        13.65,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '234') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '227'\n  AND m.movie_id <= '341'\n  AND t.production_year = '1963'\n  AND c.nr_order = '234'\nGROUP BY m.movie_id;": [
        4311.99,
        3374.26,
        3371.82,
        3370.55,
        3368.71,
        3359.89,
        3200.45,
        12.1,
        8.32,
        79.71,
        8.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2302') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '263'\n  AND m.movie_id <= '402'\n  AND t.production_year = '1888'\n  AND c.nr_order = '2302'\nGROUP BY m.movie_id;": [
        4846.12,
        3908.38,
        3905.94,
        3904.67,
        3902.84,
        3837.11,
        3819.7,
        13.6,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '6100') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '221'\n  AND m.movie_id <= '393'\n  AND t.production_year = '1982'\n  AND c.nr_order = '6100'\nGROUP BY m.movie_id;": [
        5784.8,
        4847.07,
        4844.63,
        4843.36,
        4841.52,
        4833.57,
        4622.23,
        15.58,
        8.27,
        70.43,
        7.89,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '226') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '227'\n  AND m.movie_id <= '340'\n  AND t.production_year = '1965'\n  AND c.nr_order = '226'\nGROUP BY m.movie_id;": [
        4285.94,
        3348.21,
        3345.77,
        3344.5,
        3342.66,
        3334.05,
        3179.04,
        12.04,
        8.33,
        77.49,
        8.55,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '232') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '227'\n  AND m.movie_id <= '342'\n  AND t.production_year = '1964'\n  AND c.nr_order = '232'\nGROUP BY m.movie_id;": [
        4329.13,
        3391.4,
        3388.96,
        3387.69,
        3385.85,
        3377.4,
        3225.86,
        12.15,
        8.33,
        75.76,
        8.39,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1004') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '345'\n  AND m.movie_id <= '476'\n  AND t.production_year = '1954'\n  AND c.nr_order = '1004'\nGROUP BY m.movie_id;": [
        4670.72,
        3732.98,
        3730.55,
        3729.28,
        3727.44,
        3716.62,
        3620.42,
        13.12,
        8.31,
        96.19,
        10.75,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '123') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '231'\n  AND m.movie_id <= '486'\n  AND t.production_year = '1934'\n  AND c.nr_order = '123'\nGROUP BY m.movie_id;": [
        7686.54,
        6748.81,
        6746.37,
        6745.1,
        6743.26,
        6644.67,
        6627.26,
        24.56,
        8.19,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '74') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '376'\n  AND m.movie_id <= '510'\n  AND t.production_year = '1905'\n  AND c.nr_order = '74'\nGROUP BY m.movie_id;": [
        4723.07,
        3785.33,
        3782.89,
        3781.62,
        3779.79,
        3714.06,
        3696.65,
        13.29,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '74') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '376'\n  AND m.movie_id <= '508'\n  AND t.production_year = '1909'\n  AND c.nr_order = '74'\nGROUP BY m.movie_id;": [
        4703.36,
        3765.62,
        3763.18,
        3761.91,
        3760.08,
        3661.49,
        3645.83,
        13.18,
        8.31,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '9001') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '101'\n  AND m.movie_id <= '233'\n  AND t.production_year = '1975'\n  AND c.nr_order = '9001'\nGROUP BY m.movie_id;": [
        4744.69,
        3806.96,
        3804.52,
        3803.25,
        3801.41,
        3793.15,
        3645.83,
        13.18,
        8.31,
        73.65,
        8.19,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '328') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '172'\n  AND m.movie_id <= '274'\n  AND t.production_year = '2002'\n  AND c.nr_order = '328'\nGROUP BY m.movie_id;": [
        4193.45,
        3255.71,
        3253.27,
        3252.0,
        3250.17,
        3244.95,
        2907.53,
        11.38,
        8.35,
        42.17,
        5.15,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1048') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '389'\n  AND m.movie_id <= '506'\n  AND t.production_year = '1975'\n  AND c.nr_order = '1048'\nGROUP BY m.movie_id;": [
        4375.54,
        3437.81,
        3435.37,
        3434.1,
        3432.26,
        3424.0,
        3276.68,
        12.28,
        8.33,
        73.65,
        8.19,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '130'\n  AND m.movie_id <= '294'\n  AND t.production_year = '1926'\n  AND c.nr_order = '2'\nGROUP BY m.movie_id;": [
        6399.62,
        4524.15,
        4519.27,
        4517.76,
        4452.03,
        4448.36,
        4430.95,
        15.1,
        8.28,
        17.35,
        1.84,
        32.85,
        1.18,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1920') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '296'\n  AND m.movie_id <= '407'\n  AND t.production_year = '1909'\n  AND c.nr_order = '1920'\nGROUP BY m.movie_id;": [
        4156.88,
        3219.15,
        3216.71,
        3215.44,
        3213.6,
        3147.88,
        3132.22,
        11.92,
        8.34,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1066') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '203'\n  AND m.movie_id <= '342'\n  AND t.production_year = '1967'\n  AND c.nr_order = '1066'\nGROUP BY m.movie_id;": [
        4958.14,
        4020.41,
        4017.97,
        4016.7,
        4014.86,
        4007.64,
        3819.7,
        13.6,
        8.31,
        62.64,
        7.16,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1203') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '295'\n  AND m.movie_id <= '400'\n  AND t.production_year = '1916'\n  AND c.nr_order = '1203'\nGROUP BY m.movie_id;": [
        4047.5,
        3109.76,
        3107.32,
        3106.05,
        3104.22,
        3091.0,
        2983.76,
        11.56,
        8.35,
        107.23,
        13.16,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1700') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '295'\n  AND m.movie_id <= '402'\n  AND t.production_year = '1912'\n  AND c.nr_order = '1700'\nGROUP BY m.movie_id;": [
        4076.12,
        3138.39,
        3135.95,
        3134.68,
        3132.84,
        3122.74,
        3030.58,
        11.68,
        8.34,
        92.15,
        10.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1400') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '297'\n  AND m.movie_id <= '404'\n  AND t.production_year = '1912'\n  AND c.nr_order = '1400'\nGROUP BY m.movie_id;": [
        4076.12,
        3138.39,
        3135.95,
        3134.68,
        3132.84,
        3122.74,
        3030.58,
        11.68,
        8.34,
        92.15,
        10.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '94') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '370'\n  AND m.movie_id <= '513'\n  AND t.production_year = '1904'\n  AND c.nr_order = '94'\nGROUP BY m.movie_id;": [
        4939.76,
        4002.02,
        3999.58,
        3998.31,
        3996.48,
        3930.75,
        3913.34,
        13.83,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '78') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '373'\n  AND m.movie_id <= '511'\n  AND t.production_year = '1910'\n  AND c.nr_order = '78'\nGROUP BY m.movie_id;": [
        4857.47,
        3919.73,
        3917.29,
        3916.02,
        3914.19,
        3901.09,
        3794.29,
        13.54,
        8.31,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '84') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '375'\n  AND m.movie_id <= '517'\n  AND t.production_year = '1905'\n  AND c.nr_order = '84'\nGROUP BY m.movie_id;": [
        4914.35,
        3976.61,
        3974.17,
        3972.9,
        3971.07,
        3905.34,
        3887.93,
        13.78,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '344') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '335'\n  AND m.movie_id <= '397'\n  AND t.production_year = '1955'\n  AND c.nr_order = '344'\nGROUP BY m.movie_id;": [
        2959.55,
        2021.81,
        2019.37,
        2018.1,
        2016.27,
        2005.02,
        1906.66,
        8.96,
        8.4,
        98.35,
        11.18,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '154') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '333'\n  AND m.movie_id <= '403'\n  AND t.production_year = '2009'\n  AND c.nr_order = '154'\nGROUP BY m.movie_id;": [
        3536.0,
        2598.26,
        2595.82,
        2594.55,
        2592.72,
        2587.98,
        2105.94,
        9.44,
        8.39,
        37.07,
        4.67,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '155') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '85'\n  AND m.movie_id <= '332'\n  AND t.production_year = '1953'\n  AND c.nr_order = '155'\nGROUP BY m.movie_id;": [
        7600.98,
        6663.24,
        6660.8,
        6659.53,
        6657.7,
        6644.71,
        6431.98,
        20.07,
        8.2,
        106.35,
        12.93,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '240') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '231'\n  AND m.movie_id <= '343'\n  AND t.production_year = '1957'\n  AND c.nr_order = '240'\nGROUP BY m.movie_id;": [
        4206.69,
        3268.95,
        3266.52,
        3265.25,
        3263.41,
        3252.79,
        3157.63,
        11.97,
        8.34,
        95.15,
        10.56,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '333') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '170'\n  AND m.movie_id <= '282'\n  AND t.production_year = '2000'\n  AND c.nr_order = '333'\nGROUP BY m.movie_id;": [
        4453.32,
        3515.58,
        3513.14,
        3511.87,
        3510.04,
        3504.71,
        3157.63,
        11.97,
        8.34,
        43.37,
        5.27,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '526') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '154'\n  AND m.movie_id <= '278'\n  AND t.production_year = '1926'\n  AND c.nr_order = '526'\nGROUP BY m.movie_id;": [
        4476.97,
        3539.23,
        3536.79,
        3535.52,
        3533.69,
        3467.96,
        3450.55,
        12.69,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '89') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '267'\n  AND m.movie_id <= '509'\n  AND t.production_year = '1944'\n  AND c.nr_order = '89'\nGROUP BY m.movie_id;": [
        7368.21,
        6430.48,
        6428.04,
        6426.77,
        6424.93,
        6326.34,
        6308.93,
        19.77,
        8.2,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '8000') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '103'\n  AND m.movie_id <= '236'\n  AND t.production_year = '1973'\n  AND c.nr_order = '8000'\nGROUP BY m.movie_id;": [
        4829.42,
        3891.69,
        3889.25,
        3887.98,
        3886.14,
        3878.32,
        3671.24,
        13.24,
        8.31,
        69.01,
        7.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '428') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '106'\n  AND m.movie_id <= '216'\n  AND t.production_year = '1924'\n  AND c.nr_order = '428'\nGROUP BY m.movie_id;": [
        4131.59,
        3193.85,
        3191.41,
        3190.14,
        3188.31,
        3122.58,
        3106.81,
        11.86,
        8.34,
        15.71,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '393') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '107'\n  AND m.movie_id <= '216'\n  AND t.production_year = '1926'\n  AND c.nr_order = '393'\nGROUP BY m.movie_id;": [
        4074.95,
        3137.22,
        3134.78,
        3133.51,
        3100.65,
        3098.81,
        3081.4,
        11.79,
        8.34,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '711') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '137'\n  AND m.movie_id <= '495'\n  AND t.production_year = '1957'\n  AND c.nr_order = '711'\nGROUP BY m.movie_id;": [
        10300.34,
        9362.6,
        9360.16,
        9358.89,
        9357.06,
        9346.44,
        9060.96,
        30.75,
        8.09,
        95.15,
        10.56,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1776') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '292'\n  AND m.movie_id <= '409'\n  AND t.production_year = '1911'\n  AND c.nr_order = '1776'\nGROUP BY m.movie_id;": [
        4338.77,
        3401.04,
        3398.6,
        3397.33,
        3395.49,
        3382.61,
        3276.68,
        12.28,
        8.33,
        105.92,
        12.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1303') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '295'\n  AND m.movie_id <= '411'\n  AND t.production_year = '1908'\n  AND c.nr_order = '1303'\nGROUP BY m.movie_id;": [
        4277.69,
        3339.95,
        3337.51,
        3336.24,
        3334.41,
        3268.68,
        3251.27,
        12.21,
        8.33,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '266') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '135'\n  AND m.movie_id <= '363'\n  AND t.production_year = '2015'\n  AND c.nr_order = '266'\nGROUP BY m.movie_id;": [
        7032.47,
        6094.74,
        6092.3,
        6091.03,
        6089.19,
        5990.6,
        5973.19,
        18.93,
        8.21,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '807') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '273'\n  AND m.movie_id <= '408'\n  AND t.production_year = '1896'\n  AND c.nr_order = '807'\nGROUP BY m.movie_id;": [
        4748.48,
        3810.74,
        3808.3,
        3807.03,
        3805.2,
        3739.47,
        3722.06,
        13.36,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '803') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '272'\n  AND m.movie_id <= '408'\n  AND t.production_year = '1895'\n  AND c.nr_order = '803'\nGROUP BY m.movie_id;": [
        4769.89,
        3832.15,
        3829.71,
        3828.44,
        3826.61,
        3760.88,
        3743.47,
        13.42,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '11000') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '9'\n  AND m.movie_id <= '154'\n  AND t.production_year = '1898'\n  AND c.nr_order = '11000'\nGROUP BY m.movie_id;": [
        4990.58,
        4052.84,
        4050.4,
        4049.13,
        4047.3,
        3981.57,
        3964.16,
        13.96,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '800') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '54'\n  AND m.movie_id <= '488'\n  AND t.production_year = '1977'\n  AND c.nr_order = '800'\nGROUP BY m.movie_id;": [
        12291.3,
        11353.56,
        11351.12,
        11349.85,
        11348.02,
        11339.76,
        10824.12,
        35.31,
        8.03,
        73.65,
        8.19,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1080') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '61'\n  AND m.movie_id <= '260'\n  AND t.production_year = '1975'\n  AND c.nr_order = '1080'\nGROUP BY m.movie_id;": [
        6448.82,
        5511.09,
        5508.65,
        5507.38,
        5505.54,
        5497.29,
        5276.3,
        17.19,
        8.24,
        73.65,
        8.19,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1030') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '379'\n  AND m.movie_id <= '503'\n  AND t.production_year = '1975'\n  AND c.nr_order = '1030'\nGROUP BY m.movie_id;": [
        4549.41,
        3611.68,
        3609.24,
        3607.97,
        3606.13,
        3597.87,
        3450.55,
        12.69,
        8.32,
        73.65,
        8.19,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2198') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '261'\n  AND m.movie_id <= '399'\n  AND t.production_year = '1892'\n  AND c.nr_order = '2198'\nGROUP BY m.movie_id;": [
        4820.71,
        3882.97,
        3880.53,
        3879.26,
        3877.43,
        3811.7,
        3794.29,
        13.54,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '527') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '157'\n  AND m.movie_id <= '275'\n  AND t.production_year = '1924'\n  AND c.nr_order = '527'\nGROUP BY m.movie_id;": [
        4359.73,
        3421.99,
        3419.56,
        3418.29,
        3416.45,
        3317.86,
        3302.09,
        12.34,
        8.33,
        15.71,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '527') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '158'\n  AND m.movie_id <= '278'\n  AND t.production_year = '1928'\n  AND c.nr_order = '527'\nGROUP BY m.movie_id;": [
        4406.55,
        3468.81,
        3466.38,
        3465.11,
        3463.27,
        3364.68,
        3348.91,
        12.46,
        8.32,
        15.71,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '545') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '162'\n  AND m.movie_id <= '278'\n  AND t.production_year = '1926'\n  AND c.nr_order = '545'\nGROUP BY m.movie_id;": [
        4277.69,
        3339.95,
        3337.51,
        3336.24,
        3334.41,
        3268.68,
        3251.27,
        12.21,
        8.33,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '527') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '160'\n  AND m.movie_id <= '270'\n  AND t.production_year = '1922'\n  AND c.nr_order = '527'\nGROUP BY m.movie_id;": [
        4100.36,
        3162.63,
        3160.19,
        3158.92,
        3126.06,
        3124.22,
        3106.81,
        11.86,
        8.34,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '428') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '376'\n  AND m.movie_id <= '499'\n  AND t.production_year = '1957'\n  AND c.nr_order = '428'\nGROUP BY m.movie_id;": [
        4474.2,
        3536.46,
        3534.03,
        3532.76,
        3530.92,
        3520.3,
        3425.14,
        12.63,
        8.32,
        95.15,
        10.56,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '431') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '372'\n  AND m.movie_id <= '491'\n  AND t.production_year = '1954'\n  AND c.nr_order = '431'\nGROUP BY m.movie_id;": [
        4373.8,
        3436.06,
        3433.63,
        3432.36,
        3430.52,
        3419.7,
        3323.5,
        12.4,
        8.32,
        96.19,
        10.75,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '469') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '313'\n  AND m.movie_id <= '439'\n  AND t.production_year = '1969'\n  AND c.nr_order = '469'\nGROUP BY m.movie_id;": [
        4647.72,
        3709.98,
        3707.54,
        3706.27,
        3704.44,
        3696.85,
        3497.37,
        12.82,
        8.32,
        66.48,
        7.52,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2303') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '276'\n  AND m.movie_id <= '402'\n  AND t.production_year = '1900'\n  AND c.nr_order = '2303'\nGROUP BY m.movie_id;": [
        4523.79,
        3586.05,
        3583.61,
        3582.34,
        3580.51,
        3514.78,
        3497.37,
        12.82,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2402') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '272'\n  AND m.movie_id <= '400'\n  AND t.production_year = '1900'\n  AND c.nr_order = '2402'\nGROUP BY m.movie_id;": [
        4574.61,
        3636.87,
        3634.43,
        3633.16,
        3631.33,
        3565.6,
        3548.19,
        12.94,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '95') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '388'\n  AND m.movie_id <= '451'\n  AND t.production_year = '1919'\n  AND c.nr_order = '95'\nGROUP BY m.movie_id;": [
        2955.25,
        2017.51,
        2015.07,
        2013.8,
        2011.97,
        1946.24,
        1932.07,
        9.02,
        8.4,
        14.11,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1920') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '297'\n  AND m.movie_id <= '407'\n  AND t.production_year = '1910'\n  AND c.nr_order = '1920'\nGROUP BY m.movie_id;": [
        4169.99,
        3232.25,
        3229.81,
        3228.54,
        3226.71,
        3213.61,
        3106.81,
        11.86,
        8.34,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '88') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '369'\n  AND m.movie_id <= '511'\n  AND t.production_year = '1909'\n  AND c.nr_order = '88'\nGROUP BY m.movie_id;": [
        4945.46,
        4007.72,
        4005.28,
        4004.01,
        4002.18,
        3903.59,
        3887.93,
        13.78,
        8.3,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '65') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '315'\n  AND m.movie_id <= '498'\n  AND t.production_year = '2004'\n  AND c.nr_order = '65'\nGROUP BY m.movie_id;": [
        6661.21,
        5723.47,
        5721.03,
        5719.76,
        5717.93,
        5712.99,
        4889.74,
        16.23,
        8.26,
        39.19,
        4.87,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '89') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '375'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1911'\n  AND c.nr_order = '89'\nGROUP BY m.movie_id;": [
        4907.2,
        3969.47,
        3967.03,
        3965.76,
        3963.92,
        3951.04,
        3845.11,
        13.65,
        8.31,
        105.92,
        12.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '90') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '369'\n  AND m.movie_id <= '514'\n  AND t.production_year = '1905'\n  AND c.nr_order = '90'\nGROUP BY m.movie_id;": [
        4990.58,
        4052.84,
        4050.4,
        4049.13,
        4047.3,
        3981.57,
        3964.16,
        13.96,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2198') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '260'\n  AND m.movie_id <= '404'\n  AND t.production_year = '1894'\n  AND c.nr_order = '2198'\nGROUP BY m.movie_id;": [
        4965.17,
        4027.43,
        4024.99,
        4023.72,
        4021.89,
        3956.16,
        3938.75,
        13.9,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '4102') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '133'\n  AND m.movie_id <= '306'\n  AND t.production_year = '1950'\n  AND c.nr_order = '4102'\nGROUP BY m.movie_id;": [
        5710.82,
        4773.08,
        4770.64,
        4769.37,
        4767.54,
        4754.44,
        4647.64,
        15.64,
        8.27,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '4200') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '133'\n  AND m.movie_id <= '306'\n  AND t.production_year = '1951'\n  AND c.nr_order = '4200'\nGROUP BY m.movie_id;": [
        5710.27,
        4772.54,
        4770.1,
        4768.83,
        4766.99,
        4754.0,
        4647.64,
        15.64,
        8.27,
        106.35,
        12.93,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1400') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '294'\n  AND m.movie_id <= '398'\n  AND t.production_year = '1909'\n  AND c.nr_order = '1400'\nGROUP BY m.movie_id;": [
        3983.01,
        3045.28,
        3042.84,
        3041.57,
        3039.73,
        2974.01,
        2958.35,
        11.5,
        8.35,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '826') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '384'\n  AND m.movie_id <= '457'\n  AND t.production_year = '1929'\n  AND c.nr_order = '826'\nGROUP BY m.movie_id;": [
        3175.72,
        2237.99,
        2235.55,
        2234.28,
        2201.42,
        2199.58,
        2182.17,
        9.62,
        8.39,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1305') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '296'\n  AND m.movie_id <= '410'\n  AND t.production_year = '1909'\n  AND c.nr_order = '1305'\nGROUP BY m.movie_id;": [
        4225.11,
        3287.38,
        3284.94,
        3283.67,
        3281.83,
        3216.11,
        3200.45,
        12.1,
        8.32,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2153') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '275'\n  AND m.movie_id <= '406'\n  AND t.production_year = '1896'\n  AND c.nr_order = '2153'\nGROUP BY m.movie_id;": [
        4646.84,
        3709.1,
        3706.66,
        3705.39,
        3703.56,
        3637.83,
        3620.42,
        13.12,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '78') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '88'\n  AND m.movie_id <= '226'\n  AND t.production_year = '1936'\n  AND c.nr_order = '78'\nGROUP BY m.movie_id;": [
        4868.23,
        3930.49,
        3928.05,
        3926.78,
        3924.95,
        3910.12,
        3794.29,
        13.54,
        8.31,
        115.82,
        14.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1126') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '302'\n  AND m.movie_id <= '433'\n  AND t.production_year = '1992'\n  AND c.nr_order = '1126'\nGROUP BY m.movie_id;": [
        4791.54,
        3853.81,
        3851.37,
        3850.1,
        3848.26,
        3841.74,
        3620.42,
        13.12,
        8.31,
        55.32,
        6.46,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '463') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '312'\n  AND m.movie_id <= '441'\n  AND t.production_year = '1969'\n  AND c.nr_order = '463'\nGROUP BY m.movie_id;": [
        4723.95,
        3786.21,
        3783.77,
        3782.5,
        3780.67,
        3773.08,
        3573.6,
        13.0,
        8.32,
        66.48,
        7.52,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '545') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '162'\n  AND m.movie_id <= '274'\n  AND t.production_year = '1924'\n  AND c.nr_order = '545'\nGROUP BY m.movie_id;": [
        4182.41,
        3244.67,
        3242.23,
        3240.96,
        3239.13,
        3173.4,
        3157.63,
        11.97,
        8.34,
        15.71,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '412') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '110'\n  AND m.movie_id <= '217'\n  AND t.production_year = '1922'\n  AND c.nr_order = '412'\nGROUP BY m.movie_id;": [
        4024.13,
        3086.4,
        3083.96,
        3082.69,
        3049.83,
        3047.99,
        3030.58,
        11.68,
        8.34,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2302') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '260'\n  AND m.movie_id <= '402'\n  AND t.production_year = '1894'\n  AND c.nr_order = '2302'\nGROUP BY m.movie_id;": [
        4914.35,
        3976.61,
        3974.17,
        3972.9,
        3971.07,
        3905.34,
        3887.93,
        13.78,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '88') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '367'\n  AND m.movie_id <= '506'\n  AND t.production_year = '1904'\n  AND c.nr_order = '88'\nGROUP BY m.movie_id;": [
        4846.12,
        3908.38,
        3905.94,
        3904.67,
        3902.84,
        3837.11,
        3819.7,
        13.6,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '7100') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '99'\n  AND m.movie_id <= '233'\n  AND t.production_year = '1972'\n  AND c.nr_order = '7100'\nGROUP BY m.movie_id;": [
        4793.97,
        3856.23,
        3853.79,
        3852.52,
        3850.69,
        3842.5,
        3696.65,
        13.29,
        8.31,
        72.91,
        8.13,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '431') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '105'\n  AND m.movie_id <= '218'\n  AND t.production_year = '1929'\n  AND c.nr_order = '431'\nGROUP BY m.movie_id;": [
        4205.46,
        3267.72,
        3265.28,
        3264.01,
        3262.18,
        3196.45,
        3179.04,
        12.04,
        8.33,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1703') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '141'\n  AND m.movie_id <= '275'\n  AND t.production_year = '1909'\n  AND c.nr_order = '1703'\nGROUP BY m.movie_id;": [
        4754.18,
        3816.44,
        3814.0,
        3812.73,
        3810.9,
        3712.31,
        3696.65,
        13.29,
        8.31,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1203') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '289'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1911'\n  AND c.nr_order = '1203'\nGROUP BY m.movie_id;": [
        4219.72,
        3281.99,
        3279.55,
        3278.28,
        3276.44,
        3263.56,
        3157.63,
        11.97,
        8.34,
        105.92,
        12.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1048') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '199'\n  AND m.movie_id <= '323'\n  AND t.production_year = '1941'\n  AND c.nr_order = '1048'\nGROUP BY m.movie_id;": [
        4476.97,
        3539.23,
        3536.79,
        3535.52,
        3533.69,
        3467.96,
        3450.55,
        12.69,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1400') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '287'\n  AND m.movie_id <= '409'\n  AND t.production_year = '1908'\n  AND c.nr_order = '1400'\nGROUP BY m.movie_id;": [
        4426.15,
        3488.41,
        3485.97,
        3484.7,
        3482.87,
        3417.14,
        3399.73,
        12.58,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1001') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '345'\n  AND m.movie_id <= '476'\n  AND t.production_year = '1955'\n  AND c.nr_order = '1001'\nGROUP BY m.movie_id;": [
        4668.62,
        3730.89,
        3728.45,
        3727.18,
        3725.34,
        3718.78,
        3620.42,
        13.12,
        8.31,
        98.35,
        6.5,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1056') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '200'\n  AND m.movie_id <= '340'\n  AND t.production_year = '1968'\n  AND c.nr_order = '1056'\nGROUP BY m.movie_id;": [
        4941.43,
        4003.69,
        4001.25,
        3999.98,
        3998.15,
        3990.01,
        3845.11,
        13.65,
        8.31,
        72.44,
        8.08,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '88') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '369'\n  AND m.movie_id <= '513'\n  AND t.production_year = '1906'\n  AND c.nr_order = '88'\nGROUP BY m.movie_id;": [
        4965.17,
        4027.43,
        4024.99,
        4023.72,
        4021.89,
        3956.16,
        3938.75,
        13.9,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '970713') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '159'\n  AND m.movie_id <= '420'\n  AND t.production_year = '1928'\n  AND c.nr_order = '970713'\nGROUP BY m.movie_id;": [
        7847.45,
        6909.72,
        6907.28,
        6906.01,
        6904.17,
        6888.41,
        6767.72,
        24.92,
        8.18,
        120.67,
        15.71,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '210') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '25'\n  AND m.movie_id <= '113'\n  AND t.production_year = '1933'\n  AND c.nr_order = '210'\nGROUP BY m.movie_id;": [
        3544.87,
        2607.14,
        2604.7,
        2603.43,
        2570.57,
        2568.73,
        2551.32,
        10.52,
        8.36,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '481') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '238'\n  AND m.movie_id <= '353'\n  AND t.production_year = '1953'\n  AND c.nr_order = '481'\nGROUP BY m.movie_id;": [
        4288.49,
        3350.76,
        3348.32,
        3347.05,
        3345.21,
        3332.22,
        3225.86,
        12.15,
        8.33,
        106.35,
        12.93,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1202') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '296'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1917'\n  AND c.nr_order = '1202'\nGROUP BY m.movie_id;": [
        4039.71,
        3101.98,
        3099.54,
        3098.27,
        3096.44,
        2997.84,
        2983.76,
        11.56,
        8.35,
        14.02,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '230') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '227'\n  AND m.movie_id <= '336'\n  AND t.production_year = '1961'\n  AND c.nr_order = '230'\nGROUP BY m.movie_id;": [
        4198.09,
        3260.35,
        3257.91,
        3256.64,
        3254.81,
        3245.76,
        3081.4,
        11.79,
        8.34,
        82.17,
        8.99,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '248') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '163'\n  AND m.movie_id <= '297'\n  AND t.production_year = '1917'\n  AND c.nr_order = '248'\nGROUP BY m.movie_id;": [
        4765.86,
        3828.12,
        3825.69,
        3824.42,
        3822.58,
        3808.49,
        3696.65,
        13.29,
        8.31,
        111.83,
        14.02,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '77') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '367'\n  AND m.movie_id <= '510'\n  AND t.production_year = '1900'\n  AND c.nr_order = '77'\nGROUP BY m.movie_id;": [
        4939.76,
        4002.02,
        3999.58,
        3998.31,
        3996.48,
        3930.75,
        3913.34,
        13.83,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1080') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '94'\n  AND m.movie_id <= '364'\n  AND t.production_year = '1991'\n  AND c.nr_order = '1080'\nGROUP BY m.movie_id;": [
        8382.97,
        7445.24,
        7442.8,
        7441.53,
        7439.69,
        7433.1,
        6984.41,
        25.45,
        8.18,
        56.07,
        6.53,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1400') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '390'\n  AND m.movie_id <= '442'\n  AND t.production_year = '1944'\n  AND c.nr_order = '1400'\nGROUP BY m.movie_id;": [
        2650.11,
        1712.38,
        1709.94,
        1708.67,
        1675.81,
        1673.97,
        1656.56,
        8.36,
        8.41,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '88') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '367'\n  AND m.movie_id <= '505'\n  AND t.production_year = '1904'\n  AND c.nr_order = '88'\nGROUP BY m.movie_id;": [
        4820.71,
        3882.97,
        3880.53,
        3879.26,
        3877.43,
        3811.7,
        3794.29,
        13.54,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '88') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '367'\n  AND m.movie_id <= '505'\n  AND t.production_year = '1905'\n  AND c.nr_order = '88'\nGROUP BY m.movie_id;": [
        4820.71,
        3882.97,
        3880.53,
        3879.26,
        3877.43,
        3811.7,
        3794.29,
        13.54,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1072') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '206'\n  AND m.movie_id <= '343'\n  AND t.production_year = '1967'\n  AND c.nr_order = '1072'\nGROUP BY m.movie_id;": [
        4907.32,
        3969.59,
        3967.15,
        3965.88,
        3964.04,
        3956.82,
        3768.88,
        13.47,
        8.31,
        62.64,
        7.16,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '418') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '108'\n  AND m.movie_id <= '215'\n  AND t.production_year = '1923'\n  AND c.nr_order = '418'\nGROUP BY m.movie_id;": [
        4024.13,
        3086.4,
        3083.96,
        3082.69,
        3049.83,
        3047.99,
        3030.58,
        11.68,
        8.34,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '390') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '107'\n  AND m.movie_id <= '214'\n  AND t.production_year = '1925'\n  AND c.nr_order = '390'\nGROUP BY m.movie_id;": [
        4024.13,
        3086.4,
        3083.96,
        3082.69,
        3049.83,
        3047.99,
        3030.58,
        11.68,
        8.34,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2153') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '260'\n  AND m.movie_id <= '399'\n  AND t.production_year = '1890'\n  AND c.nr_order = '2153'\nGROUP BY m.movie_id;": [
        4846.12,
        3908.38,
        3905.94,
        3904.67,
        3902.84,
        3837.11,
        3819.7,
        13.6,
        8.31,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '338') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '173'\n  AND m.movie_id <= '274'\n  AND t.production_year = '1999'\n  AND c.nr_order = '338'\nGROUP BY m.movie_id;": [
        4141.59,
        3203.85,
        3201.41,
        3200.14,
        3198.31,
        3192.89,
        2882.12,
        11.31,
        8.35,
        44.38,
        5.36,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1188') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '3'\n  AND m.movie_id <= '307'\n  AND t.production_year = '1967'\n  AND c.nr_order = '1188'\nGROUP BY m.movie_id;": [
        9185.85,
        8248.12,
        8245.68,
        8244.41,
        8242.57,
        8235.35,
        7796.82,
        27.51,
        8.14,
        62.64,
        7.16,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '224') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '231'\n  AND m.movie_id <= '342'\n  AND t.production_year = '1963'\n  AND c.nr_order = '224'\nGROUP BY m.movie_id;": [
        4243.76,
        3306.03,
        3303.59,
        3302.32,
        3300.48,
        3291.66,
        3132.22,
        11.92,
        8.34,
        79.71,
        8.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '222') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '231'\n  AND m.movie_id <= '342'\n  AND t.production_year = '1963'\n  AND c.nr_order = '222'\nGROUP BY m.movie_id;": [
        4243.76,
        3306.03,
        3303.59,
        3302.32,
        3300.48,
        3291.66,
        3132.22,
        11.92,
        8.34,
        79.71,
        8.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '89') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '372'\n  AND m.movie_id <= '514'\n  AND t.production_year = '1899'\n  AND c.nr_order = '89'\nGROUP BY m.movie_id;": [
        4914.35,
        3976.61,
        3974.17,
        3972.9,
        3971.07,
        3905.34,
        3887.93,
        13.78,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '132') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '72'\n  AND m.movie_id <= '248'\n  AND t.production_year = '1901'\n  AND c.nr_order = '132'\nGROUP BY m.movie_id;": [
        5746.29,
        4808.55,
        4806.11,
        4804.84,
        4803.01,
        4737.28,
        4719.87,
        15.82,
        8.27,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2402') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '276'\n  AND m.movie_id <= '403'\n  AND t.production_year = '1888'\n  AND c.nr_order = '2402'\nGROUP BY m.movie_id;": [
        4549.2,
        3611.46,
        3609.02,
        3607.75,
        3605.92,
        3540.19,
        3522.78,
        12.87,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1075') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '36'\n  AND m.movie_id <= '176'\n  AND t.production_year = '1971'\n  AND c.nr_order = '1075'\nGROUP BY m.movie_id;": [
        4942.93,
        4005.2,
        4002.76,
        4001.49,
        3999.65,
        3991.44,
        3845.11,
        13.65,
        8.31,
        73.16,
        8.15,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '529') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '158'\n  AND m.movie_id <= '273'\n  AND t.production_year = '1927'\n  AND c.nr_order = '529'\nGROUP BY m.movie_id;": [
        4252.28,
        3314.54,
        3312.1,
        3310.83,
        3309.0,
        3243.27,
        3225.86,
        12.15,
        8.33,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '249') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '94'\n  AND m.movie_id <= '329'\n  AND t.production_year = '2014'\n  AND c.nr_order = '249'\nGROUP BY m.movie_id;": [
        7202.34,
        6264.61,
        6262.17,
        6260.9,
        6259.06,
        6160.47,
        6143.06,
        19.36,
        8.21,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '248') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '162'\n  AND m.movie_id <= '297'\n  AND t.production_year = '1914'\n  AND c.nr_order = '248'\nGROUP BY m.movie_id;": [
        4773.64,
        3835.9,
        3833.46,
        3832.19,
        3830.36,
        3819.33,
        3722.06,
        13.36,
        8.32,
        97.26,
        10.96,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1010') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '168'\n  AND m.movie_id <= '475'\n  AND t.production_year = '1961'\n  AND c.nr_order = '1010'\nGROUP BY m.movie_id;": [
        9150.1,
        8212.37,
        8209.93,
        8208.66,
        8206.82,
        8197.77,
        7869.05,
        27.7,
        8.14,
        82.17,
        8.99,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '249') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '162'\n  AND m.movie_id <= '297'\n  AND t.production_year = '1913'\n  AND c.nr_order = '249'\nGROUP BY m.movie_id;": [
        4773.2,
        3835.47,
        3833.03,
        3831.76,
        3829.92,
        3818.97,
        3722.06,
        13.36,
        8.32,
        96.9,
        10.89,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '505') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '145'\n  AND m.movie_id <= '450'\n  AND t.production_year = '1973'\n  AND c.nr_order = '505'\nGROUP BY m.movie_id;": [
        9187.49,
        8249.76,
        8247.32,
        8246.05,
        8244.21,
        8236.39,
        7822.23,
        27.57,
        8.14,
        69.01,
        7.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1007') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '345'\n  AND m.movie_id <= '475'\n  AND t.production_year = '1951'\n  AND c.nr_order = '1007'\nGROUP BY m.movie_id;": [
        4661.64,
        3723.91,
        3721.47,
        3720.2,
        3718.36,
        3705.37,
        3599.01,
        13.06,
        8.32,
        106.35,
        12.93,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2153') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '260'\n  AND m.movie_id <= '404'\n  AND t.production_year = '1894'\n  AND c.nr_order = '2153'\nGROUP BY m.movie_id;": [
        4965.17,
        4027.43,
        4024.99,
        4023.72,
        4021.89,
        3956.16,
        3938.75,
        13.9,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2198') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '260'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1894'\n  AND c.nr_order = '2198'\nGROUP BY m.movie_id;": [
        4892.94,
        3955.2,
        3952.76,
        3951.49,
        3949.66,
        3883.93,
        3866.52,
        13.72,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '8001') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '103'\n  AND m.movie_id <= '238'\n  AND t.production_year = '1976'\n  AND c.nr_order = '8001'\nGROUP BY m.movie_id;": [
        4820.4,
        3882.67,
        3880.23,
        3878.96,
        3877.12,
        3868.89,
        3722.06,
        13.36,
        8.32,
        73.4,
        8.17,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '10001') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '78'\n  AND m.movie_id <= '202'\n  AND t.production_year = '1992'\n  AND c.nr_order = '10001'\nGROUP BY m.movie_id;": [
        4621.67,
        3683.94,
        3681.5,
        3680.23,
        3678.39,
        3671.87,
        3450.55,
        12.69,
        8.32,
        55.32,
        6.46,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '7002') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '102'\n  AND m.movie_id <= '231'\n  AND t.production_year = '1977'\n  AND c.nr_order = '7002'\nGROUP BY m.movie_id;": [
        4672.46,
        3734.73,
        3732.29,
        3731.02,
        3729.18,
        3720.92,
        3573.6,
        13.0,
        8.32,
        73.65,
        8.19,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '470') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '236'\n  AND m.movie_id <= '351'\n  AND t.production_year = '1954'\n  AND c.nr_order = '470'\nGROUP BY m.movie_id;": [
        4276.16,
        3338.42,
        3335.99,
        3334.72,
        3332.88,
        3322.06,
        3225.86,
        12.15,
        8.33,
        96.19,
        10.75,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '81') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '367'\n  AND m.movie_id <= '512'\n  AND t.production_year = '1905'\n  AND c.nr_order = '81'\nGROUP BY m.movie_id;": [
        4990.58,
        4052.84,
        4050.4,
        4049.13,
        4047.3,
        3981.57,
        3964.16,
        13.96,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '89') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '368'\n  AND m.movie_id <= '513'\n  AND t.production_year = '1903'\n  AND c.nr_order = '89'\nGROUP BY m.movie_id;": [
        4990.58,
        4052.84,
        4050.4,
        4049.13,
        4047.3,
        3981.57,
        3964.16,
        13.96,
        8.3,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1279') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '298'\n  AND m.movie_id <= '406'\n  AND t.production_year = '1909'\n  AND c.nr_order = '1279'\nGROUP BY m.movie_id;": [
        4080.65,
        3142.92,
        3140.48,
        3139.21,
        3137.37,
        3071.65,
        3055.99,
        11.74,
        8.34,
        15.59,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1306') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '292'\n  AND m.movie_id <= '404'\n  AND t.production_year = '1906'\n  AND c.nr_order = '1306'\nGROUP BY m.movie_id;": [
        4184.05,
        3246.31,
        3243.87,
        3242.6,
        3240.77,
        3175.04,
        3157.63,
        11.97,
        8.34,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2402') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '277'\n  AND m.movie_id <= '403'\n  AND t.production_year = '1899'\n  AND c.nr_order = '2402'\nGROUP BY m.movie_id;": [
        4523.79,
        3586.05,
        3583.61,
        3582.34,
        3580.51,
        3514.78,
        3497.37,
        12.82,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '91') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '370'\n  AND m.movie_id <= '517'\n  AND t.production_year = '1901'\n  AND c.nr_order = '91'\nGROUP BY m.movie_id;": [
        5037.4,
        4099.66,
        4097.22,
        4095.95,
        4094.12,
        4028.39,
        4010.98,
        14.08,
        8.29,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '527') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '159'\n  AND m.movie_id <= '270'\n  AND t.production_year = '1919'\n  AND c.nr_order = '527'\nGROUP BY m.movie_id;": [
        4188.26,
        3250.53,
        3248.09,
        3246.82,
        3244.98,
        3146.39,
        3132.22,
        11.92,
        8.34,
        14.11,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '328') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '173'\n  AND m.movie_id <= '282'\n  AND t.production_year = '2000'\n  AND c.nr_order = '328'\nGROUP BY m.movie_id;": [
        4377.09,
        3439.35,
        3436.91,
        3435.64,
        3433.81,
        3428.48,
        3081.4,
        11.79,
        8.34,
        43.37,
        5.27,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '355') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '10'\n  AND m.movie_id <= '130'\n  AND t.production_year = '1933'\n  AND c.nr_order = '355'\nGROUP BY m.movie_id;": [
        4375.33,
        3437.59,
        3435.15,
        3433.88,
        3432.05,
        3366.32,
        3348.91,
        12.46,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '318') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '170'\n  AND m.movie_id <= '275'\n  AND t.production_year = '1999'\n  AND c.nr_order = '318'\nGROUP BY m.movie_id;": [
        4243.23,
        3305.49,
        3303.05,
        3301.78,
        3299.95,
        3294.53,
        2983.76,
        11.56,
        8.35,
        44.38,
        5.36,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '240') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '161'\n  AND m.movie_id <= '297'\n  AND t.production_year = '1917'\n  AND c.nr_order = '240'\nGROUP BY m.movie_id;": [
        4812.68,
        3874.94,
        3872.51,
        3871.24,
        3869.4,
        3855.31,
        3743.47,
        13.42,
        8.31,
        111.83,
        14.02,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '248') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '159'\n  AND m.movie_id <= '296'\n  AND t.production_year = '1914'\n  AND c.nr_order = '248'\nGROUP BY m.movie_id;": [
        4820.46,
        3882.72,
        3880.28,
        3879.01,
        3877.18,
        3866.15,
        3768.88,
        13.47,
        8.31,
        97.26,
        10.96,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '249') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '160'\n  AND m.movie_id <= '296'\n  AND t.production_year = '1914'\n  AND c.nr_order = '249'\nGROUP BY m.movie_id;": [
        4795.05,
        3857.31,
        3854.87,
        3853.6,
        3851.77,
        3840.74,
        3743.47,
        13.42,
        8.31,
        97.26,
        10.96,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '822') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '141'\n  AND m.movie_id <= '309'\n  AND t.production_year = '1990'\n  AND c.nr_order = '822'\nGROUP BY m.movie_id;": [
        5762.09,
        4824.35,
        4821.91,
        4820.64,
        4818.81,
        4812.08,
        4524.59,
        15.33,
        8.27,
        57.49,
        6.67,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '248') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '163'\n  AND m.movie_id <= '292'\n  AND t.production_year = '1912'\n  AND c.nr_order = '248'\nGROUP BY m.movie_id;": [
        4619.14,
        3681.41,
        3678.97,
        3677.7,
        3675.86,
        3665.76,
        3573.6,
        13.0,
        8.32,
        92.15,
        10.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ]
}