{
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '224'\n  AND cc.id <= '403'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '224'\n       AND cc2.id <= '403')\nGROUP BY cc.status_id;": [
        166.21,
        8.41,
        7.96,
        157.69,
        13.29,
        2.96
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '259'\n  AND cc.id <= '493'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '259'\n       AND cc2.id <= '493')\nGROUP BY cc.status_id;": [
        83.4,
        9.63,
        9.04,
        73.72,
        15.77,
        4.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '157'\n  AND cc.id <= '186'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '157'\n       AND cc2.id <= '186')\nGROUP BY cc.status_id;": [
        49.74,
        5.08,
        5.0,
        44.62,
        9.22,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '35'\n  AND cc.id <= '420'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '35'\n       AND cc2.id <= '420')\nGROUP BY cc.status_id;": [
        127.64,
        16.96,
        16.0,
        110.62,
        24.84,
        3.68
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '144'\n  AND cc.id <= '361'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '144'\n       AND cc2.id <= '361')\nGROUP BY cc.status_id;": [
        189.32,
        9.25,
        8.7,
        179.96,
        15.31,
        2.79
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '246'\n  AND cc.id <= '398'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '246'\n       AND cc2.id <= '398')\nGROUP BY cc.status_id;": [
        60.21,
        7.81,
        7.42,
        52.37,
        12.54,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '150'\n  AND cc.id <= '161'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '150'\n       AND cc2.id <= '161')\nGROUP BY cc.status_id;": [
        26.74,
        4.7,
        4.66,
        22.02,
        8.75,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '15'\n  AND cc.id <= '242'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '15'\n       AND cc2.id <= '242')\nGROUP BY cc.status_id;": [
        83.05,
        9.47,
        8.9,
        73.53,
        15.58,
        4.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '137'\n  AND cc.id <= '210'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '137'\n       AND cc2.id <= '210')\nGROUP BY cc.status_id;": [
        34.22,
        6.08,
        5.88,
        28.13,
        10.43,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '90'\n  AND cc.id <= '100'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '90'\n       AND cc2.id <= '100')\nGROUP BY cc.status_id;": [
        17.84,
        4.68,
        4.64,
        13.15,
        8.72,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '116'\n  AND cc.id <= '209'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '116'\n       AND cc2.id <= '209')\nGROUP BY cc.status_id;": [
        108.14,
        6.5,
        6.26,
        101.58,
        10.95,
        3.58
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '227'\n  AND cc.id <= '410'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '227'\n       AND cc2.id <= '410')\nGROUP BY cc.status_id;": [
        170.83,
        8.51,
        8.04,
        162.22,
        13.4,
        2.99
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '140'\n  AND cc.id <= '265'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '140'\n       AND cc2.id <= '265')\nGROUP BY cc.status_id;": [
        133.58,
        7.22,
        6.9,
        126.28,
        11.83,
        3.32
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '323'\n  AND cc.id <= '371'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '323'\n       AND cc2.id <= '371')\nGROUP BY cc.status_id;": [
        28.54,
        5.51,
        5.38,
        23.01,
        9.74,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '182'\n  AND cc.id <= '289'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '182'\n       AND cc2.id <= '289')\nGROUP BY cc.status_id;": [
        44.73,
        6.82,
        6.54,
        37.88,
        11.34,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '42'\n  AND cc.id <= '445'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '42'\n       AND cc2.id <= '445')\nGROUP BY cc.status_id;": [
        260.81,
        17.37,
        16.36,
        243.24,
        25.34,
        1.97
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '18'\n  AND cc.id <= '420'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '18'\n       AND cc2.id <= '420')\nGROUP BY cc.status_id;": [
        260.76,
        17.34,
        16.34,
        243.21,
        25.31,
        1.97
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '78'\n  AND cc.id <= '401'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '78'\n       AND cc2.id <= '401')\nGROUP BY cc.status_id;": [
        101.88,
        11.59,
        10.78,
        90.24,
        18.17,
        3.74
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '217'\n  AND cc.id <= '243'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '217'\n       AND cc2.id <= '243')\nGROUP BY cc.status_id;": [
        23.07,
        5.04,
        4.96,
        18.01,
        9.16,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '126'\n  AND cc.id <= '453'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '126'\n       AND cc2.id <= '453')\nGROUP BY cc.status_id;": [
        239.53,
        11.68,
        10.86,
        227.68,
        18.28,
        2.33
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '47'\n  AND cc.id <= '332'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '47'\n       AND cc2.id <= '332')\nGROUP BY cc.status_id;": [
        95.18,
        10.76,
        10.04,
        84.37,
        17.15,
        3.9
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '86'\n  AND cc.id <= '357'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '86'\n       AND cc2.id <= '357')\nGROUP BY cc.status_id;": [
        218.38,
        10.44,
        9.76,
        207.79,
        16.76,
        2.57
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '41'\n  AND cc.id <= '123'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '41'\n       AND cc2.id <= '123')\nGROUP BY cc.status_id;": [
        39.11,
        6.28,
        6.06,
        32.8,
        10.68,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '385'\n  AND cc.id <= '408'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '385'\n       AND cc2.id <= '408')\nGROUP BY cc.status_id;": [
        40.63,
        4.97,
        4.9,
        35.63,
        9.08,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '237'\n  AND cc.id <= '454'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '237'\n       AND cc2.id <= '454')\nGROUP BY cc.status_id;": [
        189.32,
        9.25,
        8.7,
        179.96,
        15.31,
        2.79
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '24'\n  AND cc.id <= '108'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '24'\n       AND cc2.id <= '108')\nGROUP BY cc.status_id;": [
        102.89,
        6.32,
        6.1,
        96.5,
        10.73,
        3.68
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '76'\n  AND cc.id <= '387'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '76'\n       AND cc2.id <= '387')\nGROUP BY cc.status_id;": [
        236.64,
        11.34,
        10.56,
        225.14,
        17.86,
        2.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '126'\n  AND cc.id <= '251'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '126'\n       AND cc2.id <= '251')\nGROUP BY cc.status_id;": [
        133.58,
        7.22,
        6.9,
        126.28,
        11.83,
        3.32
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '8'\n  AND cc.id <= '143'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '8'\n       AND cc2.id <= '143')\nGROUP BY cc.status_id;": [
        54.99,
        7.45,
        7.1,
        47.5,
        12.11,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '117'\n  AND cc.id <= '163'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '117'\n       AND cc2.id <= '163')\nGROUP BY cc.status_id;": [
        28.44,
        5.47,
        5.34,
        22.96,
        9.69,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '71'\n  AND cc.id <= '152'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '71'\n       AND cc2.id <= '152')\nGROUP BY cc.status_id;": [
        98.31,
        6.26,
        6.04,
        92.0,
        10.65,
        3.65
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '328'\n  AND cc.id <= '367'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '328'\n       AND cc2.id <= '367')\nGROUP BY cc.status_id;": [
        23.67,
        5.31,
        5.2,
        18.34,
        9.49,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '243'\n  AND cc.id <= '413'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '243'\n       AND cc2.id <= '413')\nGROUP BY cc.status_id;": [
        160.9,
        8.21,
        7.78,
        152.59,
        13.04,
        2.98
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '32'\n  AND cc.id <= '374'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '32'\n       AND cc2.id <= '374')\nGROUP BY cc.status_id;": [
        241.98,
        12.01,
        11.16,
        229.79,
        18.69,
        2.24
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '310'\n  AND cc.id <= '342'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '310'\n       AND cc2.id <= '342')\nGROUP BY cc.status_id;": [
        54.31,
        5.15,
        5.06,
        49.12,
        9.3,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '179'\n  AND cc.id <= '495'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '179'\n       AND cc2.id <= '495')\nGROUP BY cc.status_id;": [
        237.7,
        11.43,
        10.64,
        226.1,
        17.97,
        2.4
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '328'\n  AND cc.id <= '438'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '328'\n       AND cc2.id <= '438')\nGROUP BY cc.status_id;": [
        49.31,
        6.88,
        6.6,
        42.39,
        11.42,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '147'\n  AND cc.id <= '199'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '147'\n       AND cc2.id <= '199')\nGROUP BY cc.status_id;": [
        28.74,
        5.6,
        5.46,
        23.12,
        9.85,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '114'\n  AND cc.id <= '364'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '114'\n       AND cc2.id <= '364')\nGROUP BY cc.status_id;": [
        206.82,
        9.99,
        9.36,
        196.69,
        16.21,
        2.64
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '24'\n  AND cc.id <= '44'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '24'\n       AND cc2.id <= '44')\nGROUP BY cc.status_id;": [
        18.34,
        4.91,
        4.84,
        13.42,
        9.0,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '213'\n  AND cc.id <= '250'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '213'\n       AND cc2.id <= '250')\nGROUP BY cc.status_id;": [
        23.57,
        5.27,
        5.16,
        18.29,
        9.44,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '404'\n  AND cc.id <= '457'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '404'\n       AND cc2.id <= '457')\nGROUP BY cc.status_id;": [
        73.5,
        5.63,
        5.48,
        67.83,
        9.88,
        4.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '180'\n  AND cc.id <= '283'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '180'\n       AND cc2.id <= '283')\nGROUP BY cc.status_id;": [
        44.53,
        6.73,
        6.46,
        37.77,
        11.22,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '96'\n  AND cc.id <= '419'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '96'\n       AND cc2.id <= '419')\nGROUP BY cc.status_id;": [
        101.88,
        11.59,
        10.78,
        90.24,
        18.17,
        3.74
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '23'\n  AND cc.id <= '202'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '23'\n       AND cc2.id <= '202')\nGROUP BY cc.status_id;": [
        66.42,
        8.41,
        7.96,
        57.96,
        13.29,
        4.01
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '205'\n  AND cc.id <= '490'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '205'\n       AND cc2.id <= '490')\nGROUP BY cc.status_id;": [
        224.36,
        10.76,
        10.04,
        213.45,
        17.15,
        2.53
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '82'\n  AND cc.id <= '355'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '82'\n       AND cc2.id <= '355')\nGROUP BY cc.status_id;": [
        90.15,
        10.48,
        9.8,
        79.62,
        16.82,
        3.88
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '132'\n  AND cc.id <= '343'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '132'\n       AND cc2.id <= '343')\nGROUP BY cc.status_id;": [
        77.82,
        9.11,
        8.58,
        68.67,
        15.14,
        4.07
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '195'\n  AND cc.id <= '272'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '195'\n       AND cc2.id <= '272')\nGROUP BY cc.status_id;": [
        93.68,
        6.16,
        5.96,
        87.46,
        10.54,
        3.61
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '154'\n  AND cc.id <= '298'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '154'\n       AND cc2.id <= '298')\nGROUP BY cc.status_id;": [
        59.81,
        7.63,
        7.26,
        52.15,
        12.33,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '304'\n  AND cc.id <= '333'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '304'\n       AND cc2.id <= '333')\nGROUP BY cc.status_id;": [
        49.74,
        5.08,
        5.0,
        44.62,
        9.22,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '36'\n  AND cc.id <= '170'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '36'\n       AND cc2.id <= '170')\nGROUP BY cc.status_id;": [
        138.89,
        7.42,
        7.08,
        131.38,
        12.08,
        3.26
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '80'\n  AND cc.id <= '476'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '80'\n       AND cc2.id <= '476')\nGROUP BY cc.status_id;": [
        128.61,
        17.21,
        16.22,
        111.34,
        25.15,
        3.54
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '294'\n  AND cc.id <= '346'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '294'\n       AND cc2.id <= '346')\nGROUP BY cc.status_id;": [
        73.45,
        5.6,
        5.46,
        67.8,
        9.85,
        4.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '64'\n  AND cc.id <= '108'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '64'\n       AND cc2.id <= '108')\nGROUP BY cc.status_id;": [
        64.19,
        5.42,
        5.3,
        58.73,
        9.63,
        4.04
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '119'\n  AND cc.id <= '266'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '119'\n       AND cc2.id <= '266')\nGROUP BY cc.status_id;": [
        59.96,
        7.7,
        7.32,
        52.23,
        12.41,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '148'\n  AND cc.id <= '246'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '148'\n       AND cc2.id <= '246')\nGROUP BY cc.status_id;": [
        108.82,
        6.61,
        6.36,
        102.14,
        11.09,
        3.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '415'\n  AND cc.id <= '459'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '415'\n       AND cc2.id <= '459')\nGROUP BY cc.status_id;": [
        64.19,
        5.42,
        5.3,
        58.73,
        9.63,
        4.04
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '68'\n  AND cc.id <= '453'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '68'\n       AND cc2.id <= '453')\nGROUP BY cc.status_id;": [
        127.64,
        16.96,
        16.0,
        110.62,
        24.84,
        3.68
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '4'\n  AND cc.id <= '434'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '4'\n       AND cc2.id <= '434')\nGROUP BY cc.status_id;": [
        135.12,
        17.95,
        16.88,
        117.1,
        26.05,
        3.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '293'\n  AND cc.id <= '471'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '293'\n       AND cc2.id <= '471')\nGROUP BY cc.status_id;": [
        166.16,
        8.39,
        7.94,
        157.66,
        13.26,
        2.96
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '6'\n  AND cc.id <= '426'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '6'\n       AND cc2.id <= '426')\nGROUP BY cc.status_id;": [
        263.8,
        17.75,
        16.7,
        245.83,
        25.81,
        1.9
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '22'\n  AND cc.id <= '190'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '22'\n       AND cc2.id <= '190')\nGROUP BY cc.status_id;": [
        160.38,
        8.17,
        7.74,
        152.11,
        12.99,
        3.04
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '6'\n  AND cc.id <= '400'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '6'\n       AND cc2.id <= '400')\nGROUP BY cc.status_id;": [
        259.51,
        17.16,
        16.18,
        242.14,
        25.09,
        2.0
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '350'\n  AND cc.id <= '499'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '350'\n       AND cc2.id <= '499')\nGROUP BY cc.status_id;": [
        149.29,
        7.74,
        7.36,
        141.46,
        12.46,
        3.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '270'\n  AND cc.id <= '300'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '270'\n       AND cc2.id <= '300')\nGROUP BY cc.status_id;": [
        49.79,
        5.11,
        5.02,
        44.64,
        9.25,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '105'\n  AND cc.id <= '266'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '105'\n       AND cc2.id <= '266')\nGROUP BY cc.status_id;": [
        155.17,
        8.01,
        7.6,
        147.07,
        12.79,
        3.07
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '68'\n  AND cc.id <= '320'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '68'\n       AND cc2.id <= '320')\nGROUP BY cc.status_id;": [
        84.72,
        10.04,
        9.4,
        74.64,
        16.27,
        3.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '31'\n  AND cc.id <= '313'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '31'\n       AND cc2.id <= '313')\nGROUP BY cc.status_id;": [
        95.03,
        10.69,
        9.98,
        84.29,
        17.07,
        3.9
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '349'\n  AND cc.id <= '475'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '349'\n       AND cc2.id <= '475')\nGROUP BY cc.status_id;": [
        133.63,
        7.25,
        6.92,
        126.31,
        11.86,
        3.32
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '145'\n  AND cc.id <= '478'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '145'\n       AND cc2.id <= '478')\nGROUP BY cc.status_id;": [
        240.25,
        11.81,
        10.98,
        228.26,
        18.44,
        2.31
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '292'\n  AND cc.id <= '339'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '292'\n       AND cc2.id <= '339')\nGROUP BY cc.status_id;": [
        68.77,
        5.49,
        5.36,
        63.24,
        9.71,
        4.07
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '61'\n  AND cc.id <= '435'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '61'\n       AND cc2.id <= '435')\nGROUP BY cc.status_id;": [
        126.09,
        16.71,
        15.78,
        109.32,
        23.54,
        3.68
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '132'\n  AND cc.id <= '138'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '132'\n       AND cc2.id <= '138')\nGROUP BY cc.status_id;": [
        22.07,
        4.59,
        4.56,
        17.46,
        8.61,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '345'\n  AND cc.id <= '489'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '345'\n       AND cc2.id <= '489')\nGROUP BY cc.status_id;": [
        59.81,
        7.63,
        7.26,
        52.15,
        12.33,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '168'\n  AND cc.id <= '483'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '168'\n       AND cc2.id <= '483')\nGROUP BY cc.status_id;": [
        101.48,
        11.41,
        10.62,
        90.02,
        17.95,
        3.74
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '130'\n  AND cc.id <= '171'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '130'\n       AND cc2.id <= '171')\nGROUP BY cc.status_id;": [
        59.62,
        5.36,
        5.24,
        54.22,
        9.55,
        4.01
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '73'\n  AND cc.id <= '298'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '73'\n       AND cc2.id <= '298')\nGROUP BY cc.status_id;": [
        194.58,
        9.43,
        8.86,
        185.03,
        15.53,
        2.77
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '13'\n  AND cc.id <= '301'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '13'\n       AND cc2.id <= '301')\nGROUP BY cc.status_id;": [
        95.33,
        10.82,
        10.1,
        84.45,
        17.23,
        3.9
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '51'\n  AND cc.id <= '457'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '51'\n       AND cc2.id <= '457')\nGROUP BY cc.status_id;": [
        129.11,
        17.43,
        16.42,
        111.62,
        25.42,
        3.54
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '208'\n  AND cc.id <= '222'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '208'\n       AND cc2.id <= '222')\nGROUP BY cc.status_id;": [
        31.32,
        4.77,
        4.72,
        26.53,
        8.83,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '88'\n  AND cc.id <= '352'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '88'\n       AND cc2.id <= '352')\nGROUP BY cc.status_id;": [
        213.17,
        10.28,
        9.62,
        202.75,
        16.57,
        2.57
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '3'\n  AND cc.id <= '167'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '3'\n       AND cc2.id <= '167')\nGROUP BY cc.status_id;": [
        61.24,
        8.08,
        7.66,
        53.13,
        12.88,
        3.98
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '242'\n  AND cc.id <= '358'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '242'\n       AND cc2.id <= '358')\nGROUP BY cc.status_id;": [
        49.61,
        7.02,
        6.72,
        42.56,
        11.58,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '175'\n  AND cc.id <= '478'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '175'\n       AND cc2.id <= '478')\nGROUP BY cc.status_id;": [
        96.5,
        11.16,
        10.4,
        85.29,
        17.64,
        3.71
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '91'\n  AND cc.id <= '263'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '91'\n       AND cc2.id <= '263')\nGROUP BY cc.status_id;": [
        161.0,
        8.26,
        7.82,
        152.65,
        13.09,
        2.98
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '121'\n  AND cc.id <= '366'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '121'\n       AND cc2.id <= '366')\nGROUP BY cc.status_id;": [
        84.37,
        9.88,
        9.26,
        74.45,
        16.08,
        3.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '172'\n  AND cc.id <= '259'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '172'\n       AND cc2.id <= '259')\nGROUP BY cc.status_id;": [
        103.41,
        6.37,
        6.14,
        96.98,
        10.79,
        3.54
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '290'\n  AND cc.id <= '337'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '290'\n       AND cc2.id <= '337')\nGROUP BY cc.status_id;": [
        68.77,
        5.49,
        5.36,
        63.24,
        9.71,
        4.07
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '318'\n  AND cc.id <= '346'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '318'\n       AND cc2.id <= '346')\nGROUP BY cc.status_id;": [
        23.17,
        5.08,
        5.0,
        18.07,
        9.22,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '426'\n  AND cc.id <= '431'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '426'\n       AND cc2.id <= '431')\nGROUP BY cc.status_id;": [
        17.59,
        4.57,
        4.54,
        13.01,
        8.58,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '393'\n  AND cc.id <= '419'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '393'\n       AND cc2.id <= '419')\nGROUP BY cc.status_id;": [
        45.21,
        5.04,
        4.96,
        40.14,
        9.16,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '444'\n  AND cc.id <= '500'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '444'\n       AND cc2.id <= '500')\nGROUP BY cc.status_id;": [
        74.07,
        5.69,
        5.54,
        68.33,
        9.96,
        3.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '48'\n  AND cc.id <= '468'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '48'\n       AND cc2.id <= '468')\nGROUP BY cc.status_id;": [
        134.24,
        17.75,
        16.7,
        116.43,
        25.81,
        3.58
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '93'\n  AND cc.id <= '484'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '93'\n       AND cc2.id <= '484')\nGROUP BY cc.status_id;": [
        128.36,
        17.1,
        16.12,
        111.21,
        25.01,
        3.54
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '64'\n  AND cc.id <= '276'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '64'\n       AND cc2.id <= '276')\nGROUP BY cc.status_id;": [
        77.87,
        9.13,
        8.6,
        68.69,
        15.17,
        4.07
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '103'\n  AND cc.id <= '447'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '103'\n       AND cc2.id <= '447')\nGROUP BY cc.status_id;": [
        242.08,
        12.06,
        11.2,
        229.84,
        18.74,
        2.24
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '29'\n  AND cc.id <= '87'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '29'\n       AND cc2.id <= '87')\nGROUP BY cc.status_id;": [
        78.6,
        5.74,
        5.58,
        72.81,
        10.02,
        3.88
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '71'\n  AND cc.id <= '389'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '71'\n       AND cc2.id <= '389')\nGROUP BY cc.status_id;": [
        101.63,
        11.47,
        10.68,
        90.1,
        18.03,
        3.74
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '493'\n  AND cc.id <= '494'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '493'\n       AND cc2.id <= '494')\nGROUP BY cc.status_id;": [
        17.39,
        4.48,
        4.46,
        12.9,
        8.47,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '395'\n  AND cc.id <= '447'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '395'\n       AND cc2.id <= '447')\nGROUP BY cc.status_id;": [
        73.45,
        5.6,
        5.46,
        67.8,
        9.85,
        4.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '232'\n  AND cc.id <= '304'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '232'\n       AND cc2.id <= '304')\nGROUP BY cc.status_id;": [
        34.17,
        6.05,
        5.86,
        28.1,
        10.4,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '114'\n  AND cc.id <= '307'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '114'\n       AND cc2.id <= '307')\nGROUP BY cc.status_id;": [
        177.61,
        8.73,
        8.24,
        168.77,
        14.67,
        2.91
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '212'\n  AND cc.id <= '289'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '212'\n       AND cc2.id <= '289')\nGROUP BY cc.status_id;": [
        38.86,
        6.16,
        5.96,
        32.66,
        10.54,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '164'\n  AND cc.id <= '183'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '164'\n       AND cc2.id <= '183')\nGROUP BY cc.status_id;": [
        18.29,
        4.88,
        4.82,
        13.39,
        8.97,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '11'\n  AND cc.id <= '161'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '11'\n       AND cc2.id <= '161')\nGROUP BY cc.status_id;": [
        60.11,
        7.76,
        7.38,
        52.32,
        12.49,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '195'\n  AND cc.id <= '319'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '195'\n       AND cc2.id <= '319')\nGROUP BY cc.status_id;": [
        129.11,
        7.2,
        6.88,
        121.83,
        11.8,
        3.28
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '39'\n  AND cc.id <= '311'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '39'\n       AND cc2.id <= '311')\nGROUP BY cc.status_id;": [
        90.1,
        10.46,
        9.78,
        79.59,
        16.79,
        3.88
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '277'\n  AND cc.id <= '412'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '277'\n       AND cc2.id <= '412')\nGROUP BY cc.status_id;": [
        138.94,
        7.45,
        7.1,
        131.41,
        12.11,
        3.26
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '233'\n  AND cc.id <= '307'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '233'\n       AND cc2.id <= '307')\nGROUP BY cc.status_id;": [
        38.71,
        6.1,
        5.9,
        32.58,
        10.46,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '226'\n  AND cc.id <= '385'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '226'\n       AND cc2.id <= '385')\nGROUP BY cc.status_id;": [
        60.99,
        7.97,
        7.56,
        52.99,
        12.74,
        3.98
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '138'\n  AND cc.id <= '365'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '138'\n       AND cc2.id <= '365')\nGROUP BY cc.status_id;": [
        83.05,
        9.47,
        8.9,
        73.53,
        15.58,
        4.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '123'\n  AND cc.id <= '467'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '123'\n       AND cc2.id <= '467')\nGROUP BY cc.status_id;": [
        107.78,
        12.06,
        11.2,
        95.67,
        18.74,
        3.61
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '8'\n  AND cc.id <= '53'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '8'\n       AND cc2.id <= '53')\nGROUP BY cc.status_id;": [
        28.39,
        5.45,
        5.32,
        22.93,
        9.66,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '14'\n  AND cc.id <= '397'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '14'\n       AND cc2.id <= '397')\nGROUP BY cc.status_id;": [
        127.54,
        16.92,
        15.96,
        110.56,
        24.79,
        3.68
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '433'\n  AND cc.id <= '480'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '433'\n       AND cc2.id <= '480')\nGROUP BY cc.status_id;": [
        28.49,
        5.49,
        5.36,
        22.99,
        9.71,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '76'\n  AND cc.id <= '380'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '76'\n       AND cc2.id <= '380')\nGROUP BY cc.status_id;": [
        96.55,
        11.18,
        10.42,
        85.32,
        17.67,
        3.71
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '216'\n  AND cc.id <= '472'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '216'\n       AND cc2.id <= '472')\nGROUP BY cc.status_id;": [
        84.92,
        10.12,
        9.48,
        74.75,
        16.38,
        3.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '177'\n  AND cc.id <= '222'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '177'\n       AND cc2.id <= '222')\nGROUP BY cc.status_id;": [
        64.24,
        5.45,
        5.32,
        58.76,
        9.66,
        4.04
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '99'\n  AND cc.id <= '360'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '99'\n       AND cc2.id <= '360')\nGROUP BY cc.status_id;": [
        89.55,
        10.21,
        9.56,
        79.29,
        16.49,
        3.88
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '206'\n  AND cc.id <= '321'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '206'\n       AND cc2.id <= '321')\nGROUP BY cc.status_id;": [
        49.56,
        7.0,
        6.7,
        42.53,
        11.56,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '272'\n  AND cc.id <= '313'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '272'\n       AND cc2.id <= '313')\nGROUP BY cc.status_id;": [
        59.62,
        5.36,
        5.24,
        54.22,
        9.55,
        4.01
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '282'\n  AND cc.id <= '335'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '282'\n       AND cc2.id <= '335')\nGROUP BY cc.status_id;": [
        73.5,
        5.63,
        5.48,
        67.83,
        9.88,
        4.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '229'\n  AND cc.id <= '353'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '229'\n       AND cc2.id <= '353')\nGROUP BY cc.status_id;": [
        129.11,
        7.2,
        6.88,
        121.83,
        11.8,
        3.28
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '261'\n  AND cc.id <= '463'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '261'\n       AND cc2.id <= '463')\nGROUP BY cc.status_id;": [
        182.87,
        8.91,
        8.4,
        173.84,
        14.89,
        2.89
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '84'\n  AND cc.id <= '235'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '84'\n       AND cc2.id <= '235')\nGROUP BY cc.status_id;": [
        60.16,
        7.79,
        7.4,
        52.34,
        12.52,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '220'\n  AND cc.id <= '408'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '220'\n       AND cc2.id <= '408')\nGROUP BY cc.status_id;": [
        176.94,
        8.62,
        8.14,
        168.21,
        14.54,
        2.96
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '378'\n  AND cc.id <= '486'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '378'\n       AND cc2.id <= '486')\nGROUP BY cc.status_id;": [
        118.6,
        6.84,
        6.56,
        111.69,
        11.36,
        3.41
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '57'\n  AND cc.id <= '156'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '57'\n       AND cc2.id <= '156')\nGROUP BY cc.status_id;": [
        44.33,
        6.64,
        6.38,
        37.66,
        11.12,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '376'\n  AND cc.id <= '463'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '376'\n       AND cc2.id <= '463')\nGROUP BY cc.status_id;": [
        103.41,
        6.37,
        6.14,
        96.98,
        10.79,
        3.54
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '59'\n  AND cc.id <= '273'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '59'\n       AND cc2.id <= '273')\nGROUP BY cc.status_id;": [
        77.97,
        9.18,
        8.64,
        68.75,
        15.22,
        4.07
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '380'\n  AND cc.id <= '466'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '380'\n       AND cc2.id <= '466')\nGROUP BY cc.status_id;": [
        39.26,
        6.34,
        6.12,
        32.88,
        10.76,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '188'\n  AND cc.id <= '204'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '188'\n       AND cc2.id <= '204')\nGROUP BY cc.status_id;": [
        35.86,
        4.82,
        4.76,
        31.01,
        8.89,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '52'\n  AND cc.id <= '439'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '52'\n       AND cc2.id <= '439')\nGROUP BY cc.status_id;": [
        258.31,
        17.01,
        16.04,
        241.1,
        24.9,
        2.03
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '72'\n  AND cc.id <= '324'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '72'\n       AND cc2.id <= '324')\nGROUP BY cc.status_id;": [
        207.34,
        10.04,
        9.4,
        197.17,
        16.27,
        2.61
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '46'\n  AND cc.id <= '129'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '46'\n       AND cc2.id <= '129')\nGROUP BY cc.status_id;": [
        39.16,
        6.3,
        6.08,
        32.83,
        10.7,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '198'\n  AND cc.id <= '254'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '198'\n       AND cc2.id <= '254')\nGROUP BY cc.status_id;": [
        74.07,
        5.69,
        5.54,
        68.33,
        9.96,
        3.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '20'\n  AND cc.id <= '468'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '20'\n       AND cc2.id <= '468')\nGROUP BY cc.status_id;": [
        268.13,
        18.36,
        17.24,
        249.55,
        26.55,
        1.81
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '395'\n  AND cc.id <= '441'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '395'\n       AND cc2.id <= '441')\nGROUP BY cc.status_id;": [
        68.72,
        5.47,
        5.34,
        63.21,
        9.69,
        4.07
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '237'\n  AND cc.id <= '371'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '237'\n       AND cc2.id <= '371')\nGROUP BY cc.status_id;": [
        54.94,
        7.42,
        7.08,
        47.48,
        12.08,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '30'\n  AND cc.id <= '333'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '30'\n       AND cc2.id <= '333')\nGROUP BY cc.status_id;": [
        96.5,
        11.16,
        10.4,
        85.29,
        17.64,
        3.71
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '57'\n  AND cc.id <= '430'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '57'\n       AND cc2.id <= '430')\nGROUP BY cc.status_id;": [
        254.9,
        16.69,
        15.76,
        238.01,
        23.51,
        2.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '286'\n  AND cc.id <= '442'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '286'\n       AND cc2.id <= '442')\nGROUP BY cc.status_id;": [
        60.41,
        7.9,
        7.5,
        52.48,
        12.65,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '101'\n  AND cc.id <= '189'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '101'\n       AND cc2.id <= '189')\nGROUP BY cc.status_id;": [
        39.36,
        6.39,
        6.16,
        32.94,
        10.81,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '96'\n  AND cc.id <= '390'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '96'\n       AND cc2.id <= '390')\nGROUP BY cc.status_id;": [
        96.05,
        10.96,
        10.22,
        85.05,
        17.4,
        3.71
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '193'\n  AND cc.id <= '254'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '193'\n       AND cc2.id <= '254')\nGROUP BY cc.status_id;": [
        83.18,
        5.81,
        5.64,
        77.32,
        10.1,
        3.9
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '105'\n  AND cc.id <= '256'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '105'\n       AND cc2.id <= '256')\nGROUP BY cc.status_id;": [
        149.82,
        7.79,
        7.4,
        141.94,
        12.52,
        3.11
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '280'\n  AND cc.id <= '379'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '280'\n       AND cc2.id <= '379')\nGROUP BY cc.status_id;": [
        113.3,
        6.64,
        6.38,
        106.59,
        11.12,
        3.49
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '172'\n  AND cc.id <= '429'\n  AND cc.status_id = '4'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '172'\n       AND cc2.id <= '429')\nGROUP BY cc.status_id;": [
        84.92,
        10.12,
        9.48,
        74.75,
        16.38,
        3.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:45\n-- Operation: both\n-- Old Join Path: complete_cast\n-- New Join Path: complete_cast JOIN movie_link ON complete_cast.movie_id = movie_link.movie_id\n-- Table Size Changes: Added join with movie_link which is moderately sized (approx. 3 MB, 29,997 rows) to slightly increase processing cost.\n-- Structural Changes: Added an extra join to movie_link and refined the nested subquery by adding an additional predicate on the id range, preserving the nested aggregation requirement.\n-- LLM Reasoning: To push the execution cost from ~2771 to the target range [3000.0, 4000.0], I introduced an additional join to a moderately sized table (movie_link) and refined the nested subquery by including an extra filter condition. This additional join and enhanced filtering add extra processing overhead while maintaining the original template constraints and placeholder formats.\n\n-- SQL Template Metadata\n-- Template ID: 6\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 2\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: ['complete_cast', 'movie_link']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 2\n\nSELECT cc.status_id,\n       COUNT(*) AS total_count\nFROM complete_cast cc\nJOIN movie_link ml ON cc.movie_id = ml.movie_id\nWHERE cc.id >= '1'\n  AND cc.id <= '1'\n  AND cc.status_id = '3'\n  AND cc.id >\n    (SELECT AVG(cc2.id)\n     FROM complete_cast cc2\n     WHERE cc2.id >= '1'\n       AND cc2.id <= '1')\nGROUP BY cc.status_id;": [
        17.34,
        4.46,
        4.44,
        12.87,
        8.45,
        4.37
    ]
}