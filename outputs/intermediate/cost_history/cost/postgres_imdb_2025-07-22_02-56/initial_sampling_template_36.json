{
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '335'\n  AND m.movie_id <= '503'\n  AND t.production_year = '1888'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '13'\n  AND m.movie_id <= '294'\n  AND t.production_year = '1892'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '289'\n  AND m.movie_id <= '436'\n  AND t.production_year = '1890'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '402'\n  AND m.movie_id <= '429'\n  AND t.production_year = '1976'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '109'\n  AND m.movie_id <= '515'\n  AND t.production_year = '1905'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '244'\n  AND m.movie_id <= '462'\n  AND t.production_year = '1899'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '62'\n  AND m.movie_id <= '498'\n  AND t.production_year = '1942'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '111'\n  AND m.movie_id <= '414'\n  AND t.production_year = '1993'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '217'\n  AND m.movie_id <= '289'\n  AND t.production_year = '1936'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '355'\n  AND m.movie_id <= '436'\n  AND t.production_year = '1937'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '138'\n  AND m.movie_id <= '340'\n  AND t.production_year = '1880'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '52'\n  AND m.movie_id <= '143'\n  AND t.production_year = '1963'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '316'\n  AND m.movie_id <= '438'\n  AND t.production_year = '1924'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '176'\n  AND m.movie_id <= '517'\n  AND t.production_year = '1897'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '168'\n  AND m.movie_id <= '353'\n  AND t.production_year = '2001'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '364'\n  AND m.movie_id <= '488'\n  AND t.production_year = '1889'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '26'\n  AND m.movie_id <= '322'\n  AND t.production_year = '1962'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '143'\n  AND m.movie_id <= '260'\n  AND t.production_year = '1964'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '394'\n  AND m.movie_id <= '453'\n  AND t.production_year = '1998'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '74'\n  AND m.movie_id <= '91'\n  AND t.production_year = '1951'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '86'\n  AND m.movie_id <= '123'\n  AND t.production_year = '1941'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '388'\n  AND m.movie_id <= '460'\n  AND t.production_year = '1985'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '176'\n  AND m.movie_id <= '398'\n  AND t.production_year = '1903'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '153'\n  AND m.movie_id <= '466'\n  AND t.production_year = '1908'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '146'\n  AND m.movie_id <= '342'\n  AND t.production_year = '1945'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '124'\n  AND m.movie_id <= '463'\n  AND t.production_year = '2008'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '361'\n  AND m.movie_id <= '495'\n  AND t.production_year = '1950'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '45'\n  AND m.movie_id <= '128'\n  AND t.production_year = '2007'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '160'\n  AND m.movie_id <= '482'\n  AND t.production_year = '1974'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '129'\n  AND m.movie_id <= '310'\n  AND t.production_year = '1939'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '132'\n  AND m.movie_id <= '195'\n  AND t.production_year = '1935'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '40'\n  AND m.movie_id <= '279'\n  AND t.production_year = '1922'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '119'\n  AND m.movie_id <= '164'\n  AND t.production_year = '1914'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '103'\n  AND m.movie_id <= '508'\n  AND t.production_year = '2004'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '222'\n  AND m.movie_id <= '313'\n  AND t.production_year = '1985'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '154'\n  AND m.movie_id <= '233'\n  AND t.production_year = '1927'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '6'\n  AND m.movie_id <= '465'\n  AND t.production_year = '1951'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '243'\n  AND m.movie_id <= '454'\n  AND t.production_year = '1973'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '149'\n  AND m.movie_id <= '171'\n  AND t.production_year = '2010'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '80'\n  AND m.movie_id <= '376'\n  AND t.production_year = '1925'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '423'\n  AND m.movie_id <= '482'\n  AND t.production_year = '1965'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '432'\n  AND m.movie_id <= '499'\n  AND t.production_year = '1898'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '180'\n  AND m.movie_id <= '238'\n  AND t.production_year = '1981'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '356'\n  AND m.movie_id <= '379'\n  AND t.production_year = '1970'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '9'\n  AND m.movie_id <= '384'\n  AND t.production_year = '2013'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '135'\n  AND m.movie_id <= '204'\n  AND t.production_year = '1929'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '84'\n  AND m.movie_id <= '108'\n  AND t.production_year = '1940'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '17'\n  AND m.movie_id <= '198'\n  AND t.production_year = '2011'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '163'\n  AND m.movie_id <= '305'\n  AND t.production_year = '1980'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '419'\n  AND m.movie_id <= '444'\n  AND t.production_year = '1966'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '191'\n  AND m.movie_id <= '306'\n  AND t.production_year = '2015'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '30'\n  AND m.movie_id <= '54'\n  AND t.production_year = '1962'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '189'\n  AND m.movie_id <= '295'\n  AND t.production_year = '1994'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '125'\n  AND m.movie_id <= '504'\n  AND t.production_year = '2008'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '46'\n  AND m.movie_id <= '321'\n  AND t.production_year = '1987'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '173'\n  AND m.movie_id <= '303'\n  AND t.production_year = '1891'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '6'\n  AND m.movie_id <= '427'\n  AND t.production_year = '1911'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '37'\n  AND m.movie_id <= '238'\n  AND t.production_year = '1946'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '314'\n  AND m.movie_id <= '476'\n  AND t.production_year = '2009'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '190'\n  AND m.movie_id <= '207'\n  AND t.production_year = '1936'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '146'\n  AND m.movie_id <= '393'\n  AND t.production_year = '1979'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '273'\n  AND m.movie_id <= '339'\n  AND t.production_year = '1903'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '20'\n  AND m.movie_id <= '192'\n  AND t.production_year = '1953'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '367'\n  AND m.movie_id <= '372'\n  AND t.production_year = '1930'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '32'\n  AND m.movie_id <= '497'\n  AND t.production_year = '1898'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '185'\n  AND m.movie_id <= '296'\n  AND t.production_year = '1933'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '332'\n  AND m.movie_id <= '484'\n  AND t.production_year = '1998'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '385'\n  AND m.movie_id <= '406'\n  AND t.production_year = '1909'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '27'\n  AND m.movie_id <= '332'\n  AND t.production_year = '1917'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '68'\n  AND m.movie_id <= '94'\n  AND t.production_year = '1913'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '343'\n  AND m.movie_id <= '444'\n  AND t.production_year = '1949'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '198'\n  AND m.movie_id <= '509'\n  AND t.production_year = '1931'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '375'\n  AND m.movie_id <= '506'\n  AND t.production_year = '1945'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '328'\n  AND m.movie_id <= '405'\n  AND t.production_year = '2017'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '105'\n  AND m.movie_id <= '233'\n  AND t.production_year = '1958'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '76'\n  AND m.movie_id <= '181'\n  AND t.production_year = '1948'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '98'\n  AND m.movie_id <= '324'\n  AND t.production_year = '1996'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '196'\n  AND m.movie_id <= '365'\n  AND t.production_year = '1920'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '420'\n  AND m.movie_id <= '514'\n  AND t.production_year = '1960'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '51'\n  AND m.movie_id <= '169'\n  AND t.production_year = '1894'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '225'\n  AND m.movie_id <= '268'\n  AND t.production_year = '2000'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '32'\n  AND m.movie_id <= '278'\n  AND t.production_year = '1902'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '69'\n  AND m.movie_id <= '268'\n  AND t.production_year = '1919'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '42'\n  AND m.movie_id <= '219'\n  AND t.production_year = '1890'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '19'\n  AND m.movie_id <= '307'\n  AND t.production_year = '1924'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '84'\n  AND m.movie_id <= '261'\n  AND t.production_year = '1983'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '102'\n  AND m.movie_id <= '110'\n  AND t.production_year = '1995'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '282'\n  AND m.movie_id <= '410'\n  AND t.production_year = '1966'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '90'\n  AND m.movie_id <= '281'\n  AND t.production_year = '2002'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '24'\n  AND m.movie_id <= '165'\n  AND t.production_year = '1912'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '343'\n  AND m.movie_id <= '398'\n  AND t.production_year = '1956'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '152'\n  AND m.movie_id <= '216'\n  AND t.production_year = '1932'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '86'\n  AND m.movie_id <= '389'\n  AND t.production_year = '1991'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '49'\n  AND m.movie_id <= '494'\n  AND t.production_year = '1972'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '337'\n  AND m.movie_id <= '485'\n  AND t.production_year = '2017'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '37'\n  AND m.movie_id <= '54'\n  AND t.production_year = '1955'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '60'\n  AND m.movie_id <= '208'\n  AND t.production_year = '1977'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '416'\n  AND m.movie_id <= '475'\n  AND t.production_year = '1910'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '254'\n  AND m.movie_id <= '277'\n  AND t.production_year = '1938'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '3'\n  AND m.movie_id <= '37'\n  AND t.production_year = '1948'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '250'\n  AND m.movie_id <= '293'\n  AND t.production_year = '1969'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '362'\n  AND m.movie_id <= '442'\n  AND t.production_year = '1942'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '118'\n  AND m.movie_id <= '309'\n  AND t.production_year = '1928'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '288'\n  AND m.movie_id <= '489'\n  AND t.production_year = '1971'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '52'\n  AND m.movie_id <= '368'\n  AND t.production_year = '1969'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '116'\n  AND m.movie_id <= '201'\n  AND t.production_year = '1934'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '62'\n  AND m.movie_id <= '488'\n  AND t.production_year = '2004'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '185'\n  AND m.movie_id <= '315'\n  AND t.production_year = '1988'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '203'\n  AND m.movie_id <= '267'\n  AND t.production_year = '1915'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '155'\n  AND m.movie_id <= '447'\n  AND t.production_year = '1916'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '1'\n  AND m.movie_id <= '392'\n  AND t.production_year = '1893'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '263'\n  AND m.movie_id <= '407'\n  AND t.production_year = '2000'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '8'\n  AND m.movie_id <= '346'\n  AND t.production_year = '1973'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '284'\n  AND m.movie_id <= '502'\n  AND t.production_year = '1900'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '206'\n  AND m.movie_id <= '358'\n  AND t.production_year = '1926'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '103'\n  AND m.movie_id <= '371'\n  AND t.production_year = '1954'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '249'\n  AND m.movie_id <= '298'\n  AND t.production_year = '1976'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '163'\n  AND m.movie_id <= '184'\n  AND t.production_year = '1918'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '451'\n  AND m.movie_id <= '457'\n  AND t.production_year = '1895'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '66'\n  AND m.movie_id <= '451'\n  AND t.production_year = '1913'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '288'\n  AND m.movie_id <= '348'\n  AND t.production_year = '1904'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '179'\n  AND m.movie_id <= '433'\n  AND t.production_year = '1920'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '23'\n  AND m.movie_id <= '412'\n  AND t.production_year = '1921'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '43'\n  AND m.movie_id <= '138'\n  AND t.production_year = '2011'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '251'\n  AND m.movie_id <= '475'\n  AND t.production_year = '2003'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '120'\n  AND m.movie_id <= '449'\n  AND t.production_year = '2005'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '14'\n  AND m.movie_id <= '73'\n  AND t.production_year = '2016'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '77'\n  AND m.movie_id <= '468'\n  AND t.production_year = '1990'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '218'\n  AND m.movie_id <= '221'\n  AND t.production_year = '1978'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '79'\n  AND m.movie_id <= '241'\n  AND t.production_year = '1944'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '240'\n  AND m.movie_id <= '332'\n  AND t.production_year = '1982'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '16'\n  AND m.movie_id <= '509'\n  AND t.production_year = '1906'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '350'\n  AND m.movie_id <= '389'\n  AND t.production_year = '1983'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '115'\n  AND m.movie_id <= '159'\n  AND t.production_year = '1960'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '273'\n  AND m.movie_id <= '300'\n  AND t.production_year = '1896'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '23'\n  AND m.movie_id <= '149'\n  AND t.production_year = '1991'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '326'\n  AND m.movie_id <= '430'\n  AND t.production_year = '1988'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '371'\n  AND m.movie_id <= '399'\n  AND t.production_year = '1957'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '67'\n  AND m.movie_id <= '415'\n  AND t.production_year = '1957'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '100'\n  AND m.movie_id <= '422'\n  AND t.production_year = '1931'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '226'\n  AND m.movie_id <= '380'\n  AND t.production_year = '2013'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '381'\n  AND m.movie_id <= '474'\n  AND t.production_year = '1952'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '94'\n  AND m.movie_id <= '133'\n  AND t.production_year = '1968'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '137'\n  AND m.movie_id <= '320'\n  AND t.production_year = '1986'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '60'\n  AND m.movie_id <= '211'\n  AND t.production_year = '1997'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '479'\n  AND m.movie_id <= '516'\n  AND t.production_year = '1901'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '408'\n  AND m.movie_id <= '425'\n  AND t.production_year = '2019'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '352'\n  AND m.movie_id <= '439'\n  AND t.production_year = '1908'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '211'\n  AND m.movie_id <= '458'\n  AND t.production_year = '1993'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": [],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:58\n-- Operation: structure\n-- Old Join Path: movie_info -> title -> cast_info -> role_type -> movie_companies -> company_name -> movie_info\n-- New Join Path: same as old\n-- Table Size Changes: none\n-- Structural Changes: Added additional selective predicates: filtering cast_info.id using placeholders and added extra conditions in the nested query on movie_companies.company_id. These changes reduce the number of rows processed to push the execution cost into the target range.\n-- LLM Reasoning: To push the cost down into the [7000.0, 8000.0] range without breaking the constraint requirements (maintaining 6 joins and a nested aggregation), additional selective predicate filters were added. This should reduce the result set's size and lower the overall execution cost while preserving the original join path.\n\n-- SQL Template Metadata\n-- Template ID: 20\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_id >= '{{movie_companies.company_id_low}}'\n     AND mc2.company_id <= '{{movie_companies.company_id_high}}') AS nested_sum_company_id\nFROM movie_info m\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON m.movie_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '1'\n  AND m.movie_id <= '1'\n  AND t.production_year = '1880'\n  AND c.id >= '{{cast_info.id_low}}'\n  AND c.id <= '{{cast_info.id_high}}'\nGROUP BY m.movie_id;": []
}