{
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '1'\n  AND m.movie_id <= '1'\n  AND t.production_year = '1880'\n  AND c.nr_order = '2'\nGROUP BY m.movie_id;": [
        1251.6,
        399.06,
        396.62,
        395.35,
        362.49,
        360.65,
        343.24,
        5.24,
        8.45,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '143') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '144'\n  AND m.movie_id <= '325'\n  AND t.production_year = '1919'\n  AND c.nr_order = '143'\nGROUP BY m.movie_id;": [
        5912.7,
        4974.96,
        4972.52,
        4971.25,
        4969.42,
        4955.25,
        4842.92,
        16.11,
        8.27,
        112.31,
        14.11,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '711') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '404'\n  AND m.movie_id <= '410'\n  AND t.production_year = '1912'\n  AND c.nr_order = '711'\nGROUP BY m.movie_id;": [
        1481.95,
        544.21,
        541.77,
        540.5,
        507.64,
        505.8,
        495.7,
        5.59,
        8.45,
        10.04,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '264') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '77'\n  AND m.movie_id <= '281'\n  AND t.production_year = '1944'\n  AND c.nr_order = '264'\nGROUP BY m.movie_id;": [
        6458.63,
        5520.9,
        5518.46,
        5517.19,
        5515.35,
        5416.76,
        5399.35,
        17.5,
        8.24,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '4006') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '112'\n  AND m.movie_id <= '448'\n  AND t.production_year = '1910'\n  AND c.nr_order = '4006'\nGROUP BY m.movie_id;": [
        9719.92,
        8782.18,
        8779.74,
        8778.47,
        8776.64,
        8763.53,
        8549.94,
        29.43,
        8.11,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '369') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '124'\n  AND m.movie_id <= '314'\n  AND t.production_year = '1912'\n  AND c.nr_order = '369'\nGROUP BY m.movie_id;": [
        6197.31,
        5259.58,
        5257.14,
        5255.87,
        5254.03,
        5243.92,
        5059.61,
        16.65,
        8.25,
        92.15,
        10.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '22000') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '333'\n  AND m.movie_id <= '516'\n  AND t.production_year = '2012'\n  AND c.nr_order = '22000'\nGROUP BY m.movie_id;": [
        7214.35,
        6276.61,
        6274.18,
        6272.91,
        6271.07,
        6266.41,
        4889.74,
        16.23,
        8.26,
        36.22,
        4.59,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '296') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '44'\n  AND m.movie_id <= '212'\n  AND t.production_year = '1987'\n  AND c.nr_order = '296'\nGROUP BY m.movie_id;": [
        5721.06,
        4783.33,
        4780.89,
        4779.62,
        4777.78,
        4770.67,
        4524.59,
        15.33,
        8.27,
        61.51,
        7.05,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1021') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '388'\n  AND m.movie_id <= '509'\n  AND t.production_year = '1974'\n  AND c.nr_order = '1021'\nGROUP BY m.movie_id;": [
        4468.25,
        3530.52,
        3528.08,
        3526.81,
        3524.98,
        3516.94,
        3374.32,
        12.51,
        8.32,
        71.3,
        7.97,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '77') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '72'\n  AND m.movie_id <= '508'\n  AND t.production_year = '1951'\n  AND c.nr_order = '77'\nGROUP BY m.movie_id;": [
        12146.3,
        11208.57,
        11206.13,
        11204.86,
        11203.02,
        11190.03,
        10870.94,
        35.44,
        8.03,
        106.35,
        12.93,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1305') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '297'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1910'\n  AND c.nr_order = '1305'\nGROUP BY m.movie_id;": [
        4021.53,
        3083.79,
        3081.35,
        3080.08,
        3078.25,
        3065.15,
        2958.35,
        11.5,
        8.35,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '273') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '2'\n  AND m.movie_id <= '470'\n  AND t.production_year = '2013'\n  AND c.nr_order = '273'\nGROUP BY m.movie_id;": [
        13987.66,
        13049.92,
        13047.48,
        13046.21,
        13044.38,
        13039.15,
        11600.06,
        37.36,
        8.0,
        42.31,
        5.17,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '147') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '336'\n  AND m.movie_id <= '422'\n  AND t.production_year = '1913'\n  AND c.nr_order = '147'\nGROUP BY m.movie_id;": [
        3551.64,
        2613.91,
        2611.47,
        2610.2,
        2608.36,
        2597.41,
        2500.5,
        10.4,
        8.36,
        96.9,
        10.89,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '27001') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '27'\n  AND m.movie_id <= '219'\n  AND t.production_year = '1970'\n  AND c.nr_order = '27001'\nGROUP BY m.movie_id;": [
        6335.25,
        5397.51,
        5395.07,
        5393.8,
        5391.97,
        5384.11,
        5106.43,
        16.77,
        8.25,
        69.41,
        7.8,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '829') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '16'\n  AND m.movie_id <= '31'\n  AND t.production_year = '1961'\n  AND c.nr_order = '829'\nGROUP BY m.movie_id;": [
        1742.44,
        804.71,
        802.27,
        801.0,
        799.16,
        733.43,
        724.39,
        6.13,
        8.45,
        8.99,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '390') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '219'\n  AND m.movie_id <= '433'\n  AND t.production_year = '1952'\n  AND c.nr_order = '390'\nGROUP BY m.movie_id;": [
        6793.68,
        5855.95,
        5853.51,
        5852.24,
        5850.4,
        5838.71,
        5637.45,
        18.09,
        8.23,
        100.62,
        11.63,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2198') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '276'\n  AND m.movie_id <= '401'\n  AND t.production_year = '1893'\n  AND c.nr_order = '2198'\nGROUP BY m.movie_id;": [
        4498.38,
        3560.64,
        3558.2,
        3556.93,
        3555.1,
        3489.37,
        3471.96,
        12.76,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '106') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '3'\n  AND m.movie_id <= '473'\n  AND t.production_year = '1963'\n  AND c.nr_order = '106'\nGROUP BY m.movie_id;": [
        13157.04,
        12219.31,
        12216.87,
        12215.6,
        12213.76,
        12204.94,
        11646.88,
        37.48,
        8.0,
        79.71,
        8.76,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '436') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '4'\n  AND m.movie_id <= '330'\n  AND t.production_year = '1896'\n  AND c.nr_order = '436'\nGROUP BY m.movie_id;": [
        9404.03,
        8466.3,
        8463.86,
        8462.59,
        8460.75,
        8444.45,
        8315.84,
        28.84,
        8.12,
        128.59,
        16.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '831') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '50'\n  AND m.movie_id <= '334'\n  AND t.production_year = '1991'\n  AND c.nr_order = '831'\nGROUP BY m.movie_id;": [
        8714.71,
        7776.98,
        7774.54,
        7773.27,
        7771.43,
        7764.84,
        7316.15,
        26.29,
        8.16,
        56.07,
        6.53,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1009') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '475'\n  AND m.movie_id <= '485'\n  AND t.production_year = '1979'\n  AND c.nr_order = '1009'\nGROUP BY m.movie_id;": [
        1613.98,
        676.24,
        673.8,
        672.53,
        670.7,
        604.97,
        597.34,
        5.83,
        8.45,
        7.57,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '28000') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '28'\n  AND m.movie_id <= '220'\n  AND t.production_year = '1968'\n  AND c.nr_order = '28000'\nGROUP BY m.movie_id;": [
        6275.2,
        5337.46,
        5335.02,
        5333.75,
        5331.92,
        5323.77,
        5106.43,
        16.77,
        8.25,
        72.44,
        8.08,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '266') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '78'\n  AND m.movie_id <= '279'\n  AND t.production_year = '1944'\n  AND c.nr_order = '266'\nGROUP BY m.movie_id;": [
        6386.4,
        5448.67,
        5446.23,
        5444.96,
        5443.12,
        5344.53,
        5327.12,
        17.32,
        8.25,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '389') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '218'\n  AND m.movie_id <= '433'\n  AND t.production_year = '1952'\n  AND c.nr_order = '389'\nGROUP BY m.movie_id;": [
        6819.09,
        5881.36,
        5878.92,
        5877.65,
        5875.81,
        5864.12,
        5662.86,
        18.15,
        8.23,
        100.62,
        11.63,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '488525') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '370'\n  AND m.movie_id <= '418'\n  AND t.production_year = '1983'\n  AND c.nr_order = '488525'\nGROUP BY m.movie_id;": [
        2572.84,
        1635.1,
        1632.66,
        1631.39,
        1629.56,
        1621.92,
        1554.92,
        8.12,
        8.41,
        66.99,
        7.57,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '10000') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '36'\n  AND m.movie_id <= '348'\n  AND t.production_year = '1920'\n  AND c.nr_order = '10000'\nGROUP BY m.movie_id;": [
        9165.15,
        8227.42,
        8224.98,
        8223.71,
        8221.87,
        8207.79,
        7984.1,
        28.0,
        8.14,
        111.83,
        14.02,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '970713') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '370'\n  AND m.movie_id <= '417'\n  AND t.production_year = '1982'\n  AND c.nr_order = '970713'\nGROUP BY m.movie_id;": [
        2551.19,
        1613.45,
        1611.01,
        1609.74,
        1607.91,
        1599.95,
        1529.51,
        8.06,
        8.41,
        70.43,
        7.89,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '266') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '49'\n  AND m.movie_id <= '85'\n  AND t.production_year = '1941'\n  AND c.nr_order = '266'\nGROUP BY m.movie_id;": [
        2247.56,
        1309.82,
        1307.38,
        1306.11,
        1273.25,
        1271.41,
        1254.0,
        7.4,
        8.42,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '305') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '133'\n  AND m.movie_id <= '170'\n  AND t.production_year = '1915'\n  AND c.nr_order = '305'\nGROUP BY m.movie_id;": [
        2299.66,
        1361.93,
        1359.49,
        1358.22,
        1356.38,
        1290.65,
        1279.41,
        7.45,
        8.42,
        11.18,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '370') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '126'\n  AND m.movie_id <= '313'\n  AND t.production_year = '1913'\n  AND c.nr_order = '370'\nGROUP BY m.movie_id;": [
        6135.44,
        5197.7,
        5195.26,
        5193.99,
        5192.16,
        5181.2,
        4987.38,
        16.47,
        8.26,
        96.9,
        10.89,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '306') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '133'\n  AND m.movie_id <= '173'\n  AND t.production_year = '1912'\n  AND c.nr_order = '306'\nGROUP BY m.movie_id;": [
        2401.18,
        1463.45,
        1461.01,
        1459.74,
        1457.9,
        1447.8,
        1355.64,
        7.63,
        8.43,
        92.15,
        10.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '294') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '42'\n  AND m.movie_id <= '211'\n  AND t.production_year = '1987'\n  AND c.nr_order = '294'\nGROUP BY m.movie_id;": [
        5746.47,
        4808.74,
        4806.3,
        4805.03,
        4803.19,
        4796.08,
        4550.0,
        15.4,
        8.27,
        61.51,
        7.05,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '444') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '15'\n  AND m.movie_id <= '221'\n  AND t.production_year = '1931'\n  AND c.nr_order = '444'\nGROUP BY m.movie_id;": [
        6529.9,
        5592.17,
        5589.73,
        5588.46,
        5586.62,
        5570.86,
        5450.17,
        17.61,
        8.24,
        120.67,
        15.71,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '459') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '16'\n  AND m.movie_id <= '220'\n  AND t.production_year = '1933'\n  AND c.nr_order = '459'\nGROUP BY m.movie_id;": [
        6458.63,
        5520.9,
        5518.46,
        5517.19,
        5515.35,
        5416.76,
        5399.35,
        17.5,
        8.24,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '155') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '281'\n  AND m.movie_id <= '504'\n  AND t.production_year = '1956'\n  AND c.nr_order = '155'\nGROUP BY m.movie_id;": [
        6994.46,
        6056.73,
        6054.29,
        6053.02,
        6051.18,
        6041.18,
        5858.14,
        18.64,
        8.22,
        91.51,
        9.94,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1046') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '56'\n  AND m.movie_id <= '159'\n  AND t.production_year = '1918'\n  AND c.nr_order = '1046'\nGROUP BY m.movie_id;": [
        3988.64,
        3050.9,
        3048.46,
        3047.19,
        3045.36,
        2946.77,
        2932.94,
        11.44,
        8.35,
        13.77,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '273') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '3'\n  AND m.movie_id <= '472'\n  AND t.production_year = '2013'\n  AND c.nr_order = '273'\nGROUP BY m.movie_id;": [
        14009.07,
        13071.33,
        13068.89,
        13067.62,
        13065.79,
        13060.56,
        11621.47,
        37.42,
        7.99,
        42.31,
        5.17,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '428') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '295'\n  AND m.movie_id <= '371'\n  AND t.production_year = '1940'\n  AND c.nr_order = '428'\nGROUP BY m.movie_id;": [
        3247.95,
        2310.22,
        2307.78,
        2306.51,
        2273.65,
        2271.81,
        2254.4,
        9.79,
        8.38,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '428') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '296'\n  AND m.movie_id <= '374'\n  AND t.production_year = '1940'\n  AND c.nr_order = '428'\nGROUP BY m.movie_id;": [
        3294.77,
        2357.04,
        2354.6,
        2353.33,
        2320.47,
        2318.63,
        2301.22,
        9.92,
        8.36,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '802') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '55'\n  AND m.movie_id <= '57'\n  AND t.production_year = '1953'\n  AND c.nr_order = '802'\nGROUP BY m.movie_id;": [
        1383.19,
        445.46,
        443.02,
        441.75,
        408.88,
        407.05,
        394.06,
        5.35,
        8.45,
        12.93,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '803') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '55'\n  AND m.movie_id <= '56'\n  AND t.production_year = '1953'\n  AND c.nr_order = '803'\nGROUP BY m.movie_id;": [
        1336.48,
        420.05,
        417.61,
        416.34,
        383.47,
        381.64,
        368.65,
        5.29,
        8.45,
        12.93,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '264') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '80'\n  AND m.movie_id <= '281'\n  AND t.production_year = '1944'\n  AND c.nr_order = '264'\nGROUP BY m.movie_id;": [
        6386.4,
        5448.67,
        5446.23,
        5444.96,
        5443.12,
        5344.53,
        5327.12,
        17.32,
        8.25,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '459') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '13'\n  AND m.movie_id <= '217'\n  AND t.production_year = '1931'\n  AND c.nr_order = '459'\nGROUP BY m.movie_id;": [
        6479.08,
        5541.35,
        5538.91,
        5537.64,
        5535.8,
        5520.04,
        5399.35,
        17.5,
        8.24,
        120.67,
        15.71,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '31') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '146'\n  AND m.movie_id <= '426'\n  AND t.production_year = '1940'\n  AND c.nr_order = '31'\nGROUP BY m.movie_id;": [
        8299.66,
        7361.92,
        7359.48,
        7358.21,
        7356.38,
        7351.12,
        7222.51,
        26.06,
        8.17,
        128.59,
        5.2,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '444') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '14'\n  AND m.movie_id <= '221'\n  AND t.production_year = '1932'\n  AND c.nr_order = '444'\nGROUP BY m.movie_id;": [
        6546.64,
        5608.9,
        5606.46,
        5605.19,
        5603.36,
        5587.7,
        5467.58,
        17.68,
        8.23,
        120.11,
        15.59,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '389') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '216'\n  AND m.movie_id <= '433'\n  AND t.production_year = '1950'\n  AND c.nr_order = '389'\nGROUP BY m.movie_id;": [
        6776.86,
        5839.12,
        5836.68,
        5835.41,
        5833.58,
        5820.48,
        5713.68,
        18.27,
        8.23,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '390') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '219'\n  AND m.movie_id <= '430'\n  AND t.production_year = '1951'\n  AND c.nr_order = '390'\nGROUP BY m.movie_id;": [
        6627.85,
        5690.12,
        5687.68,
        5686.41,
        5684.57,
        5671.58,
        5565.22,
        17.91,
        8.23,
        106.35,
        12.93,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '463') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '459'\n  AND m.movie_id <= '488'\n  AND t.production_year = '2001'\n  AND c.nr_order = '463'\nGROUP BY m.movie_id;": [
        2153.93,
        1216.2,
        1213.76,
        1212.49,
        1210.65,
        1205.35,
        1076.13,
        6.97,
        8.42,
        43.06,
        5.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '370') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '124'\n  AND m.movie_id <= '314'\n  AND t.production_year = '1911'\n  AND c.nr_order = '370'\nGROUP BY m.movie_id;": [
        6121.7,
        5183.97,
        5181.53,
        5180.26,
        5178.42,
        5165.54,
        5059.61,
        16.65,
        8.25,
        105.92,
        12.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '373') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '124'\n  AND m.movie_id <= '316'\n  AND t.production_year = '1910'\n  AND c.nr_order = '373'\nGROUP BY m.movie_id;": [
        6169.61,
        5231.87,
        5229.43,
        5228.16,
        5226.33,
        5213.23,
        5106.43,
        16.77,
        8.25,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '355') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '82'\n  AND m.movie_id <= '159'\n  AND t.production_year = '1954'\n  AND c.nr_order = '355'\nGROUP BY m.movie_id;": [
        3326.11,
        2388.37,
        2385.94,
        2384.67,
        2382.83,
        2372.01,
        2275.81,
        9.86,
        8.36,
        96.19,
        10.75,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '28000') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '27'\n  AND m.movie_id <= '222'\n  AND t.production_year = '1967'\n  AND c.nr_order = '28000'\nGROUP BY m.movie_id;": [
        6442.4,
        5504.66,
        5502.22,
        5500.95,
        5499.12,
        5491.9,
        5178.66,
        16.95,
        8.25,
        62.64,
        7.16,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '28000') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '27'\n  AND m.movie_id <= '218'\n  AND t.production_year = '1970'\n  AND c.nr_order = '28000'\nGROUP BY m.movie_id;": [
        6309.84,
        5372.1,
        5369.66,
        5368.39,
        5366.56,
        5358.7,
        5081.02,
        16.71,
        8.25,
        69.41,
        7.8,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '795') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '38'\n  AND m.movie_id <= '45'\n  AND t.production_year = '1963'\n  AND c.nr_order = '795'\nGROUP BY m.movie_id;": [
        1506.07,
        568.34,
        565.9,
        564.63,
        531.76,
        529.93,
        521.11,
        5.66,
        8.45,
        8.76,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '353') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '80'\n  AND m.movie_id <= '159'\n  AND t.production_year = '1955'\n  AND c.nr_order = '353'\nGROUP BY m.movie_id;": [
        3379.52,
        2441.78,
        2439.34,
        2438.07,
        2436.24,
        2424.99,
        2326.63,
        9.97,
        8.36,
        98.35,
        11.18,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '27') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '332'\n  AND m.movie_id <= '427'\n  AND t.production_year = '2012'\n  AND c.nr_order = '27'\nGROUP BY m.movie_id;": [
        10115.75,
        3530.3,
        3513.23,
        3500.38,
        3495.72,
        3494.45,
        2733.66,
        10.96,
        8.35,
        36.22,
        1.12,
        4.59,
        1.84,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '444') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '89'\n  AND m.movie_id <= '171'\n  AND t.production_year = '2013'\n  AND c.nr_order = '444'\nGROUP BY m.movie_id;": [
        3647.65,
        2709.91,
        2707.47,
        2706.2,
        2704.37,
        2699.14,
        2402.86,
        10.15,
        8.37,
        42.31,
        5.17,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '526') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '235'\n  AND m.movie_id <= '305'\n  AND t.production_year = '1931'\n  AND c.nr_order = '526'\nGROUP BY m.movie_id;": [
        3130.72,
        2192.98,
        2190.54,
        2189.27,
        2187.44,
        2121.71,
        2105.94,
        9.44,
        8.39,
        15.71,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '210') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '215'\n  AND m.movie_id <= '336'\n  AND t.production_year = '1903'\n  AND c.nr_order = '210'\nGROUP BY m.movie_id;": [
        4400.74,
        3463.0,
        3460.56,
        3459.29,
        3457.46,
        3391.73,
        3374.32,
        12.51,
        8.32,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '226') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '209'\n  AND m.movie_id <= '315'\n  AND t.production_year = '1972'\n  AND c.nr_order = '226'\nGROUP BY m.movie_id;": [
        4102.49,
        3164.75,
        3162.31,
        3161.04,
        3159.21,
        3151.02,
        3005.17,
        11.62,
        8.34,
        72.91,
        8.13,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '90') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '311'\n  AND m.movie_id <= '387'\n  AND t.production_year = '1978'\n  AND c.nr_order = '90'\nGROUP BY m.movie_id;": [
        3343.96,
        2406.23,
        2403.79,
        2402.52,
        2400.68,
        2392.84,
        2254.4,
        9.79,
        8.38,
        69.21,
        7.78,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '230') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '231'\n  AND m.movie_id <= '342'\n  AND t.production_year = '1960'\n  AND c.nr_order = '230'\nGROUP BY m.movie_id;": [
        4245.17,
        3307.44,
        3305.0,
        3303.73,
        3301.89,
        3293.01,
        3132.22,
        11.92,
        8.34,
        80.38,
        8.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '28000') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '30'\n  AND m.movie_id <= '221'\n  AND t.production_year = '1970'\n  AND c.nr_order = '28000'\nGROUP BY m.movie_id;": [
        6309.84,
        5372.1,
        5369.66,
        5368.39,
        5366.56,
        5358.7,
        5081.02,
        16.71,
        8.25,
        69.41,
        7.8,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '226') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '180'\n  AND m.movie_id <= '505'\n  AND t.production_year = '2009'\n  AND c.nr_order = '226'\nGROUP BY m.movie_id;": [
        11203.71,
        10265.98,
        10263.54,
        10262.27,
        10260.43,
        10255.7,
        8290.43,
        28.78,
        8.12,
        37.07,
        4.67,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '263') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '100'\n  AND m.movie_id <= '473'\n  AND t.production_year = '1914'\n  AND c.nr_order = '263'\nGROUP BY m.movie_id;": [
        10660.24,
        9722.5,
        9720.06,
        9718.79,
        9716.96,
        9705.93,
        9414.11,
        31.65,
        8.08,
        97.26,
        10.96,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '28000') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '26'\n  AND m.movie_id <= '218'\n  AND t.production_year = '1971'\n  AND c.nr_order = '28000'\nGROUP BY m.movie_id;": [
        6277.42,
        5339.69,
        5337.25,
        5335.98,
        5334.14,
        5325.93,
        5106.43,
        16.77,
        8.25,
        73.16,
        8.15,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '27001') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '28'\n  AND m.movie_id <= '217'\n  AND t.production_year = '1971'\n  AND c.nr_order = '27001'\nGROUP BY m.movie_id;": [
        6205.19,
        5267.46,
        5265.02,
        5263.75,
        5261.91,
        5253.7,
        5034.2,
        16.59,
        8.25,
        73.16,
        8.15,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '317') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '53'\n  AND m.movie_id <= '105'\n  AND t.production_year = '2008'\n  AND c.nr_order = '317'\nGROUP BY m.movie_id;": [
        2977.06,
        2039.32,
        2036.88,
        2035.61,
        2033.78,
        2029.03,
        1656.56,
        8.36,
        8.41,
        37.23,
        4.69,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '384') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '218'\n  AND m.movie_id <= '432'\n  AND t.production_year = '1953'\n  AND c.nr_order = '384'\nGROUP BY m.movie_id;": [
        6700.08,
        5762.35,
        5759.91,
        5758.64,
        5756.8,
        5743.81,
        5637.45,
        18.09,
        8.23,
        106.35,
        12.93,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1092') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '8'\n  AND m.movie_id <= '488'\n  AND t.production_year = '1903'\n  AND c.nr_order = '1092'\nGROUP BY m.movie_id;": [
        12969.64,
        12031.91,
        12029.47,
        12028.2,
        12026.36,
        12010.06,
        11881.45,
        38.09,
        7.99,
        128.59,
        16.24,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '387') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '219'\n  AND m.movie_id <= '433'\n  AND t.production_year = '1953'\n  AND c.nr_order = '387'\nGROUP BY m.movie_id;": [
        6700.08,
        5762.35,
        5759.91,
        5758.64,
        5756.8,
        5743.81,
        5637.45,
        18.09,
        8.23,
        106.35,
        12.93,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '369') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '127'\n  AND m.movie_id <= '311'\n  AND t.production_year = '1911'\n  AND c.nr_order = '369'\nGROUP BY m.movie_id;": [
        5977.24,
        5039.51,
        5037.07,
        5035.8,
        5033.96,
        5021.08,
        4915.15,
        16.29,
        8.26,
        105.92,
        12.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '271') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '81'\n  AND m.movie_id <= '280'\n  AND t.production_year = '1944'\n  AND c.nr_order = '271'\nGROUP BY m.movie_id;": [
        6335.58,
        5397.85,
        5395.41,
        5394.14,
        5392.3,
        5293.71,
        5276.3,
        17.19,
        8.24,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '263') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '84'\n  AND m.movie_id <= '281'\n  AND t.production_year = '1944'\n  AND c.nr_order = '263'\nGROUP BY m.movie_id;": [
        6288.76,
        5351.03,
        5348.59,
        5347.32,
        5345.48,
        5246.89,
        5229.48,
        17.07,
        8.25,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '387') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '212'\n  AND m.movie_id <= '431'\n  AND t.production_year = '1950'\n  AND c.nr_order = '387'\nGROUP BY m.movie_id;": [
        6823.68,
        5885.94,
        5883.5,
        5882.23,
        5880.4,
        5867.3,
        5760.5,
        18.39,
        8.23,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '701') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '412'\n  AND m.movie_id <= '462'\n  AND t.production_year = '1901'\n  AND c.nr_order = '701'\nGROUP BY m.movie_id;": [
        2599.29,
        1661.56,
        1659.12,
        1657.85,
        1624.99,
        1623.15,
        1605.74,
        8.24,
        8.41,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '396') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '217'\n  AND m.movie_id <= '430'\n  AND t.production_year = '1952'\n  AND c.nr_order = '396'\nGROUP BY m.movie_id;": [
        6772.27,
        5834.54,
        5832.1,
        5830.83,
        5828.99,
        5817.3,
        5616.04,
        18.04,
        8.23,
        100.62,
        11.63,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '2034') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '139'\n  AND m.movie_id <= '171'\n  AND t.production_year = '1897'\n  AND c.nr_order = '2034'\nGROUP BY m.movie_id;": [
        2145.92,
        1208.18,
        1205.74,
        1204.47,
        1171.61,
        1169.77,
        1152.36,
        7.16,
        8.42,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '258') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '78'\n  AND m.movie_id <= '283'\n  AND t.production_year = '1944'\n  AND c.nr_order = '258'\nGROUP BY m.movie_id;": [
        6484.04,
        5546.31,
        5543.87,
        5542.6,
        5540.76,
        5442.17,
        5424.76,
        17.55,
        8.24,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '57') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '406'\n  AND m.movie_id <= '478'\n  AND t.production_year = '1968'\n  AND c.nr_order = '57'\nGROUP BY m.movie_id;": [
        3180.63,
        2242.89,
        2240.45,
        2239.18,
        2237.35,
        2229.21,
        2156.76,
        9.56,
        8.39,
        72.44,
        8.08,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '369') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '123'\n  AND m.movie_id <= '316'\n  AND t.production_year = '1911'\n  AND c.nr_order = '369'\nGROUP BY m.movie_id;": [
        6193.93,
        5256.2,
        5253.76,
        5252.49,
        5250.65,
        5237.77,
        5131.84,
        16.83,
        8.25,
        105.92,
        12.82,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '461') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '15'\n  AND m.movie_id <= '216'\n  AND t.production_year = '1931'\n  AND c.nr_order = '461'\nGROUP BY m.movie_id;": [
        6406.85,
        5469.12,
        5466.68,
        5465.41,
        5463.57,
        5447.81,
        5327.12,
        17.32,
        8.25,
        120.67,
        15.71,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '127') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '149'\n  AND m.movie_id <= '224'\n  AND t.production_year = '1926'\n  AND c.nr_order = '127'\nGROUP BY m.movie_id;": [
        3226.54,
        2288.81,
        2286.37,
        2285.1,
        2252.24,
        2250.4,
        2232.99,
        9.74,
        8.39,
        17.35,
        1.84,
        32.85,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '444') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '15'\n  AND m.movie_id <= '219'\n  AND t.production_year = '1929'\n  AND c.nr_order = '444'\nGROUP BY m.movie_id;": [
        6458.63,
        5520.9,
        5518.46,
        5517.19,
        5515.35,
        5416.76,
        5399.35,
        17.5,
        8.24,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '459') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '14'\n  AND m.movie_id <= '220'\n  AND t.production_year = '1937'\n  AND c.nr_order = '459'\nGROUP BY m.movie_id;": [
        6528.57,
        5590.83,
        5588.39,
        5587.12,
        5585.29,
        5569.74,
        5450.17,
        17.61,
        8.24,
        119.56,
        15.49,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '444') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '12'\n  AND m.movie_id <= '221'\n  AND t.production_year = '1932'\n  AND c.nr_order = '444'\nGROUP BY m.movie_id;": [
        6597.46,
        5659.72,
        5657.28,
        5656.01,
        5654.18,
        5638.52,
        5518.4,
        17.79,
        8.23,
        120.11,
        15.59,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '387') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '213'\n  AND m.movie_id <= '431'\n  AND t.production_year = '1950'\n  AND c.nr_order = '387'\nGROUP BY m.movie_id;": [
        6798.27,
        5860.53,
        5858.09,
        5856.82,
        5854.99,
        5841.89,
        5735.09,
        18.33,
        8.23,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1030') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '30'\n  AND m.movie_id <= '186'\n  AND t.production_year = '1990'\n  AND c.nr_order = '1030'\nGROUP BY m.movie_id;": [
        5411.67,
        4473.94,
        4471.5,
        4470.23,
        4468.39,
        4461.66,
        4231.67,
        14.62,
        8.28,
        57.49,
        6.67,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '390') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '220'\n  AND m.movie_id <= '428'\n  AND t.production_year = '1950'\n  AND c.nr_order = '390'\nGROUP BY m.movie_id;": [
        6556.17,
        5618.43,
        5615.99,
        5614.72,
        5612.89,
        5599.79,
        5492.99,
        17.73,
        8.23,
        106.79,
        13.04,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '370') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '125'\n  AND m.movie_id <= '313'\n  AND t.production_year = '1915'\n  AND c.nr_order = '370'\nGROUP BY m.movie_id;": [
        6160.04,
        5222.31,
        5219.87,
        5218.6,
        5216.76,
        5205.52,
        5008.79,
        16.54,
        8.25,
        98.35,
        11.18,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '263') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '81'\n  AND m.movie_id <= '280'\n  AND t.production_year = '1941'\n  AND c.nr_order = '263'\nGROUP BY m.movie_id;": [
        6335.58,
        5397.85,
        5395.41,
        5394.14,
        5392.3,
        5293.71,
        5276.3,
        17.19,
        8.24,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '409') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '1') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '1') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '216'\n  AND m.movie_id <= '433'\n  AND t.production_year = '1952'\n  AND c.nr_order = '409'\nGROUP BY m.movie_id;": [
        6869.91,
        5932.18,
        5929.74,
        5928.47,
        5926.63,
        5914.94,
        5713.68,
        18.27,
        8.23,
        100.62,
        11.63,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '1802') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '379'\n  AND m.movie_id <= '461'\n  AND t.production_year = '1958'\n  AND c.nr_order = '1802'\nGROUP BY m.movie_id;": [
        3443.72,
        2505.98,
        2503.54,
        2502.27,
        2500.44,
        2490.85,
        2402.86,
        10.15,
        8.37,
        87.98,
        9.52,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '276') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '77'\n  AND m.movie_id <= '280'\n  AND t.production_year = '1943'\n  AND c.nr_order = '276'\nGROUP BY m.movie_id;": [
        6433.22,
        5495.49,
        5493.05,
        5491.78,
        5489.94,
        5391.35,
        5373.94,
        17.43,
        8.24,
        17.35,
        32.85,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:05:09\n-- Operation: both\n-- Old Join Path: movie_info m -> title t -> cast_info c -> role_type r -> movie_companies mc -> company_name cn -> movie_info m2\n-- New Join Path: company_name cn -> movie_companies mc -> movie_info m -> title t -> cast_info c -> role_type r -> movie_info m2\n-- Table Size Changes: Reordered the joins to start with the smaller company_name (29 MB) and movie_companies (282 MB) before joining the larger tables (movie_info ~1831 MB, cast_info ~3881 MB) to reduce the scanned rows early.\n-- Structural Changes: Added an extra predicate on cast_info (c.nr_order = '26002') and refined the nested query by including a predicate on movie_companies (mc2.company_type_id = '2') to increase selectivity.\n-- LLM Reasoning: To push the execution cost into the target range [4000.0, 5000.0], I both re-ordered the join path and added more selective filters. Starting from a smaller table minimizes the intermediate result set and applying selective predicates on high-cardinality tables reduces overall cost. These changes, while retaining the required tables and structure including the nested aggregated subquery, aim to curtail the cost significantly.\n\n-- SQL Template Metadata\n-- Template ID: 20 Refined\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 6\n--   Number of Joins: 6\n--   Number of Aggregations: 5\n--   Semantic Requirement: The query should have a nested query with aggregation, at least two predicate values to fill.\n--   Tables Involved: [movie_info, title, cast_info, role_type, movie_companies, company_name]\n\nSELECT m.movie_id,\n       COUNT(c.id) AS cast_info_count, -- Aggregation 1\n MIN(t.production_year) AS min_production_year, -- Aggregation 2\n MAX(t.production_year) AS max_production_year, -- Aggregation 3\n AVG(r.id) AS avg_role_id, -- Aggregation 4\n\n  (SELECT SUM(mc2.company_id) -- Aggregation 5 via nested query\n\n   FROM movie_companies mc2\n   WHERE mc2.movie_id = m.movie_id\n     AND mc2.company_type_id = '2') AS nested_sum_company_id\nFROM company_name cn\nJOIN movie_companies mc ON cn.id = mc.company_id\nJOIN movie_info m ON m.movie_id = mc.movie_id\nJOIN title t ON m.movie_id = t.id\nJOIN cast_info c ON m.movie_id = c.movie_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_info m2 ON m.movie_id = m2.movie_id\nWHERE m.movie_id >= '26'\n  AND m.movie_id <= '219'\n  AND t.production_year = '1971'\n  AND c.nr_order = '26002'\nGROUP BY m.movie_id;": [
        6302.83,
        5365.1,
        5362.66,
        5361.39,
        5359.55,
        5351.34,
        5131.84,
        16.83,
        8.25,
        73.16,
        8.15,
        1.84,
        1.12,
        1.94,
        21.29,
        21.27
    ]
}