{
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2'\n  AND mk.movie_id <= '2'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        379.9,
        379.11,
        377.08,
        9.4,
        8.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '887'\n  AND mk.movie_id <= '5258'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5122.81,
        5078.53,
        4479.66,
        232.79,
        83.46
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1091'\n  AND mk.movie_id <= '3871'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5008.77,
        4980.33,
        4479.66,
        145.9,
        55.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '963'\n  AND mk.movie_id <= '1069'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        839.7,
        837.85,
        833.08,
        10.7,
        7.76
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3834'\n  AND mk.movie_id <= '5009'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3841.42,
        3828.94,
        3796.93,
        26.69,
        5.4,
        5.39
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '918'\n  AND mk.movie_id <= '1025'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        839.7,
        837.85,
        833.08,
        10.7,
        7.76
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '591'\n  AND mk.movie_id <= '4664'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5101.87,
        5060.57,
        4479.66,
        216.96,
        78.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '818'\n  AND mk.movie_id <= '979'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1055.87,
        1053.47,
        1047.3,
        11.37,
        7.56
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1667'\n  AND mk.movie_id <= '2911'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3968.34,
        3955.18,
        3921.45,
        28.53,
        5.29,
        5.28
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '465'\n  AND mk.movie_id <= '2921'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4986.8,
        4961.58,
        4479.66,
        129.45,
        50.25
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2639'\n  AND mk.movie_id <= '3852'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3917.02,
        3904.16,
        3871.19,
        27.17,
        5.35,
        5.34
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '967'\n  AND mk.movie_id <= '4035'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5028.58,
        4997.27,
        4479.66,
        160.8,
        59.67
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '901'\n  AND mk.movie_id <= '3845'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5020.54,
        4990.45,
        4479.66,
        154.85,
        58.18
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '4739'\n  AND mk.movie_id <= '4948'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1237.95,
        1235.08,
        1227.7,
        11.95,
        7.41
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1400'\n  AND mk.movie_id <= '5258'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5087.62,
        5048.45,
        4479.66,
        206.36,
        76.24
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '64'\n  AND mk.movie_id <= '3842'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5081.37,
        5042.99,
        4479.66,
        201.46,
        74.28
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2071'\n  AND mk.movie_id <= '2079'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        418.5,
        417.63,
        415.38,
        9.5,
        8.12
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '327'\n  AND mk.movie_id <= '2040'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4515.49,
        4497.66,
        39.24,
        4.51,
        4.5
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '992'\n  AND mk.movie_id <= '1057'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        663.19,
        661.75,
        658.06,
        10.19,
        7.9
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1389'\n  AND mk.movie_id <= '1417'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        508.24,
        507.17,
        504.43,
        9.74,
        8.11
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '975'\n  AND mk.movie_id <= '1621'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2613.8,
        2606.59,
        2588.08,
        19.25,
        6.31,
        6.3
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '24'\n  AND mk.movie_id <= '3837'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5083.58,
        5044.87,
        4479.66,
        203.11,
        74.69
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '22'\n  AND mk.movie_id <= '3849'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5085.52,
        5046.67,
        4479.66,
        204.8,
        75.86
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '11'\n  AND mk.movie_id <= '4707'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5149.48,
        5101.99,
        4479.66,
        253.95,
        92.38
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '22'\n  AND mk.movie_id <= '4729'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5150.31,
        5102.69,
        4479.66,
        254.56,
        92.53
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '989'\n  AND mk.movie_id <= '1668'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2735.13,
        2727.58,
        2708.22,
        19.66,
        6.24
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '318'\n  AND mk.movie_id <= '2037'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4521.27,
        4503.38,
        39.3,
        4.5,
        4.49
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '327'\n  AND mk.movie_id <= '936'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2542.27,
        2535.43,
        2517.87,
        18.8,
        6.39
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '419'\n  AND mk.movie_id <= '2920'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4989.75,
        4964.08,
        4479.66,
        131.63,
        50.8
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '590'\n  AND mk.movie_id <= '1080'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2190.34,
        2184.67,
        2170.12,
        16.37,
        6.65
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '592'\n  AND mk.movie_id <= '1080'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2189.81,
        2184.16,
        2169.66,
        16.35,
        6.67
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '22'\n  AND mk.movie_id <= '44'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        482.67,
        481.66,
        479.05,
        9.67,
        8.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '114'\n  AND mk.movie_id <= '387'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1469.72,
        1466.22,
        1457.22,
        13.72,
        7.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '901'\n  AND mk.movie_id <= '3842'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5020.31,
        4990.26,
        4479.66,
        154.68,
        58.14
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '903'\n  AND mk.movie_id <= '5258'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5121.63,
        5077.53,
        4479.66,
        231.92,
        83.25
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1046'\n  AND mk.movie_id <= '1557'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2256.59,
        2250.71,
        2235.63,
        16.63,
        6.6
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '118'\n  AND mk.movie_id <= '399'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1504.32,
        1500.74,
        1491.51,
        13.82,
        7.21
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '954'\n  AND mk.movie_id <= '1856'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3262.15,
        3252.38,
        3227.34,
        23.38,
        5.83,
        5.82
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '951'\n  AND mk.movie_id <= '1857'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3271.29,
        3261.49,
        3236.36,
        23.42,
        5.83,
        5.82
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '975'\n  AND mk.movie_id <= '1897'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3302.72,
        3292.76,
        3267.22,
        23.61,
        5.8,
        5.79
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '975'\n  AND mk.movie_id <= '1865'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3233.11,
        3223.47,
        3198.71,
        22.23,
        5.86,
        5.85
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '419'\n  AND mk.movie_id <= '2914'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4989.3,
        4963.69,
        4479.66,
        131.29,
        50.72
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '466'\n  AND mk.movie_id <= '2920'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4986.68,
        4961.48,
        4479.66,
        129.37,
        50.23
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '318'\n  AND mk.movie_id <= '2068'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4555.31,
        4537.11,
        39.68,
        4.46,
        4.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '22'\n  AND mk.movie_id <= '908'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3220.04,
        3210.43,
        3185.76,
        22.19,
        5.85,
        5.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '965'\n  AND mk.movie_id <= '3083'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4942.81,
        4920.95,
        45.15,
        4.05,
        4.04
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '963'\n  AND mk.movie_id <= '2909'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4766.29,
        4746.15,
        43.06,
        4.23,
        4.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '984'\n  AND mk.movie_id <= '5006'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5098.48,
        5057.69,
        4479.66,
        214.43,
        78.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '959'\n  AND mk.movie_id <= '2872'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4732.0,
        4712.17,
        42.67,
        4.26,
        4.25
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '970'\n  AND mk.movie_id <= '3191'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4971.74,
        4948.85,
        4479.66,
        118.39,
        47.41
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1011'\n  AND mk.movie_id <= '2280'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4004.27,
        3990.85,
        3956.44,
        28.85,
        5.23,
        5.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1013'\n  AND mk.movie_id <= '2079'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3617.49,
        3606.1,
        3576.88,
        25.37,
        5.56,
        5.55
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1627'\n  AND mk.movie_id <= '2918'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4030.46,
        4016.83,
        3981.88,
        29.1,
        5.19,
        5.18
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1057'\n  AND mk.movie_id <= '1551'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2203.38,
        2197.67,
        2183.04,
        16.41,
        6.65
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2070'\n  AND mk.movie_id <= '2279'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1237.95,
        1235.08,
        1227.7,
        11.95,
        7.41
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '909'\n  AND mk.movie_id <= '1051'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        982.13,
        979.93,
        974.26,
        11.13,
        7.64
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '334'\n  AND mk.movie_id <= '334'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        379.9,
        379.11,
        377.08,
        9.4,
        8.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '284'\n  AND mk.movie_id <= '419'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        952.05,
        949.91,
        944.42,
        11.05,
        7.65
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1796'\n  AND mk.movie_id <= '2636'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3114.91,
        3105.75,
        3082.25,
        21.63,
        5.94,
        5.93
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1832'\n  AND mk.movie_id <= '2638'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3029.43,
        3020.62,
        2998.02,
        21.2,
        6.0,
        5.99
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '907'\n  AND mk.movie_id <= '2627'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4521.9,
        4504.0,
        39.32,
        4.5,
        4.49
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '302'\n  AND mk.movie_id <= '582'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1499.8,
        1496.23,
        1487.05,
        13.8,
        7.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '908'\n  AND mk.movie_id <= '2638'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4537.31,
        4519.31,
        39.45,
        4.49,
        4.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2685'\n  AND mk.movie_id <= '4921'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4972.65,
        4949.62,
        4479.66,
        119.05,
        47.58
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1045'\n  AND mk.movie_id <= '1049'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        405.46,
        404.62,
        402.46,
        9.46,
        8.19
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '302'\n  AND mk.movie_id <= '2040'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4539.26,
        4521.18,
        39.53,
        4.47,
        4.46
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '228'\n  AND mk.movie_id <= '2040'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4626.73,
        4607.92,
        40.43,
        4.38,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2599'\n  AND mk.movie_id <= '5226'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4998.83,
        4971.92,
        4479.66,
        138.58,
        53.32
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '595'\n  AND mk.movie_id <= '1023'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1996.12,
        1991.06,
        1978.06,
        15.62,
        6.79
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1576'\n  AND mk.movie_id <= '2918'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4099.24,
        4085.1,
        4048.85,
        29.72,
        5.09,
        5.08
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '928'\n  AND mk.movie_id <= '3268'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4979.32,
        4955.25,
        4479.66,
        123.95,
        48.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '924'\n  AND mk.movie_id <= '3268'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4979.54,
        4955.44,
        4479.66,
        124.12,
        48.88
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1003'\n  AND mk.movie_id <= '2280'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4014.73,
        4001.24,
        3966.65,
        28.93,
        5.22,
        5.21
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '118'\n  AND mk.movie_id <= '3800'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5074.97,
        5037.55,
        4479.66,
        196.71,
        73.11
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1600'\n  AND mk.movie_id <= '2924'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4073.09,
        4059.12,
        4023.32,
        29.51,
        5.12,
        5.11
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1015'\n  AND mk.movie_id <= '3864'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5013.34,
        4984.21,
        4479.66,
        149.28,
        56.03
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1570'\n  AND mk.movie_id <= '2913'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4103.81,
        4089.65,
        4053.35,
        29.75,
        5.09,
        5.08
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '302'\n  AND mk.movie_id <= '951'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2622.94,
        2615.7,
        2597.1,
        19.3,
        6.3,
        6.29
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1054'\n  AND mk.movie_id <= '2920'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4679.83,
        4660.48,
        41.09,
        4.32,
        4.31
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1064'\n  AND mk.movie_id <= '2685'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4455.05,
        4438.13,
        4394.79,
        38.12,
        4.63,
        4.62
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1632'\n  AND mk.movie_id <= '4440'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5010.6,
        4981.88,
        4479.66,
        147.25,
        55.52
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1086'\n  AND mk.movie_id <= '2382'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4036.36,
        4022.68,
        3987.59,
        29.17,
        5.18,
        5.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '398'\n  AND mk.movie_id <= '2068'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4510.66,
        4493.26,
        4448.71,
        38.7,
        4.57,
        4.56
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1085'\n  AND mk.movie_id <= '2600'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4322.24,
        4306.38,
        4265.75,
        35.82,
        4.8,
        4.79
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1564'\n  AND mk.movie_id <= '2910'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4104.47,
        4090.3,
        4053.95,
        29.77,
        5.08,
        5.07
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '909'\n  AND mk.movie_id <= '1073'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1064.39,
        1061.97,
        1055.76,
        11.39,
        7.57
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '227'\n  AND mk.movie_id <= '2069'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4655.9,
        4636.79,
        40.8,
        4.35,
        4.34
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1627'\n  AND mk.movie_id <= '2925'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4040.93,
        4027.22,
        3992.09,
        29.19,
        5.18,
        5.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '966'\n  AND mk.movie_id <= '2968'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4824.67,
        4803.97,
        43.74,
        4.17,
        4.16
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '925'\n  AND mk.movie_id <= '3201'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4975.24,
        4951.81,
        4479.66,
        120.96,
        48.07
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1024'\n  AND mk.movie_id <= '3191'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4987.25,
        4964.91,
        45.75,
        4.0,
        3.99
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '923'\n  AND mk.movie_id <= '3279'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4980.33,
        4956.11,
        4479.66,
        124.7,
        49.03
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '967'\n  AND mk.movie_id <= '3037'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4895.1,
        4873.71,
        44.57,
        4.1,
        4.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1862'\n  AND mk.movie_id <= '4745'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5016.52,
        4987.05,
        4479.66,
        151.89,
        57.43
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '318'\n  AND mk.movie_id <= '2025'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4509.71,
        4491.95,
        39.15,
        4.52,
        4.51
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '4250'\n  AND mk.movie_id <= '4758'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2247.55,
        2241.7,
        2226.71,
        16.58,
        6.62
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2668'\n  AND mk.movie_id <= '4920'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4973.66,
        4950.48,
        4479.66,
        119.8,
        47.77
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '586'\n  AND mk.movie_id <= '2834'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4973.44,
        4950.28,
        4479.66,
        119.63,
        47.73
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2293'\n  AND mk.movie_id <= '5225'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5019.73,
        4989.77,
        4479.66,
        154.26,
        58.03
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '4738'\n  AND mk.movie_id <= '4920'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1142.12,
        1139.52,
        1132.81,
        11.62,
        7.52
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3841'\n  AND mk.movie_id <= '5022'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3851.19,
        3838.66,
        3806.54,
        26.76,
        5.39,
        5.38
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1627'\n  AND mk.movie_id <= '2910'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4015.43,
        4001.88,
        3967.16,
        29.0,
        5.21,
        5.2
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '334'\n  AND mk.movie_id <= '2025'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4488.53,
        4470.92,
        38.96,
        4.54,
        4.53
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '927'\n  AND mk.movie_id <= '3279'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4980.11,
        4955.92,
        4479.66,
        124.53,
        48.99
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '919'\n  AND mk.movie_id <= '3279'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4980.67,
        4956.4,
        4479.66,
        124.95,
        49.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '931'\n  AND mk.movie_id <= '3201'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4974.79,
        4951.43,
        4479.66,
        120.63,
        47.98
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '972'\n  AND mk.movie_id <= '3279'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4977.17,
        4953.44,
        4479.66,
        122.37,
        48.43
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2800'\n  AND mk.movie_id <= '4948'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4968.78,
        4946.63,
        45.51,
        4.02,
        4.01
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1007'\n  AND mk.movie_id <= '2279'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4004.93,
        3991.49,
        3957.04,
        28.87,
        5.23,
        5.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '371'\n  AND mk.movie_id <= '2071'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4499.44,
        4481.75,
        39.06,
        4.53,
        4.52
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '228'\n  AND mk.movie_id <= '2070'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4655.9,
        4636.79,
        40.8,
        4.35,
        4.34
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1012'\n  AND mk.movie_id <= '2279'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3999.04,
        3985.65,
        3951.33,
        28.81,
        5.24,
        5.23
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2608'\n  AND mk.movie_id <= '5211'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4997.35,
        4970.66,
        4479.66,
        137.48,
        53.04
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '399'\n  AND mk.movie_id <= '2914'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4990.66,
        4964.85,
        4479.66,
        132.29,
        50.97
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1060'\n  AND mk.movie_id <= '2924'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4679.19,
        4659.85,
        41.07,
        4.32,
        4.31
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1590'\n  AND mk.movie_id <= '2910'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4067.19,
        4053.27,
        4017.6,
        29.45,
        5.14,
        5.13
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '967'\n  AND mk.movie_id <= '2925'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4782.34,
        4762.07,
        43.21,
        4.22,
        4.21
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2018'\n  AND mk.movie_id <= '4033'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4837.21,
        4816.37,
        43.91,
        4.15,
        4.14
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1064'\n  AND mk.movie_id <= '2281'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3922.26,
        3909.36,
        3876.3,
        27.21,
        5.34,
        5.33
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1014'\n  AND mk.movie_id <= '2279'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3994.47,
        3981.1,
        3946.83,
        28.78,
        5.24,
        5.23
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1076'\n  AND mk.movie_id <= '3585'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4990.21,
        4964.46,
        4479.66,
        131.96,
        50.89
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '919'\n  AND mk.movie_id <= '3191'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4975.02,
        4951.62,
        4479.66,
        120.79,
        48.03
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2558'\n  AND mk.movie_id <= '5107'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4993.82,
        4967.67,
        4479.66,
        134.88,
        52.38
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1087'\n  AND mk.movie_id <= '2281'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3883.83,
        3871.16,
        3838.68,
        26.93,
        5.38,
        5.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1008'\n  AND mk.movie_id <= '2293'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4020.66,
        4007.08,
        3972.27,
        29.04,
        5.2,
        5.19
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '114'\n  AND mk.movie_id <= '2079'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4784.56,
        4764.22,
        43.29,
        4.21,
        4.2
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2786'\n  AND mk.movie_id <= '4877'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4914.13,
        4892.54,
        44.83,
        4.07,
        4.06
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2668'\n  AND mk.movie_id <= '4903'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4972.65,
        4949.62,
        4479.66,
        119.05,
        47.58
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1007'\n  AND mk.movie_id <= '2070'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3612.27,
        3600.91,
        3571.77,
        25.33,
        5.57,
        5.56
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2600'\n  AND mk.movie_id <= '5258'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5000.88,
        4973.65,
        4479.66,
        140.09,
        53.7
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2018'\n  AND mk.movie_id <= '4028'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4831.44,
        4810.65,
        43.85,
        4.16,
        4.15
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1074'\n  AND mk.movie_id <= '3585'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4990.32,
        4964.56,
        4479.66,
        132.04,
        50.91
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1636'\n  AND mk.movie_id <= '3852'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4971.41,
        4948.57,
        4479.66,
        118.14,
        47.34
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1677'\n  AND mk.movie_id <= '3851'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4993.68,
        4971.26,
        45.83,
        3.99,
        3.98
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1065'\n  AND mk.movie_id <= '5268'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5111.54,
        5068.94,
        4479.66,
        224.4,
        81.42
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1857'\n  AND mk.movie_id <= '4039'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5003.94,
        4981.45,
        45.92,
        3.99,
        3.98
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1067'\n  AND mk.movie_id <= '5266'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5111.3,
        5068.74,
        4479.66,
        224.23,
        81.38
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1818'\n  AND mk.movie_id <= '5259'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5058.06,
        5023.04,
        4479.66,
        183.92,
        69.19
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1807'\n  AND mk.movie_id <= '5262'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5058.99,
        5023.83,
        4479.66,
        184.6,
        69.36
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1045'\n  AND mk.movie_id <= '1054'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        418.5,
        417.63,
        415.38,
        9.5,
        8.12
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1065'\n  AND mk.movie_id <= '3037'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4794.83,
        4774.42,
        43.38,
        4.2,
        4.19
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1070'\n  AND mk.movie_id <= '1080'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        427.02,
        426.13,
        423.84,
        9.52,
        8.12
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '318'\n  AND mk.movie_id <= '1041'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2820.61,
        2812.63,
        2792.15,
        20.2,
        6.16,
        6.15
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2018'\n  AND mk.movie_id <= '4006'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4807.98,
        4787.42,
        43.57,
        4.18,
        4.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '989'\n  AND mk.movie_id <= '2304'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4061.95,
        4048.07,
        4012.49,
        29.4,
        5.14,
        5.13
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1020'\n  AND mk.movie_id <= '3532'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4990.43,
        4964.65,
        4479.66,
        132.13,
        50.93
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1006'\n  AND mk.movie_id <= '2279'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4009.5,
        3996.04,
        3961.54,
        28.89,
        5.23,
        5.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1632'\n  AND mk.movie_id <= '2930'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4040.93,
        4027.22,
        3992.09,
        29.19,
        5.18,
        5.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1025'\n  AND mk.movie_id <= '3201'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4998.16,
        4975.73,
        45.85,
        4.0,
        3.99
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1012'\n  AND mk.movie_id <= '2820'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4621.59,
        4602.82,
        40.39,
        4.39,
        4.38
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '965'\n  AND mk.movie_id <= '4496'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5064.97,
        5029.06,
        4479.66,
        189.3,
        71.28
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1085'\n  AND mk.movie_id <= '2558'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4268.98,
        4253.55,
        4214.0,
        31.31,
        4.86,
        4.85
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1062'\n  AND mk.movie_id <= '2839'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4587.48,
        4569.02,
        40.0,
        4.43,
        4.42
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1077'\n  AND mk.movie_id <= '3679'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4997.24,
        4970.57,
        4479.66,
        137.4,
        53.02
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '595'\n  AND mk.movie_id <= '4426'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5085.87,
        5046.96,
        4479.66,
        205.06,
        75.92
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '887'\n  AND mk.movie_id <= '4802'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5091.35,
        5051.63,
        4479.66,
        209.14,
        76.93
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '114'\n  AND mk.movie_id <= '1059'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3358.22,
        3348.04,
        3321.92,
        23.89,
        5.76,
        5.75
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1075'\n  AND mk.movie_id <= '3679'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4997.35,
        4970.66,
        4479.66,
        137.48,
        53.04
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3083'\n  AND mk.movie_id <= '4737'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4489.05,
        4471.82,
        4427.67,
        38.51,
        4.59,
        4.58
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3201'\n  AND mk.movie_id <= '4738'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4354.29,
        4338.21,
        4297.0,
        36.1,
        4.76,
        4.75
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2304'\n  AND mk.movie_id <= '4658'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4980.22,
        4956.02,
        4479.66,
        124.61,
        49.01
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1065'\n  AND mk.movie_id <= '2854'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4595.27,
        4576.68,
        40.15,
        4.41,
        4.4
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '388'\n  AND mk.movie_id <= '921'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2318.85,
        2312.76,
        2297.13,
        16.88,
        6.55
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '11'\n  AND mk.movie_id <= '582'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2430.32,
        2423.85,
        2407.23,
        17.36,
        6.46
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '106'\n  AND mk.movie_id <= '2076'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4790.33,
        4769.95,
        43.35,
        4.2,
        4.19
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '945'\n  AND mk.movie_id <= '3281'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4979.09,
        4955.06,
        4479.66,
        123.78,
        48.8
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1017'\n  AND mk.movie_id <= '3329'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4977.5,
        4953.72,
        4479.66,
        122.62,
        48.5
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2018'\n  AND mk.movie_id <= '4035'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4841.7,
        4820.84,
        43.93,
        4.15,
        4.14
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1086'\n  AND mk.movie_id <= '2293'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3907.99,
        3895.2,
        3862.41,
        27.08,
        5.36,
        5.35
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '917'\n  AND mk.movie_id <= '3268'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4979.99,
        4955.83,
        4479.66,
        124.45,
        48.97
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2607'\n  AND mk.movie_id <= '4659'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4873.28,
        4852.07,
        44.36,
        4.11,
        4.1
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1031'\n  AND mk.movie_id <= '3283'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4973.66,
        4950.48,
        4479.66,
        119.8,
        47.77
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '960'\n  AND mk.movie_id <= '2685'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4527.67,
        4509.72,
        39.38,
        4.49,
        4.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1026'\n  AND mk.movie_id <= '3328'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4976.94,
        4953.24,
        4479.66,
        122.2,
        48.39
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2018'\n  AND mk.movie_id <= '4739'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5004.99,
        4977.13,
        4479.66,
        143.12,
        54.47
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1018'\n  AND mk.movie_id <= '2668'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4488.4,
        4471.2,
        4427.14,
        38.47,
        4.59,
        4.58
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2006'\n  AND mk.movie_id <= '4028'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4842.99,
        4822.1,
        43.97,
        4.15,
        4.14
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '926'\n  AND mk.movie_id <= '5013'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5102.81,
        5061.37,
        4479.66,
        217.65,
        79.01
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1016'\n  AND mk.movie_id <= '2627'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4439.37,
        4422.55,
        4379.48,
        38.0,
        4.65,
        4.64
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1897'\n  AND mk.movie_id <= '4739'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5012.89,
        4983.82,
        4479.66,
        148.94,
        55.94
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1072'\n  AND mk.movie_id <= '4027'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5021.23,
        4991.04,
        4479.66,
        155.36,
        58.31
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2607'\n  AND mk.movie_id <= '5211'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4997.35,
        4970.66,
        4479.66,
        137.48,
        53.04
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '937'\n  AND mk.movie_id <= '3845'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5018.13,
        4988.41,
        4479.66,
        153.07,
        57.73
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '464'\n  AND mk.movie_id <= '944'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2159.24,
        2153.68,
        2139.37,
        16.24,
        6.68
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '979'\n  AND mk.movie_id <= '999'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        474.15,
        473.16,
        470.59,
        9.65,
        8.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2627'\n  AND mk.movie_id <= '5022'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4982.83,
        4958.22,
        4479.66,
        126.53,
        49.5
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2599'\n  AND mk.movie_id <= '5012'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4984.07,
        4959.28,
        4479.66,
        127.45,
        49.74
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2608'\n  AND mk.movie_id <= '4555'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4766.93,
        4746.77,
        43.08,
        4.23,
        4.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '943'\n  AND mk.movie_id <= '3281'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4979.2,
        4955.16,
        4479.66,
        123.87,
        48.82
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1016'\n  AND mk.movie_id <= '3342'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4978.41,
        4954.49,
        4479.66,
        123.28,
        48.67
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '918'\n  AND mk.movie_id <= '3281'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4980.79,
        4956.5,
        4479.66,
        125.03,
        49.12
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '925'\n  AND mk.movie_id <= '3328'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4983.39,
        4958.7,
        4479.66,
        126.95,
        49.61
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '917'\n  AND mk.movie_id <= '3083'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4986.61,
        4964.28,
        45.73,
        4.01,
        4.0
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '938'\n  AND mk.movie_id <= '947'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        418.5,
        417.63,
        415.38,
        9.5,
        8.12
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '919'\n  AND mk.movie_id <= '3268'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4979.88,
        4955.73,
        4479.66,
        124.37,
        48.95
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1565'\n  AND mk.movie_id <= '2911'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4104.47,
        4090.3,
        4053.95,
        29.77,
        5.08,
        5.07
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1618'\n  AND mk.movie_id <= '2911'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4031.13,
        4017.48,
        3982.48,
        29.13,
        5.19,
        5.18
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3037'\n  AND mk.movie_id <= '4731'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4493.66,
        4476.02,
        39.0,
        4.53,
        4.52
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1565'\n  AND mk.movie_id <= '2640'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3640.34,
        3628.86,
        3599.41,
        25.48,
        5.55,
        5.54
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2685'\n  AND mk.movie_id <= '4032'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4109.04,
        4094.84,
        4058.45,
        29.79,
        5.08,
        5.07
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2800'\n  AND mk.movie_id <= '4006'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3907.99,
        3895.2,
        3862.41,
        27.08,
        5.36,
        5.35
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '908'\n  AND mk.movie_id <= '2614'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4509.71,
        4491.95,
        39.15,
        4.52,
        4.51
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1015'\n  AND mk.movie_id <= '1668'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2636.03,
        2628.75,
        2610.07,
        19.34,
        6.3,
        6.29
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '903'\n  AND mk.movie_id <= '2627'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4527.04,
        4509.1,
        39.36,
        4.49,
        4.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1632'\n  AND mk.movie_id <= '2880'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3972.87,
        3959.66,
        3925.79,
        28.59,
        5.28,
        5.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2786'\n  AND mk.movie_id <= '4859'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4895.74,
        4874.34,
        44.59,
        4.09,
        4.08
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2614'\n  AND mk.movie_id <= '4566'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4776.56,
        4756.35,
        43.14,
        4.22,
        4.21
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2304'\n  AND mk.movie_id <= '4609'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4977.05,
        4953.34,
        4479.66,
        122.29,
        48.41
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2006'\n  AND mk.movie_id <= '4031'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4848.13,
        4827.2,
        44.02,
        4.14,
        4.13
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2006'\n  AND mk.movie_id <= '4035'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4853.26,
        4832.29,
        44.06,
        4.14,
        4.13
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1087'\n  AND mk.movie_id <= '3992'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5017.9,
        4988.22,
        4479.66,
        152.9,
        57.69
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3190'\n  AND mk.movie_id <= '4738'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4362.37,
        4346.18,
        4304.69,
        37.23,
        4.74,
        4.73
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2640'\n  AND mk.movie_id <= '5229'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4996.44,
        4969.89,
        4479.66,
        136.81,
        52.87
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1068'\n  AND mk.movie_id <= '2304'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3957.88,
        3944.79,
        3911.24,
        28.44,
        5.3,
        5.29
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2600'\n  AND mk.movie_id <= '2921'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1644.31,
        1640.32,
        1630.06,
        14.31,
        7.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2607'\n  AND mk.movie_id <= '2929'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1644.31,
        1640.32,
        1630.06,
        14.31,
        7.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1071'\n  AND mk.movie_id <= '1861'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2988.29,
        2979.64,
        2957.45,
        21.01,
        6.03,
        6.02
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '654'\n  AND mk.movie_id <= '3556'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5017.78,
        4988.12,
        4479.66,
        152.82,
        57.67
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1070'\n  AND mk.movie_id <= '1864'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3002.0,
        2993.3,
        2970.97,
        21.07,
        6.02,
        6.01
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3863'\n  AND mk.movie_id <= '5007'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3776.3,
        3764.14,
        3732.94,
        26.31,
        5.44,
        5.43
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1013'\n  AND mk.movie_id <= '1832'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3060.04,
        3051.1,
        3028.14,
        21.37,
        5.97,
        5.96
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1065'\n  AND mk.movie_id <= '2834'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4577.21,
        4558.81,
        39.92,
        4.44,
        4.43
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1063'\n  AND mk.movie_id <= '2834'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4577.84,
        4559.43,
        39.94,
        4.43,
        4.42
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1086'\n  AND mk.movie_id <= '1594'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2247.55,
        2241.7,
        2226.71,
        16.58,
        6.62
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '996'\n  AND mk.movie_id <= '3845'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5013.34,
        4984.21,
        4479.66,
        149.28,
        56.03
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1017'\n  AND mk.movie_id <= '2636'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4449.83,
        4432.94,
        4389.69,
        38.08,
        4.64,
        4.63
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1016'\n  AND mk.movie_id <= '2668'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4492.95,
        4475.73,
        4431.63,
        38.49,
        4.59,
        4.58
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1086'\n  AND mk.movie_id <= '2636'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4366.92,
        4350.72,
        4309.19,
        37.25,
        4.74,
        4.73
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '903'\n  AND mk.movie_id <= '2640'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4538.62,
        4520.56,
        39.51,
        4.48,
        4.47
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3279'\n  AND mk.movie_id <= '4734'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4242.83,
        4227.57,
        4188.47,
        31.09,
        4.89,
        4.88
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1576'\n  AND mk.movie_id <= '4651'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5033.04,
        5001.66,
        4479.66,
        165.14,
        63.76
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3083'\n  AND mk.movie_id <= '4732'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4487.72,
        4470.54,
        4426.52,
        38.44,
        4.6,
        4.59
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1086'\n  AND mk.movie_id <= '2607'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4332.7,
        4316.78,
        4275.97,
        35.91,
        4.79,
        4.78
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3190'\n  AND mk.movie_id <= '4731'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4354.78,
        4338.66,
        4297.36,
        36.14,
        4.76,
        4.75
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1632'\n  AND mk.movie_id <= '2931'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4041.59,
        4027.87,
        3992.7,
        29.21,
        5.17,
        5.16
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '399'\n  AND mk.movie_id <= '2929'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4992.57,
        4966.62,
        4479.66,
        133.96,
        52.14
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '970'\n  AND mk.movie_id <= '1013'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        572.93,
        571.71,
        568.56,
        9.93,
        7.98
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '647'\n  AND mk.movie_id <= '2800'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4974.56,
        4952.35,
        45.58,
        4.02,
        4.01
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '64'\n  AND mk.movie_id <= '2861'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5009.91,
        4981.3,
        4479.66,
        146.74,
        55.39
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '50'\n  AND mk.movie_id <= '2861'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5010.82,
        4982.07,
        4479.66,
        147.42,
        55.56
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1018'\n  AND mk.movie_id <= '3532'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4990.55,
        4964.75,
        4479.66,
        132.21,
        50.95
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2304'\n  AND mk.movie_id <= '4453'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4969.43,
        4947.26,
        45.53,
        4.02,
        4.01
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2037'\n  AND mk.movie_id <= '3872'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4649.96,
        4630.92,
        40.71,
        4.36,
        4.35
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1042'\n  AND mk.movie_id <= '2834'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4600.41,
        4581.79,
        40.2,
        4.41,
        4.4
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1013'\n  AND mk.movie_id <= '2854'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4655.9,
        4636.79,
        40.8,
        4.35,
        4.34
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1042'\n  AND mk.movie_id <= '2854'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4626.73,
        4607.92,
        40.43,
        4.38,
        4.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1066'\n  AND mk.movie_id <= '2640'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4394.96,
        4378.51,
        4336.35,
        37.55,
        4.7,
        4.69
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2804'\n  AND mk.movie_id <= '4949'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4963.65,
        4941.53,
        45.47,
        4.02,
        4.01
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2800'\n  AND mk.movie_id <= '4802'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4824.67,
        4803.97,
        43.74,
        4.17,
        4.16
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1632'\n  AND mk.movie_id <= '2946'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4062.51,
        4048.65,
        4013.12,
        29.38,
        5.14,
        5.13
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1632'\n  AND mk.movie_id <= '2968'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4093.35,
        4079.26,
        4043.14,
        29.66,
        5.1,
        5.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1557'\n  AND mk.movie_id <= '2910'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4109.88,
        4095.63,
        4059.11,
        29.85,
        5.07,
        5.06
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1596'\n  AND mk.movie_id <= '2910'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4062.51,
        4048.65,
        4013.12,
        29.38,
        5.14,
        5.13
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1086'\n  AND mk.movie_id <= '3280'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5012.17,
        4989.56,
        46.07,
        3.98,
        3.97
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '965'\n  AND mk.movie_id <= '1033'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        680.23,
        678.76,
        674.98,
        10.23,
        7.91
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1087'\n  AND mk.movie_id <= '3279'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5011.53,
        4988.93,
        46.05,
        3.98,
        3.97
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '86'\n  AND mk.movie_id <= '964'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3197.18,
        3187.66,
        3163.22,
        22.08,
        5.87,
        5.86
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1594'\n  AND mk.movie_id <= '3800'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4970.73,
        4948.0,
        4479.66,
        117.64,
        47.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1576'\n  AND mk.movie_id <= '3837'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4974.23,
        4950.95,
        4479.66,
        120.21,
        47.88
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2636'\n  AND mk.movie_id <= '4738'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4925.47,
        4903.77,
        44.96,
        4.07,
        4.06
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2607'\n  AND mk.movie_id <= '4731'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4944.55,
        4922.64,
        45.21,
        4.04,
        4.03
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2638'\n  AND mk.movie_id <= '3844'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3907.99,
        3895.2,
        3862.41,
        27.08,
        5.36,
        5.35
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1023'\n  AND mk.movie_id <= '3329'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4977.17,
        4953.44,
        4479.66,
        122.37,
        48.43
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '318'\n  AND mk.movie_id <= '2006'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4487.89,
        4470.3,
        38.94,
        4.54,
        4.53
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '955'\n  AND mk.movie_id <= '1063'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        848.22,
        846.35,
        841.54,
        10.72,
        7.76
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1006'\n  AND mk.movie_id <= '2281'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4010.16,
        3996.69,
        3962.14,
        28.91,
        5.22,
        5.21
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1067'\n  AND mk.movie_id <= '2639'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4394.28,
        4377.85,
        4335.73,
        37.53,
        4.71,
        4.7
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1085'\n  AND mk.movie_id <= '1549'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2110.55,
        2105.14,
        2091.24,
        16.05,
        6.72
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1086'\n  AND mk.movie_id <= '2614'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4339.28,
        4323.29,
        4282.3,
        35.99,
        4.77,
        4.76
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '927'\n  AND mk.movie_id <= '2614'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4483.39,
        4465.82,
        38.91,
        4.54,
        4.53
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1668'\n  AND mk.movie_id <= '3845'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4998.81,
        4976.36,
        45.88,
        3.99,
        3.98
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3281'\n  AND mk.movie_id <= '4731'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4236.92,
        4221.71,
        4182.75,
        31.03,
        4.9,
        4.89
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '647'\n  AND mk.movie_id <= '2820'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4993.03,
        4970.63,
        45.81,
        4.0,
        3.99
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1073'\n  AND mk.movie_id <= '3841'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5007.97,
        4979.65,
        4479.66,
        145.31,
        55.03
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2599'\n  AND mk.movie_id <= '4729'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4950.98,
        4929.0,
        45.3,
        4.04,
        4.03
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2006'\n  AND mk.movie_id <= '4033'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4852.62,
        4831.67,
        44.04,
        4.14,
        4.13
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1048'\n  AND mk.movie_id <= '1855'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3037.93,
        3029.11,
        3006.47,
        21.22,
        6.0,
        5.99
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '50'\n  AND mk.movie_id <= '64'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        444.07,
        443.14,
        440.75,
        9.57,
        8.14
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2006'\n  AND mk.movie_id <= '4006'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4824.03,
        4803.35,
        43.72,
        4.17,
        4.16
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1852'\n  AND mk.movie_id <= '4758'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5018.01,
        4988.31,
        4479.66,
        152.99,
        57.71
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2006'\n  AND mk.movie_id <= '4038'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4854.27,
        4833.27,
        44.1,
        4.14,
        4.13
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2638'\n  AND mk.movie_id <= '2930'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1539.45,
        1535.76,
        1526.26,
        13.95,
        7.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '388'\n  AND mk.movie_id <= '418'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        516.76,
        515.67,
        512.88,
        9.76,
        8.11
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '909'\n  AND mk.movie_id <= '1026'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        882.83,
        880.87,
        875.83,
        10.83,
        7.72
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1564'\n  AND mk.movie_id <= '2909'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4104.47,
        4090.3,
        4053.95,
        29.77,
        5.08,
        5.07
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2800'\n  AND mk.movie_id <= '5006'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4970.73,
        4948.0,
        4479.66,
        117.64,
        47.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2834'\n  AND mk.movie_id <= '4921'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4908.36,
        4886.81,
        44.76,
        4.08,
        4.07
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2925'\n  AND mk.movie_id <= '3871'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3362.79,
        3352.59,
        3326.43,
        23.91,
        5.76,
        5.75
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2930'\n  AND mk.movie_id <= '3916'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3450.45,
        3439.85,
        3412.65,
        24.41,
        5.69,
        5.68
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2558'\n  AND mk.movie_id <= '4041'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4275.95,
        4260.41,
        4220.59,
        31.44,
        4.84,
        4.83
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2931'\n  AND mk.movie_id <= '4609'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4477.01,
        4459.53,
        38.81,
        4.56,
        4.55
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '980'\n  AND mk.movie_id <= '3849'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5015.6,
        4986.27,
        4479.66,
        151.21,
        57.26
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '925'\n  AND mk.movie_id <= '2614'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4487.89,
        4470.3,
        38.94,
        4.54,
        4.53
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '86'\n  AND mk.movie_id <= '2071'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4802.85,
        4782.32,
        43.53,
        4.18,
        4.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '85'\n  AND mk.movie_id <= '2281'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5016.66,
        4994.03,
        46.09,
        3.98,
        3.97
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '211'\n  AND mk.movie_id <= '2068'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4673.23,
        4653.96,
        40.99,
        4.33,
        4.32
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '114'\n  AND mk.movie_id <= '2071'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4782.34,
        4762.07,
        43.21,
        4.22,
        4.21
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1677'\n  AND mk.movie_id <= '3849'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4993.03,
        4970.63,
        45.81,
        4.0,
        3.99
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2382'\n  AND mk.movie_id <= '4665'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4975.7,
        4952.19,
        4479.66,
        121.29,
        48.16
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '887'\n  AND mk.movie_id <= '923'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        542.85,
        541.69,
        538.72,
        9.85,
        8.01
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2382'\n  AND mk.movie_id <= '4566'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5005.24,
        4982.71,
        45.96,
        3.98,
        3.97
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3532'\n  AND mk.movie_id <= '3837'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1591.62,
        1587.79,
        1577.94,
        14.12,
        7.14
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1618'\n  AND mk.movie_id <= '2929'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4057.28,
        4043.46,
        4008.01,
        29.34,
        5.15,
        5.14
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2946'\n  AND mk.movie_id <= '4566'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4454.38,
        4437.47,
        4394.18,
        38.1,
        4.64,
        4.63
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2834'\n  AND mk.movie_id <= '4903'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4894.46,
        4873.09,
        44.55,
        4.1,
        4.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2639'\n  AND mk.movie_id <= '4033'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4167.66,
        4152.99,
        4115.39,
        30.37,
        5.0,
        4.99
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1621'\n  AND mk.movie_id <= '2914'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4031.13,
        4017.48,
        3982.48,
        29.13,
        5.19,
        5.18
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1065'\n  AND mk.movie_id <= '4033'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5022.03,
        4991.72,
        4479.66,
        155.95,
        58.46
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1677'\n  AND mk.movie_id <= '1858'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1133.6,
        1131.01,
        1124.35,
        11.6,
        7.52
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '911'\n  AND mk.movie_id <= '982'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        697.27,
        695.77,
        691.9,
        10.27,
        7.93
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2627'\n  AND mk.movie_id <= '4566'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4756.02,
        4735.95,
        42.97,
        4.23,
        4.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3268'\n  AND mk.movie_id <= '4738'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4264.42,
        4249.01,
        4209.5,
        31.29,
        4.87,
        4.86
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1550'\n  AND mk.movie_id <= '3550'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4824.03,
        4803.35,
        43.72,
        4.17,
        4.16
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1677'\n  AND mk.movie_id <= '4037'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4980.67,
        4956.4,
        4479.66,
        124.95,
        49.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1549'\n  AND mk.movie_id <= '3328'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4588.12,
        4569.64,
        40.03,
        4.42,
        4.41
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2558'\n  AND mk.movie_id <= '2839'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1504.32,
        1500.74,
        1491.51,
        13.82,
        7.21
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1760'\n  AND mk.movie_id <= '4039'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4975.47,
        4952.0,
        4479.66,
        121.12,
        48.11
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1058'\n  AND mk.movie_id <= '2820'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4566.93,
        4548.61,
        39.83,
        4.44,
        4.43
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1050'\n  AND mk.movie_id <= '2972'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4742.91,
        4723.0,
        42.78,
        4.25,
        4.24
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1091'\n  AND mk.movie_id <= '2930'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4650.76,
        4631.69,
        40.75,
        4.35,
        4.34
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '918'\n  AND mk.movie_id <= '3279'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4980.67,
        4956.4,
        4479.66,
        124.95,
        49.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '85'\n  AND mk.movie_id <= '1068'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3441.31,
        3430.74,
        3403.63,
        24.36,
        5.69,
        5.68
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3190'\n  AND mk.movie_id <= '4737'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4361.37,
        4345.18,
        4303.69,
        36.23,
        4.74,
        4.73
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3083'\n  AND mk.movie_id <= '4738'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4489.73,
        4472.48,
        4428.28,
        38.53,
        4.59,
        4.58
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1023'\n  AND mk.movie_id <= '4706'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5075.08,
        5037.65,
        4479.66,
        196.8,
        73.13
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3191'\n  AND mk.movie_id <= '4737'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4360.69,
        4344.52,
        4303.08,
        36.2,
        4.75,
        4.74
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1621'\n  AND mk.movie_id <= '2929'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4056.62,
        4042.81,
        4007.41,
        29.32,
        5.16,
        5.15
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1063'\n  AND mk.movie_id <= '2668'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4432.82,
        4416.07,
        4373.14,
        37.91,
        4.66,
        4.65
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1071'\n  AND mk.movie_id <= '2668'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4422.35,
        4405.67,
        4362.93,
        37.82,
        4.67,
        4.66
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1089'\n  AND mk.movie_id <= '2608'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4328.15,
        4312.24,
        4271.47,
        35.88,
        4.79,
        4.78
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '419'\n  AND mk.movie_id <= '2921'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4989.75,
        4964.08,
        4479.66,
        131.63,
        50.8
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2861'\n  AND mk.movie_id <= '4028'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3832.44,
        3820.04,
        3788.2,
        26.61,
        5.41,
        5.4
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1633'\n  AND mk.movie_id <= '3083'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4236.92,
        4221.71,
        4182.75,
        31.03,
        4.9,
        4.89
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2834'\n  AND mk.movie_id <= '3191'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1762.74,
        1758.4,
        1747.24,
        14.74,
        6.99
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '951'\n  AND mk.movie_id <= '981'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        516.76,
        515.67,
        512.88,
        9.76,
        8.11
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '118'\n  AND mk.movie_id <= '3191'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5032.93,
        5001.57,
        4479.66,
        165.05,
        63.74
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2861'\n  AND mk.movie_id <= '4873'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4835.93,
        4815.12,
        43.87,
        4.16,
        4.15
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '941'\n  AND mk.movie_id <= '3679'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5006.02,
        4978.0,
        4479.66,
        143.88,
        54.66
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '943'\n  AND mk.movie_id <= '3679'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5005.91,
        4977.91,
        4479.66,
        143.79,
        54.64
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '929'\n  AND mk.movie_id <= '3679'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5006.82,
        4978.68,
        4479.66,
        144.47,
        54.81
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '925'\n  AND mk.movie_id <= '3585'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5001.0,
        4973.75,
        4479.66,
        140.17,
        53.72
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1570'\n  AND mk.movie_id <= '2910'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4098.58,
        4084.46,
        4048.25,
        29.7,
        5.1,
        5.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1089'\n  AND mk.movie_id <= '2638'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4366.92,
        4350.72,
        4309.19,
        37.25,
        4.74,
        4.73
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '948'\n  AND mk.movie_id <= '1570'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2578.44,
        2571.46,
        2553.54,
        18.98,
        6.35
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2854'\n  AND mk.movie_id <= '5012'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4980.34,
        4958.08,
        45.64,
        4.01,
        4.0
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1618'\n  AND mk.movie_id <= '3747'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4950.33,
        4928.37,
        45.28,
        4.04,
        4.03
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '466'\n  AND mk.movie_id <= '1067'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2520.18,
        2513.41,
        2496.03,
        18.72,
        6.4
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2599'\n  AND mk.movie_id <= '4039'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4226.79,
        4211.67,
        4172.93,
        30.92,
        4.92,
        4.91
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2638'\n  AND mk.movie_id <= '4035'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4168.33,
        4153.64,
        4115.99,
        30.39,
        4.99,
        4.98
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1011'\n  AND mk.movie_id <= '4032'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5025.48,
        4994.64,
        4479.66,
        158.5,
        59.1
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2820'\n  AND mk.movie_id <= '4032'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3912.45,
        3899.61,
        3866.68,
        27.14,
        5.35,
        5.34
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '468'\n  AND mk.movie_id <= '3550'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5033.5,
        5002.05,
        4479.66,
        165.48,
        63.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '581'\n  AND mk.movie_id <= '3550'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5022.14,
        4991.82,
        4479.66,
        156.04,
        58.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1003'\n  AND mk.movie_id <= '4903'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5090.42,
        5050.83,
        4479.66,
        208.44,
        76.76
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1535'\n  AND mk.movie_id <= '4038'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4989.86,
        4964.17,
        4479.66,
        131.71,
        50.82
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2627'\n  AND mk.movie_id <= '4316'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4487.89,
        4470.3,
        38.94,
        4.54,
        4.53
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2638'\n  AND mk.movie_id <= '4316'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4477.01,
        4459.53,
        38.81,
        4.56,
        4.55
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '945'\n  AND mk.movie_id <= '1187'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1359.85,
        1356.65,
        1348.41,
        12.35,
        7.3
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1551'\n  AND mk.movie_id <= '2599'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3585.18,
        3573.97,
        3545.19,
        25.15,
        5.59,
        5.58
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1554'\n  AND mk.movie_id <= '2600'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3580.61,
        3569.41,
        3540.68,
        25.13,
        5.59,
        5.58
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1633'\n  AND mk.movie_id <= '2946'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4062.51,
        4048.65,
        4013.12,
        29.38,
        5.14,
        5.13
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2079'\n  AND mk.movie_id <= '4037'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4782.34,
        4762.07,
        43.21,
        4.22,
        4.21
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1083'\n  AND mk.movie_id <= '2599'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4322.91,
        4307.04,
        4266.37,
        35.84,
        4.79,
        4.78
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1010'\n  AND mk.movie_id <= '2280'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4004.27,
        3990.85,
        3956.44,
        28.85,
        5.23,
        5.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2924'\n  AND mk.movie_id <= '3268'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1719.09,
        1714.88,
        1704.03,
        14.59,
        7.01
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '651'\n  AND mk.movie_id <= '4306'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5073.22,
        5036.07,
        4479.66,
        195.42,
        72.79
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1006'\n  AND mk.movie_id <= '2280'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4009.5,
        3996.04,
        3961.54,
        28.89,
        5.23,
        5.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '989'\n  AND mk.movie_id <= '1796'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3037.93,
        3029.11,
        3006.47,
        21.22,
        6.0,
        5.99
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '357'\n  AND mk.movie_id <= '2070'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4515.49,
        4497.66,
        39.24,
        4.51,
        4.5
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1008'\n  AND mk.movie_id <= '2281'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4009.5,
        3996.04,
        3961.54,
        28.89,
        5.23,
        5.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2834'\n  AND mk.movie_id <= '5192'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4980.45,
        4956.21,
        4479.66,
        124.78,
        49.05
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '418'\n  AND mk.movie_id <= '2929'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4990.32,
        4964.56,
        4479.66,
        132.04,
        50.91
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '968'\n  AND mk.movie_id <= '1044'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        710.32,
        708.78,
        704.82,
        10.32,
        7.89
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '415'\n  AND mk.movie_id <= '1894'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4274.6,
        4259.1,
        4219.37,
        31.39,
        4.85,
        4.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2786'\n  AND mk.movie_id <= '4032'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3967.64,
        3954.46,
        3920.68,
        28.55,
        5.29,
        5.28
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2839'\n  AND mk.movie_id <= '4948'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4931.9,
        4910.13,
        45.04,
        4.06,
        4.05
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1380'\n  AND mk.movie_id <= '3837'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4986.91,
        4961.67,
        4479.66,
        129.53,
        50.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2668'\n  AND mk.movie_id <= '4033'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4130.14,
        4115.77,
        4078.93,
        30.0,
        5.05,
        5.04
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2638'\n  AND mk.movie_id <= '4745'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4931.25,
        4909.5,
        45.02,
        4.06,
        4.05
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2639'\n  AND mk.movie_id <= '5229'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4996.44,
        4969.89,
        4479.66,
        136.81,
        52.87
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '960'\n  AND mk.movie_id <= '975'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        452.59,
        451.64,
        449.21,
        9.59,
        8.14
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1621'\n  AND mk.movie_id <= '3682'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4884.19,
        4862.89,
        44.47,
        4.11,
        4.1
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1618'\n  AND mk.movie_id <= '3680'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4884.19,
        4862.89,
        44.47,
        4.11,
        4.1
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '927'\n  AND mk.movie_id <= '3342'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4984.19,
        4959.37,
        4479.66,
        127.53,
        49.76
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1013'\n  AND mk.movie_id <= '3329'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4977.84,
        4954.01,
        4479.66,
        122.87,
        48.56
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '974'\n  AND mk.movie_id <= '3329'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4980.33,
        4956.11,
        4479.66,
        124.7,
        49.03
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1018'\n  AND mk.movie_id <= '3342'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4978.3,
        4954.39,
        4479.66,
        123.2,
        48.65
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2627'\n  AND mk.movie_id <= '4555'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4748.69,
        4728.72,
        42.84,
        4.25,
        4.24
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2607'\n  AND mk.movie_id <= '4426'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4628.78,
        4609.9,
        40.52,
        4.37,
        4.36
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2614'\n  AND mk.movie_id <= '4555'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4760.51,
        4740.42,
        42.99,
        4.23,
        4.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2627'\n  AND mk.movie_id <= '4496'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4684.97,
        4665.58,
        41.14,
        4.31,
        4.3
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '586'\n  AND mk.movie_id <= '2880'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4976.37,
        4952.77,
        4479.66,
        121.79,
        48.28
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2872'\n  AND mk.movie_id <= '4859'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4807.98,
        4787.42,
        43.57,
        4.18,
        4.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2558'\n  AND mk.movie_id <= '5012'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4986.68,
        4961.48,
        4479.66,
        129.37,
        50.23
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '418'\n  AND mk.movie_id <= '927'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2248.07,
        2242.21,
        2227.17,
        16.61,
        6.6
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3037'\n  AND mk.movie_id <= '4745'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4505.85,
        4488.07,
        39.17,
        4.51,
        4.5
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2640'\n  AND mk.movie_id <= '4031'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4162.42,
        4147.79,
        4110.28,
        30.32,
        5.0,
        4.99
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3851'\n  AND mk.movie_id <= '4877'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3533.61,
        3522.62,
        3494.43,
        24.88,
        5.63,
        5.62
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1852'\n  AND mk.movie_id <= '1861'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        418.5,
        417.63,
        415.38,
        9.5,
        8.12
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1850'\n  AND mk.movie_id <= '1862'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        435.55,
        434.64,
        432.3,
        9.55,
        8.13
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3992'\n  AND mk.movie_id <= '4873'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3210.25,
        3200.7,
        3176.16,
        22.12,
        5.87,
        5.86
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2972'\n  AND mk.movie_id <= '4496'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4333.38,
        4317.43,
        4276.58,
        35.93,
        4.78,
        4.77
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2834'\n  AND mk.movie_id <= '4737'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4724.7,
        4704.98,
        42.54,
        4.28,
        4.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2861'\n  AND mk.movie_id <= '4732'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4685.61,
        4666.2,
        41.16,
        4.31,
        4.3
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '4039'\n  AND mk.movie_id <= '5264'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3937.62,
        3924.66,
        3891.42,
        28.29,
        5.33,
        5.32
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '284'\n  AND mk.movie_id <= '2025'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4544.4,
        4526.29,
        39.58,
        4.47,
        4.46
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '387'\n  AND mk.movie_id <= '2018'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4461.58,
        4444.57,
        4401.0,
        38.23,
        4.62,
        4.61
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '227'\n  AND mk.movie_id <= '2006'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4588.12,
        4569.64,
        40.03,
        4.42,
        4.41
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2913'\n  AND mk.movie_id <= '3837'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3307.29,
        3297.31,
        3271.73,
        23.64,
        5.79,
        5.78
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '302'\n  AND mk.movie_id <= '2018'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4516.76,
        4498.9,
        39.28,
        4.5,
        4.49
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1085'\n  AND mk.movie_id <= '2608'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4333.38,
        4317.43,
        4276.58,
        35.93,
        4.78,
        4.77
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1091'\n  AND mk.movie_id <= '2638'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4361.37,
        4345.18,
        4303.69,
        36.23,
        4.74,
        4.73
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1073'\n  AND mk.movie_id <= '2639'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4388.51,
        4372.15,
        4330.22,
        37.44,
        4.72,
        4.71
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1557'\n  AND mk.movie_id <= '2909'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4109.88,
        4095.63,
        4059.11,
        29.85,
        5.07,
        5.06
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1565'\n  AND mk.movie_id <= '2914'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4104.64,
        4090.43,
        4054.0,
        29.81,
        5.08,
        5.07
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '418'\n  AND mk.movie_id <= '4658'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5114.0,
        5071.04,
        4479.66,
        226.24,
        81.87
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1069'\n  AND mk.movie_id <= '2639'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4389.72,
        4373.31,
        4331.24,
        37.5,
        4.71,
        4.7
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2861'\n  AND mk.movie_id <= '5211'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4979.99,
        4955.83,
        4479.66,
        124.45,
        48.97
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '818'\n  AND mk.movie_id <= '3585'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5007.97,
        4979.65,
        4479.66,
        145.31,
        55.03
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '818'\n  AND mk.movie_id <= '3680'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5015.15,
        4985.89,
        4479.66,
        150.87,
        57.18
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1017'\n  AND mk.movie_id <= '3282'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4974.57,
        4951.24,
        4479.66,
        120.46,
        47.94
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1087'\n  AND mk.movie_id <= '2924'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4650.6,
        4631.54,
        40.73,
        4.35,
        4.34
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1080'\n  AND mk.movie_id <= '2600'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4328.15,
        4312.24,
        4271.47,
        35.88,
        4.79,
        4.78
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1007'\n  AND mk.movie_id <= '2304'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4036.36,
        4022.68,
        3987.59,
        29.17,
        5.18,
        5.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1007'\n  AND mk.movie_id <= '2280'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4009.5,
        3996.04,
        3961.54,
        28.89,
        5.23,
        5.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1010'\n  AND mk.movie_id <= '2281'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4004.93,
        3991.49,
        3957.04,
        28.87,
        5.23,
        5.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1087'\n  AND mk.movie_id <= '2636'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4366.92,
        4350.72,
        4309.19,
        37.25,
        4.74,
        4.73
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2018'\n  AND mk.movie_id <= '3992'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4795.47,
        4775.05,
        43.4,
        4.2,
        4.19
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1062'\n  AND mk.movie_id <= '4513'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5058.76,
        5023.63,
        4479.66,
        184.43,
        69.32
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2018'\n  AND mk.movie_id <= '3872'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4668.09,
        4648.86,
        40.94,
        4.33,
        4.32
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '921'\n  AND mk.movie_id <= '1897'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3423.03,
        3412.53,
        3385.6,
        24.28,
        5.7,
        5.69
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1547'\n  AND mk.movie_id <= '3550'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4829.16,
        4808.44,
        43.76,
        4.17,
        4.16
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1618'\n  AND mk.movie_id <= '5009'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5054.82,
        5020.29,
        4479.66,
        181.51,
        68.6
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '923'\n  AND mk.movie_id <= '3280'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4980.45,
        4956.21,
        4479.66,
        124.78,
        49.05
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '596'\n  AND mk.movie_id <= '2804'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4970.84,
        4948.09,
        4479.66,
        117.73,
        47.24
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '651'\n  AND mk.movie_id <= '2804'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4974.56,
        4952.35,
        45.58,
        4.02,
        4.01
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2968'\n  AND mk.movie_id <= '4739'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4577.84,
        4559.43,
        39.94,
        4.43,
        4.42
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1576'\n  AND mk.movie_id <= '3679'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4926.12,
        4904.4,
        44.98,
        4.06,
        4.05
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1024'\n  AND mk.movie_id <= '3679'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5000.66,
        4973.46,
        4479.66,
        139.92,
        53.66
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1025'\n  AND mk.movie_id <= '3556'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4992.68,
        4966.71,
        4479.66,
        134.05,
        52.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1864'\n  AND mk.movie_id <= '2913'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3585.18,
        3573.97,
        3545.19,
        25.15,
        5.59,
        5.58
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1535'\n  AND mk.movie_id <= '3190'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4489.73,
        4472.48,
        4428.28,
        38.53,
        4.59,
        4.58
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1400'\n  AND mk.movie_id <= '3083'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4478.25,
        4460.71,
        38.87,
        4.55,
        4.54
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3279'\n  AND mk.movie_id <= '4758'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4274.6,
        4259.1,
        4219.37,
        31.39,
        4.85,
        4.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2931'\n  AND mk.movie_id <= '4758'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4639.69,
        4620.72,
        40.62,
        4.36,
        4.35
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3268'\n  AND mk.movie_id <= '4745'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4270.04,
        4254.56,
        4214.87,
        31.37,
        4.85,
        4.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3191'\n  AND mk.movie_id <= '4739'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4362.37,
        4346.18,
        4304.69,
        37.23,
        4.74,
        4.73
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '429'\n  AND mk.movie_id <= '1894'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4258.52,
        4243.16,
        4203.79,
        31.22,
        4.88,
        4.87
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1554'\n  AND mk.movie_id <= '2909'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4114.44,
        4100.18,
        4063.61,
        29.87,
        5.07,
        5.06
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '11'\n  AND mk.movie_id <= '1048'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3561.68,
        3550.57,
        3522.07,
        25.03,
        5.61,
        5.6
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1087'\n  AND mk.movie_id <= '2639'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4367.6,
        4351.37,
        4309.8,
        37.27,
        4.74,
        4.73
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '929'\n  AND mk.movie_id <= '3281'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4980.11,
        4955.92,
        4479.66,
        124.53,
        48.99
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '970'\n  AND mk.movie_id <= '3280'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4977.39,
        4953.63,
        4479.66,
        122.54,
        48.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1000'\n  AND mk.movie_id <= '2279'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4015.39,
        4001.88,
        3967.25,
        28.96,
        5.21,
        5.2
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1141'\n  AND mk.movie_id <= '3849'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5004.08,
        4976.36,
        4479.66,
        142.44,
        54.3
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1144'\n  AND mk.movie_id <= '3844'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5003.62,
        4975.97,
        4479.66,
        142.11,
        54.21
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '11'\n  AND mk.movie_id <= '2914'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5017.78,
        4988.12,
        4479.66,
        152.82,
        57.67
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '22'\n  AND mk.movie_id <= '2918'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5017.32,
        4987.73,
        4479.66,
        152.48,
        57.58
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2293'\n  AND mk.movie_id <= '4038'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4549.54,
        4531.39,
        39.62,
        4.47,
        4.46
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1858'\n  AND mk.movie_id <= '2914'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3597.9,
        3586.61,
        3557.65,
        25.24,
        5.58,
        5.57
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1854'\n  AND mk.movie_id <= '2914'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3607.7,
        3596.36,
        3567.27,
        25.3,
        5.57,
        5.56
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2972'\n  AND mk.movie_id <= '4493'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4332.7,
        4316.78,
        4275.97,
        35.91,
        4.79,
        4.78
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1090'\n  AND mk.movie_id <= '2639'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4366.92,
        4350.72,
        4309.19,
        37.25,
        4.74,
        4.73
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1020'\n  AND mk.movie_id <= '2627'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4438.05,
        4421.26,
        4378.25,
        37.95,
        4.66,
        4.65
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1089'\n  AND mk.movie_id <= '2639'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4366.92,
        4350.72,
        4309.19,
        37.25,
        4.74,
        4.73
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1570'\n  AND mk.movie_id <= '3834'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4974.45,
        4951.14,
        4479.66,
        120.38,
        47.92
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '85'\n  AND mk.movie_id <= '4445'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5121.99,
        5077.83,
        4479.66,
        232.18,
        83.31
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1535'\n  AND mk.movie_id <= '4041'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4990.09,
        4964.37,
        4479.66,
        131.88,
        50.87
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '970'\n  AND mk.movie_id <= '4651'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5074.85,
        5037.45,
        4479.66,
        196.62,
        73.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '86'\n  AND mk.movie_id <= '2280'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5012.17,
        4989.56,
        46.07,
        3.98,
        3.97
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '86'\n  AND mk.movie_id <= '2079'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4813.76,
        4793.15,
        43.63,
        4.18,
        4.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1029'\n  AND mk.movie_id <= '3201'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4993.03,
        4970.63,
        45.81,
        4.0,
        3.99
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1618'\n  AND mk.movie_id <= '3083'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4258.52,
        4243.16,
        4203.79,
        31.22,
        4.88,
        4.87
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '986'\n  AND mk.movie_id <= '2608'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4455.05,
        4438.13,
        4394.79,
        38.12,
        4.63,
        4.62
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '654'\n  AND mk.movie_id <= '2820'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4986.61,
        4964.28,
        45.73,
        4.01,
        4.0
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2931'\n  AND mk.movie_id <= '4739'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4621.59,
        4602.82,
        40.39,
        4.39,
        4.38
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2600'\n  AND mk.movie_id <= '5022'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4984.64,
        4959.76,
        4479.66,
        127.87,
        49.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '658'\n  AND mk.movie_id <= '2071'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4193.77,
        4178.93,
        4140.91,
        30.58,
        4.97,
        4.96
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1071'\n  AND mk.movie_id <= '2839'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4576.57,
        4558.19,
        39.9,
        4.44,
        4.43
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '647'\n  AND mk.movie_id <= '2079'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4215.66,
        4200.63,
        4162.11,
        30.82,
        4.93,
        4.92
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '723'\n  AND mk.movie_id <= '2668'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4766.29,
        4746.15,
        43.06,
        4.23,
        4.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '418'\n  AND mk.movie_id <= '1894'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4274.21,
        4258.74,
        4219.1,
        31.35,
        4.86,
        4.85
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '398'\n  AND mk.movie_id <= '1894'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4300.88,
        4285.2,
        4245.02,
        35.61,
        4.82,
        4.81
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '581'\n  AND mk.movie_id <= '1465'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3219.4,
        3209.81,
        3185.18,
        22.16,
        5.86,
        5.85
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '651'\n  AND mk.movie_id <= '2076'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4205.2,
        4190.23,
        4151.9,
        30.73,
        4.94,
        4.93
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '658'\n  AND mk.movie_id <= '2040'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4147.4,
        4132.85,
        4095.56,
        30.22,
        5.02,
        5.01
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '989'\n  AND mk.movie_id <= '2599'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4438.69,
        4421.89,
        4378.86,
        37.97,
        4.65,
        4.64
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1079'\n  AND mk.movie_id <= '2599'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4328.15,
        4312.24,
        4271.47,
        35.88,
        4.79,
        4.78
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1565'\n  AND mk.movie_id <= '2920'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4114.44,
        4100.18,
        4063.61,
        29.87,
        5.07,
        5.06
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '24'\n  AND mk.movie_id <= '1854'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4644.19,
        4625.2,
        40.65,
        4.36,
        4.35
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1570'\n  AND mk.movie_id <= '2914'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4103.81,
        4089.65,
        4053.35,
        29.75,
        5.09,
        5.08
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1570'\n  AND mk.movie_id <= '2918'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4109.04,
        4094.84,
        4058.45,
        29.79,
        5.08,
        5.07
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1858'\n  AND mk.movie_id <= '4513'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5000.66,
        4973.46,
        4479.66,
        139.92,
        53.66
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1576'\n  AND mk.movie_id <= '2911'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4088.78,
        4074.71,
        4038.64,
        29.64,
        5.1,
        5.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1535'\n  AND mk.movie_id <= '3834'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4976.71,
        4953.05,
        4479.66,
        122.04,
        48.35
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2304'\n  AND mk.movie_id <= '4738'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4985.43,
        4960.43,
        4479.66,
        128.45,
        49.99
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '984'\n  AND mk.movie_id <= '2037'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3589.41,
        3578.14,
        3549.23,
        25.22,
        5.58,
        5.57
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '992'\n  AND mk.movie_id <= '2076'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3659.27,
        3647.71,
        3618.03,
        25.58,
        5.54,
        5.53
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '594'\n  AND mk.movie_id <= '4311'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5077.29,
        5039.53,
        4479.66,
        198.44,
        73.54
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1551'\n  AND mk.movie_id <= '2880'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4082.89,
        4068.87,
        4032.93,
        29.58,
        5.12,
        5.11
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2304'\n  AND mk.movie_id <= '5012'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5004.08,
        4976.36,
        4479.66,
        142.44,
        54.3
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2071'\n  AND mk.movie_id <= '4033'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4779.42,
        4759.12,
        43.25,
        4.21,
        4.2
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '118'\n  AND mk.movie_id <= '2076'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4782.34,
        4762.07,
        43.21,
        4.22,
        4.21
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2861'\n  AND mk.movie_id <= '4828'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4789.05,
        4768.7,
        43.31,
        4.21,
        4.2
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2304'\n  AND mk.movie_id <= '4734'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4985.09,
        4960.14,
        4479.66,
        128.2,
        49.93
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1565'\n  AND mk.movie_id <= '3556'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4813.12,
        4792.52,
        43.61,
        4.18,
        4.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1859'\n  AND mk.movie_id <= '2279'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1973.51,
        1968.54,
        1955.76,
        15.51,
        6.83
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '465'\n  AND mk.movie_id <= '1021'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2385.63,
        2379.31,
        2363.1,
        17.16,
        6.5
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '658'\n  AND mk.movie_id <= '2079'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4199.96,
        4185.04,
        4146.79,
        30.69,
        4.95,
        4.94
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '654'\n  AND mk.movie_id <= '2071'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4194.73,
        4179.84,
        4141.68,
        30.64,
        4.96,
        4.95
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '651'\n  AND mk.movie_id <= '2279'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4460.9,
        4443.91,
        4400.39,
        38.21,
        4.62,
        4.61
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '4734'\n  AND mk.movie_id <= '4951'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1272.55,
        1269.6,
        1261.99,
        12.05,
        7.4
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '681'\n  AND mk.movie_id <= '2076'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4167.66,
        4152.99,
        4115.39,
        30.37,
        5.0,
        4.99
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '963'\n  AND mk.movie_id <= '2281'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4062.62,
        4048.73,
        4013.1,
        29.43,
        5.14,
        5.13
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '966'\n  AND mk.movie_id <= '2293'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4077.65,
        4063.67,
        4027.82,
        29.53,
        5.12,
        5.11
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1590'\n  AND mk.movie_id <= '2800'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3907.89,
        3895.06,
        3862.18,
        27.12,
        5.35,
        5.34
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2608'\n  AND mk.movie_id <= '3556'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3363.44,
        3353.22,
        3327.01,
        23.94,
        5.75,
        5.74
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1040'\n  AND mk.movie_id <= '2304'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3994.47,
        3981.1,
        3946.83,
        28.78,
        5.24,
        5.23
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '593'\n  AND mk.movie_id <= '4665'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5101.87,
        5060.57,
        4479.66,
        216.96,
        78.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2614'\n  AND mk.movie_id <= '3747'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3756.7,
        3744.64,
        3713.71,
        26.18,
        5.46,
        5.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3532'\n  AND mk.movie_id <= '4738'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3907.99,
        3895.2,
        3862.41,
        27.08,
        5.36,
        5.35
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1048'\n  AND mk.movie_id <= '4700'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5072.99,
        5035.87,
        4479.66,
        195.24,
        72.75
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '389'\n  AND mk.movie_id <= '2854'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4987.36,
        4962.06,
        4479.66,
        129.87,
        50.35
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1618'\n  AND mk.movie_id <= '5260'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5072.29,
        5035.28,
        4479.66,
        194.73,
        72.62
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '389'\n  AND mk.movie_id <= '1894'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4312.01,
        4296.24,
        4255.83,
        35.71,
        4.81,
        4.8
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '467'\n  AND mk.movie_id <= '1894'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4205.87,
        4190.89,
        4152.51,
        30.75,
        4.94,
        4.93
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '651'\n  AND mk.movie_id <= '2069'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4194.73,
        4179.84,
        4141.68,
        30.64,
        4.96,
        4.95
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2025'\n  AND mk.movie_id <= '3916'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4708.65,
        4689.05,
        42.39,
        4.29,
        4.28
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '371'\n  AND mk.movie_id <= '2037'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4505.43,
        4488.07,
        4443.6,
        38.66,
        4.57,
        4.56
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '211'\n  AND mk.movie_id <= '2040'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4644.19,
        4625.2,
        40.65,
        4.36,
        4.35
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '973'\n  AND mk.movie_id <= '1858'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3219.4,
        3209.81,
        3185.18,
        22.16,
        5.86,
        5.85
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1570'\n  AND mk.movie_id <= '3201'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4461.58,
        4444.57,
        4401.0,
        38.23,
        4.62,
        4.61
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2304'\n  AND mk.movie_id <= '4041'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4538.62,
        4520.56,
        39.51,
        4.48,
        4.47
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '398'\n  AND mk.movie_id <= '2627'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4972.19,
        4949.23,
        4479.66,
        118.72,
        47.49
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2304'\n  AND mk.movie_id <= '4828'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4991.23,
        4965.33,
        4479.66,
        132.71,
        51.08
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1074'\n  AND mk.movie_id <= '3800'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5005.34,
        4977.42,
        4479.66,
        143.37,
        54.53
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1550'\n  AND mk.movie_id <= '4032'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4988.5,
        4963.02,
        4479.66,
        130.7,
        50.57
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1549'\n  AND mk.movie_id <= '4035'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4988.73,
        4963.21,
        4479.66,
        130.87,
        50.61
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1785'\n  AND mk.movie_id <= '4903'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5035.8,
        5004.01,
        4479.66,
        167.18,
        64.27
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1149'\n  AND mk.movie_id <= '4119'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5022.14,
        4991.82,
        4479.66,
        156.04,
        58.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1149'\n  AND mk.movie_id <= '4039'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5016.98,
        4987.44,
        4479.66,
        152.22,
        57.52
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1600'\n  AND mk.movie_id <= '3837'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4972.76,
        4949.71,
        4479.66,
        119.13,
        47.6
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1067'\n  AND mk.movie_id <= '4665'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5069.39,
        5032.81,
        4479.66,
        192.57,
        72.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '594'\n  AND mk.movie_id <= '1015'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1974.04,
        1969.05,
        1956.22,
        15.54,
        6.81
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1621'\n  AND mk.movie_id <= '3800'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4999.46,
        4976.99,
        45.9,
        3.99,
        3.98
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1632'\n  AND mk.movie_id <= '3679'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4871.6,
        4850.44,
        44.29,
        4.12,
        4.11
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1537'\n  AND mk.movie_id <= '3268'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4537.31,
        4519.31,
        39.45,
        4.49,
        4.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2861'\n  AND mk.movie_id <= '5192'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4978.75,
        4954.77,
        4479.66,
        123.53,
        48.73
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2861'\n  AND mk.movie_id <= '4737'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4696.24,
        4676.78,
        42.22,
        4.31,
        4.3
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1063'\n  AND mk.movie_id <= '2854'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4599.77,
        4581.17,
        40.18,
        4.41,
        4.4
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1557'\n  AND mk.movie_id <= '2872'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4061.95,
        4048.07,
        4012.49,
        29.4,
        5.14,
        5.13
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '974'\n  AND mk.movie_id <= '3268'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4976.37,
        4952.77,
        4479.66,
        121.79,
        48.28
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1465'\n  AND mk.movie_id <= '4033'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4995.07,
        4968.74,
        4479.66,
        135.81,
        52.61
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1400'\n  AND mk.movie_id <= '4039'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4999.63,
        4972.59,
        4479.66,
        139.16,
        53.47
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1012'\n  AND mk.movie_id <= '3532'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4991.0,
        4965.14,
        4479.66,
        132.55,
        51.04
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1897'\n  AND mk.movie_id <= '4032'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4956.75,
        4934.72,
        45.36,
        4.03,
        4.02
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '968'\n  AND mk.movie_id <= '3842'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5015.95,
        4986.57,
        4479.66,
        151.46,
        57.33
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1008'\n  AND mk.movie_id <= '4948'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5093.1,
        5053.12,
        4479.66,
        210.44,
        77.25
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1897'\n  AND mk.movie_id <= '4027'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4950.98,
        4929.0,
        45.3,
        4.04,
        4.03
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '958'\n  AND mk.movie_id <= '2946'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4807.98,
        4787.42,
        43.57,
        4.18,
        4.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '968'\n  AND mk.movie_id <= '3201'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4972.42,
        4949.43,
        4479.66,
        118.88,
        47.54
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1551'\n  AND mk.movie_id <= '2857'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4052.06,
        4038.27,
        4002.91,
        29.3,
        5.16,
        5.15
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1027'\n  AND mk.movie_id <= '4496'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5059.92,
        5024.62,
        4479.66,
        185.29,
        69.53
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1065'\n  AND mk.movie_id <= '2627'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4383.29,
        4366.96,
        4325.11,
        37.4,
        4.72,
        4.71
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1554'\n  AND mk.movie_id <= '2872'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4062.62,
        4048.73,
        4013.1,
        29.43,
        5.14,
        5.13
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2279'\n  AND mk.movie_id <= '4038'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4566.22,
        4547.94,
        39.79,
        4.45,
        4.44
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2280'\n  AND mk.movie_id <= '4033'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4560.45,
        4542.22,
        39.73,
        4.46,
        4.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1064'\n  AND mk.movie_id <= '3532'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4987.59,
        4962.25,
        4479.66,
        130.04,
        50.4
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '4707'\n  AND mk.movie_id <= '5262'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2385.63,
        2379.31,
        2363.1,
        17.16,
        6.5
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1063'\n  AND mk.movie_id <= '2839'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4587.48,
        4569.02,
        40.0,
        4.43,
        4.42
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1064'\n  AND mk.movie_id <= '2820'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4564.95,
        4546.7,
        39.75,
        4.46,
        4.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1064'\n  AND mk.movie_id <= '2839'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4582.98,
        4564.54,
        39.98,
        4.43,
        4.42
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '371'\n  AND mk.movie_id <= '1087'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2802.32,
        2794.41,
        2774.11,
        20.11,
        6.17,
        6.16
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1063'\n  AND mk.movie_id <= '3550'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4988.84,
        4963.31,
        4479.66,
        130.96,
        50.63
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1017'\n  AND mk.movie_id <= '3279'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4974.34,
        4951.05,
        4479.66,
        120.29,
        47.9
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1380'\n  AND mk.movie_id <= '3871'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4989.07,
        4963.5,
        4479.66,
        131.12,
        50.67
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '826'\n  AND mk.movie_id <= '2918'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4914.13,
        4892.54,
        44.83,
        4.07,
        4.06
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1140'\n  AND mk.movie_id <= '2607'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4259.19,
        4243.81,
        4204.4,
        31.24,
        4.87,
        4.86
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '415'\n  AND mk.movie_id <= '658'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1359.85,
        1356.65,
        1348.41,
        12.35,
        7.3
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1897'\n  AND mk.movie_id <= '4031'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4956.11,
        4934.09,
        45.34,
        4.03,
        4.02
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '398'\n  AND mk.movie_id <= '2076'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4477.01,
        4459.53,
        38.81,
        4.56,
        4.55
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '681'\n  AND mk.movie_id <= '2040'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4120.34,
        4106.03,
        4069.32,
        29.94,
        5.06,
        5.05
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1091'\n  AND mk.movie_id <= '2607'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4322.91,
        4307.04,
        4266.37,
        35.84,
        4.79,
        4.78
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1897'\n  AND mk.movie_id <= '3864'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4789.05,
        4768.7,
        43.31,
        4.21,
        4.2
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3083'\n  AND mk.movie_id <= '5194'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4932.54,
        4910.76,
        45.06,
        4.06,
        4.05
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1897'\n  AND mk.movie_id <= '4037'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4962.53,
        4940.45,
        45.43,
        4.03,
        4.02
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1073'\n  AND mk.movie_id <= '2640'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4384.49,
        4368.11,
        4326.13,
        37.46,
        4.71,
        4.7
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2861'\n  AND mk.movie_id <= '4903'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4865.82,
        4844.72,
        44.23,
        4.13,
        4.12
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2872'\n  AND mk.movie_id <= '4920'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4871.6,
        4850.44,
        44.29,
        4.12,
        4.11
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1086'\n  AND mk.movie_id <= '2638'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4367.6,
        4351.37,
        4309.8,
        37.27,
        4.74,
        4.73
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '989'\n  AND mk.movie_id <= '2382'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4163.09,
        4148.45,
        4110.89,
        30.34,
        5.0,
        4.99
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1537'\n  AND mk.movie_id <= '4035'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4989.52,
        4963.89,
        4479.66,
        131.46,
        50.76
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '860'\n  AND mk.movie_id <= '903'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        572.93,
        571.71,
        568.56,
        9.93,
        7.98
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2304'\n  AND mk.movie_id <= '4152'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4662.32,
        4643.14,
        40.88,
        4.34,
        4.33
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1052'\n  AND mk.movie_id <= '3532'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4988.39,
        4962.92,
        4479.66,
        130.62,
        50.55
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '915'\n  AND mk.movie_id <= '2079'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3827.22,
        3814.85,
        3783.1,
        26.57,
        5.42,
        5.41
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '916'\n  AND mk.movie_id <= '2070'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3799.81,
        3787.54,
        3756.07,
        26.44,
        5.43,
        5.42
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1082'\n  AND mk.movie_id <= '4031'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5020.77,
        4990.65,
        4479.66,
        155.02,
        58.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2281'\n  AND mk.movie_id <= '4125'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4656.54,
        4637.41,
        40.82,
        4.35,
        4.34
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2880'\n  AND mk.movie_id <= '4496'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4449.15,
        4432.28,
        4389.07,
        38.06,
        4.64,
        4.63
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2909'\n  AND mk.movie_id <= '4566'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4494.29,
        4477.01,
        4432.77,
        38.55,
        4.59,
        4.58
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1032'\n  AND mk.movie_id <= '1782'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2893.76,
        2885.5,
        2864.29,
        20.54,
        6.1,
        6.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '371'\n  AND mk.movie_id <= '2006'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4471.36,
        4454.3,
        4410.6,
        38.29,
        4.62,
        4.61
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '683'\n  AND mk.movie_id <= '5267'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5138.05,
        5091.66,
        4479.66,
        244.41,
        87.04
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2968'\n  AND mk.movie_id <= '4555'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4411.32,
        4394.75,
        4352.28,
        37.7,
        4.68,
        4.67
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2968'\n  AND mk.movie_id <= '4513'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4360.01,
        4343.86,
        4302.47,
        36.18,
        4.75,
        4.74
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '986'\n  AND mk.movie_id <= '1011'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        491.2,
        490.16,
        487.51,
        9.7,
        8.1
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2946'\n  AND mk.movie_id <= '4651'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4505.21,
        4487.46,
        39.13,
        4.52,
        4.51
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '818'\n  AND mk.movie_id <= '1048'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1320.2,
        1317.12,
        1309.2,
        12.2,
        7.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1590'\n  AND mk.movie_id <= '3680'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4913.49,
        4891.91,
        44.81,
        4.08,
        4.07
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1590'\n  AND mk.movie_id <= '3585'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4818.25,
        4797.62,
        43.65,
        4.18,
        4.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '679'\n  AND mk.movie_id <= '2037'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4119.67,
        4105.37,
        4068.71,
        29.92,
        5.06,
        5.05
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '681'\n  AND mk.movie_id <= '2069'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4157.19,
        4142.6,
        4105.17,
        30.28,
        5.01,
        5.0
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1038'\n  AND mk.movie_id <= '2834'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4605.55,
        4586.89,
        40.24,
        4.4,
        4.39
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1618'\n  AND mk.movie_id <= '4700'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5033.5,
        5002.05,
        4479.66,
        165.48,
        63.84
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1549'\n  AND mk.movie_id <= '3268'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4521.27,
        4503.38,
        39.3,
        4.5,
        4.49
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3191'\n  AND mk.movie_id <= '5229'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4860.69,
        4839.62,
        44.19,
        4.13,
        4.12
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3190'\n  AND mk.movie_id <= '5226'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4855.56,
        4834.52,
        44.15,
        4.13,
        4.12
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1008'\n  AND mk.movie_id <= '1333'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1657.36,
        1653.33,
        1642.98,
        14.36,
        7.08
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '984'\n  AND mk.movie_id <= '1596'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2547.31,
        2540.43,
        2522.78,
        18.85,
        6.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2069'\n  AND mk.movie_id <= '4658'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4996.44,
        4969.89,
        4479.66,
        136.81,
        52.87
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1059'\n  AND mk.movie_id <= '2931'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4685.61,
        4666.2,
        41.16,
        4.31,
        4.3
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '429'\n  AND mk.movie_id <= '992'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2407.71,
        2401.33,
        2384.94,
        17.25,
        6.49
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '4873'\n  AND mk.movie_id <= '5211'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1697.01,
        1692.86,
        1682.2,
        14.51,
        7.04
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2037'\n  AND mk.movie_id <= '3992'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4777.2,
        4756.97,
        43.16,
        4.22,
        4.21
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1059'\n  AND mk.movie_id <= '2924'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4679.19,
        4659.85,
        41.07,
        4.32,
        4.31
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '910'\n  AND mk.movie_id <= '1020'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        856.75,
        854.86,
        850.0,
        10.75,
        7.77
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '937'\n  AND mk.movie_id <= '3834'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5017.44,
        4987.83,
        4479.66,
        152.56,
        57.6
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1011'\n  AND mk.movie_id <= '2293'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4015.43,
        4001.88,
        3967.16,
        29.0,
        5.21,
        5.2
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2025'\n  AND mk.movie_id <= '3872'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4661.68,
        4642.52,
        40.86,
        4.34,
        4.33
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1897'\n  AND mk.movie_id <= '3872'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4799.96,
        4779.52,
        43.42,
        4.2,
        4.19
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '975'\n  AND mk.movie_id <= '3552'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4995.64,
        4969.22,
        4479.66,
        136.23,
        52.72
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '975'\n  AND mk.movie_id <= '3556'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4995.87,
        4969.41,
        4479.66,
        136.39,
        52.76
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3283'\n  AND mk.movie_id <= '4951'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4506.1,
        4488.73,
        4444.22,
        38.68,
        4.57,
        4.56
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3282'\n  AND mk.movie_id <= '4950'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4506.1,
        4488.73,
        4444.22,
        38.68,
        4.57,
        4.56
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1862'\n  AND mk.movie_id <= '3916'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4877.76,
        4856.54,
        44.38,
        4.11,
        4.1
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1060'\n  AND mk.movie_id <= '2293'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3952.65,
        3939.6,
        3906.13,
        28.4,
        5.31,
        5.3
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1054'\n  AND mk.movie_id <= '2293'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3962.45,
        3949.34,
        3915.74,
        28.46,
        5.3,
        5.29
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1073'\n  AND mk.movie_id <= '2018'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3358.22,
        3348.04,
        3321.92,
        23.89,
        5.76,
        5.75
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1016'\n  AND mk.movie_id <= '3550'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4992.8,
        4966.81,
        4479.66,
        134.13,
        52.19
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2872'\n  AND mk.movie_id <= '3679'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3037.93,
        3029.11,
        3006.47,
        21.22,
        6.0,
        5.99
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3281'\n  AND mk.movie_id <= '4951'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4510.66,
        4493.26,
        4448.71,
        38.7,
        4.57,
        4.56
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3083'\n  AND mk.movie_id <= '5013'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4749.33,
        4729.35,
        42.86,
        4.24,
        4.23
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1142'\n  AND mk.movie_id <= '4949'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5083.23,
        5044.58,
        4479.66,
        202.85,
        74.63
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '587'\n  AND mk.movie_id <= '954'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1801.87,
        1797.43,
        1786.0,
        14.87,
        6.97
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '318'\n  AND mk.movie_id <= '654'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1692.49,
        1688.36,
        1677.74,
        14.49,
        7.05
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '418'\n  AND mk.movie_id <= '1865'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4232.36,
        4217.17,
        4178.25,
        31.01,
        4.9,
        4.89
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1465'\n  AND mk.movie_id <= '4490'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5025.82,
        4994.93,
        4479.66,
        158.76,
        59.16
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '982'\n  AND mk.movie_id <= '982'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        379.9,
        379.11,
        377.08,
        9.4,
        8.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '388'\n  AND mk.movie_id <= '2804'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4984.19,
        4959.37,
        4479.66,
        127.53,
        49.76
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '398'\n  AND mk.movie_id <= '2006'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4438.05,
        4421.26,
        4378.25,
        37.95,
        4.66,
        4.65
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '967'\n  AND mk.movie_id <= '2304'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4093.35,
        4079.26,
        4043.14,
        29.66,
        5.1,
        5.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2040'\n  AND mk.movie_id <= '4006'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4789.05,
        4768.7,
        43.31,
        4.21,
        4.2
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1065'\n  AND mk.movie_id <= '2685'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4454.38,
        4437.47,
        4394.18,
        38.1,
        4.64,
        4.63
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3329'\n  AND mk.movie_id <= '5267'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4756.02,
        4735.95,
        42.97,
        4.23,
        4.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2920'\n  AND mk.movie_id <= '5264'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4979.54,
        4955.44,
        4479.66,
        124.12,
        48.88
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2918'\n  AND mk.movie_id <= '5259'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4979.43,
        4955.35,
        4479.66,
        124.03,
        48.86
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3328'\n  AND mk.movie_id <= '5268'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4760.51,
        4740.42,
        42.99,
        4.23,
        4.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '929'\n  AND mk.movie_id <= '1087'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1046.82,
        1044.46,
        1038.39,
        11.32,
        7.61
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1632'\n  AND mk.movie_id <= '2921'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4025.9,
        4012.28,
        3977.38,
        29.08,
        5.19,
        5.18
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '918'\n  AND mk.movie_id <= '2006'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3669.07,
        3657.45,
        3627.64,
        25.65,
        5.53,
        5.52
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2930'\n  AND mk.movie_id <= '4457'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4338.61,
        4322.63,
        4281.68,
        35.97,
        4.78,
        4.77
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1148'\n  AND mk.movie_id <= '2600'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4242.15,
        4226.91,
        4187.86,
        31.07,
        4.9,
        4.89
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1003'\n  AND mk.movie_id <= '2279'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4010.16,
        3996.69,
        3962.14,
        28.91,
        5.22,
        5.21
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1002'\n  AND mk.movie_id <= '2279'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4014.73,
        4001.24,
        3966.65,
        28.93,
        5.22,
        5.21
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '977'\n  AND mk.movie_id <= '3191'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4971.29,
        4948.47,
        4479.66,
        118.06,
        47.32
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '979'\n  AND mk.movie_id <= '3532'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4994.05,
        4967.87,
        4479.66,
        135.05,
        52.42
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '991'\n  AND mk.movie_id <= '2599'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4438.05,
        4421.26,
        4378.25,
        37.95,
        4.66,
        4.65
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3283'\n  AND mk.movie_id <= '5007'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4527.04,
        4509.1,
        39.36,
        4.49,
        4.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3282'\n  AND mk.movie_id <= '4920'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4472.04,
        4454.96,
        4411.21,
        38.32,
        4.61,
        4.6
    ]
}