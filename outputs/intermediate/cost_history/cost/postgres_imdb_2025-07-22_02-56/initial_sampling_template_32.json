{
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '468'\n  AND mk.movie_id <= '1051'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2466.97,
        2460.37,
        2443.44,
        18.51,
        6.43
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '923'\n  AND mk.movie_id <= '3841'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5018.81,
        4988.99,
        4479.66,
        153.58,
        57.86
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '417'\n  AND mk.movie_id <= '2638'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4971.74,
        4948.85,
        4479.66,
        118.39,
        47.41
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1853'\n  AND mk.movie_id <= '3834'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4805.74,
        4785.24,
        43.48,
        4.19,
        4.18
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2946'\n  AND mk.movie_id <= '4493'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4361.37,
        4345.18,
        4303.69,
        36.23,
        4.74,
        4.73
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1141'\n  AND mk.movie_id <= '2037'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3247.43,
        3237.72,
        3212.82,
        22.31,
        5.84,
        5.83
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1140'\n  AND mk.movie_id <= '4453'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5049.61,
        5015.87,
        4479.66,
        177.66,
        67.64
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2909'\n  AND mk.movie_id <= '3037'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        925.96,
        923.89,
        918.58,
        10.96,
        7.69
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1148'\n  AND mk.movie_id <= '4027'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5016.29,
        4986.86,
        4479.66,
        151.72,
        57.39
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '953'\n  AND mk.movie_id <= '1818'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3174.97,
        3165.57,
        3141.44,
        21.93,
        5.89,
        5.88
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '357'\n  AND mk.movie_id <= '1067'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2788.6,
        2780.75,
        2760.58,
        20.05,
        6.18,
        6.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2025'\n  AND mk.movie_id <= '4119'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4918.62,
        4897.01,
        44.85,
        4.08,
        4.07
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '466'\n  AND mk.movie_id <= '1570'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3696.87,
        3685.09,
        3654.88,
        25.84,
        5.5,
        5.49
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1535'\n  AND mk.movie_id <= '5229'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5075.78,
        5038.24,
        4479.66,
        197.32,
        73.26
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '327'\n  AND mk.movie_id <= '928'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2520.18,
        2513.41,
        2496.03,
        18.72,
        6.4
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '940'\n  AND mk.movie_id <= '5260'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5119.4,
        5075.64,
        4479.66,
        230.26,
        82.85
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '956'\n  AND mk.movie_id <= '3844'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5016.86,
        4987.34,
        4479.66,
        152.14,
        57.5
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '965'\n  AND mk.movie_id <= '5262'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5117.88,
        5074.34,
        4479.66,
        229.12,
        82.57
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2918'\n  AND mk.movie_id <= '5263'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4979.65,
        4955.54,
        4479.66,
        124.2,
        48.9
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '937'\n  AND mk.movie_id <= '4566'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5071.48,
        5034.59,
        4479.66,
        194.12,
        72.47
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '596'\n  AND mk.movie_id <= '2638'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4865.82,
        4844.72,
        44.23,
        4.13,
        4.12
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1140'\n  AND mk.movie_id <= '1537'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1898.74,
        1893.99,
        1881.8,
        15.24,
        6.89
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1782'\n  AND mk.movie_id <= '1865'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        736.4,
        734.79,
        730.65,
        10.4,
        7.83
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '912'\n  AND mk.movie_id <= '5267'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5121.63,
        5077.53,
        4479.66,
        231.92,
        83.25
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '909'\n  AND mk.movie_id <= '5266'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5121.87,
        5077.73,
        4479.66,
        232.09,
        83.29
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '974'\n  AND mk.movie_id <= '4739'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5080.44,
        5042.2,
        4479.66,
        200.77,
        74.11
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '415'\n  AND mk.movie_id <= '977'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2407.71,
        2401.33,
        2384.94,
        17.25,
        6.49
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1062'\n  AND mk.movie_id <= '2018'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3386.29,
        3375.98,
        3349.55,
        24.04,
        5.74,
        5.73
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '965'\n  AND mk.movie_id <= '3992'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5025.94,
        4995.03,
        4479.66,
        158.84,
        59.18
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1061'\n  AND mk.movie_id <= '2800'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4543.76,
        4525.67,
        39.56,
        4.47,
        4.46
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '4209'\n  AND mk.movie_id <= '5006'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3006.57,
        2997.86,
        2975.48,
        21.09,
        6.01,
        6.0
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '978'\n  AND mk.movie_id <= '1079'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        818.14,
        816.34,
        811.7,
        10.64,
        7.78
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '86'\n  AND mk.movie_id <= '3682'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5069.27,
        5032.71,
        4479.66,
        192.49,
        72.07
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '981'\n  AND mk.movie_id <= '1041'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        641.62,
        640.24,
        636.69,
        10.12,
        7.93
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '934'\n  AND mk.movie_id <= '4730'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5082.54,
        5043.98,
        4479.66,
        202.33,
        74.5
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1040'\n  AND mk.movie_id <= '1047'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        409.98,
        409.12,
        406.92,
        9.48,
        8.11
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1076'\n  AND mk.movie_id <= '2668'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4421.1,
        4404.48,
        4361.87,
        37.76,
        4.68,
        4.67
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '926'\n  AND mk.movie_id <= '1079'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1025.26,
        1022.95,
        1017.01,
        11.26,
        7.62
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '4314'\n  AND mk.movie_id <= '4738'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1982.56,
        1977.55,
        1964.68,
        15.56,
        6.82
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '923'\n  AND mk.movie_id <= '1627'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2770.31,
        2762.52,
        2742.53,
        19.96,
        6.2,
        6.19
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '969'\n  AND mk.movie_id <= '1352'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1850.56,
        1845.96,
        1834.13,
        15.06,
        6.92
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '954'\n  AND mk.movie_id <= '4730'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5081.14,
        5042.79,
        4479.66,
        201.29,
        74.24
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3585'\n  AND mk.movie_id <= '4445'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3161.26,
        3151.91,
        3127.92,
        21.87,
        5.9,
        5.89
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '11'\n  AND mk.movie_id <= '1018'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3495.73,
        3484.92,
        3457.18,
        24.66,
        5.66,
        5.65
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '327'\n  AND mk.movie_id <= '989'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2667.41,
        2660.02,
        2641.07,
        19.47,
        6.29,
        6.28
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '930'\n  AND mk.movie_id <= '2076'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3785.44,
        3773.24,
        3741.95,
        26.35,
        5.44,
        5.43
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '651'\n  AND mk.movie_id <= '2909'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4974.11,
        4950.86,
        4479.66,
        120.13,
        47.86
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2607'\n  AND mk.movie_id <= '4734'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4949.68,
        4927.74,
        45.26,
        4.04,
        4.03
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '957'\n  AND mk.movie_id <= '4031'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5032.93,
        5001.57,
        4479.66,
        165.05,
        63.74
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '813'\n  AND mk.movie_id <= '1026'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1250.99,
        1248.08,
        1240.61,
        11.99,
        7.4
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '917'\n  AND mk.movie_id <= '4903'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5096.14,
        5055.7,
        4479.66,
        212.69,
        77.8
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '908'\n  AND mk.movie_id <= '1618'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2788.6,
        2780.75,
        2760.58,
        20.05,
        6.18,
        6.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '64'\n  AND mk.movie_id <= '991'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3316.43,
        3306.42,
        3280.75,
        23.68,
        5.79,
        5.78
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '999'\n  AND mk.movie_id <= '1856'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3152.12,
        3142.81,
        3118.9,
        21.82,
        5.91,
        5.9
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1063'\n  AND mk.movie_id <= '4152'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5033.96,
        5002.45,
        4479.66,
        165.82,
        63.93
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1087'\n  AND mk.movie_id <= '1594'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2239.03,
        2233.2,
        2218.25,
        16.56,
        6.61
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '945'\n  AND mk.movie_id <= '3864'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5018.81,
        4988.99,
        4479.66,
        153.58,
        57.86
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1085'\n  AND mk.movie_id <= '1187'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        818.14,
        816.34,
        811.7,
        10.64,
        7.78
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '284'\n  AND mk.movie_id <= '946'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2667.41,
        2660.02,
        2641.07,
        19.47,
        6.29,
        6.28
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '964'\n  AND mk.movie_id <= '1068'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        826.66,
        824.84,
        820.16,
        10.66,
        7.78
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '987'\n  AND mk.movie_id <= '3191'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4970.62,
        4947.9,
        4479.66,
        117.56,
        47.19
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1051'\n  AND mk.movie_id <= '5192'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5106.44,
        5064.46,
        4479.66,
        220.35,
        79.67
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '983'\n  AND mk.movie_id <= '1551'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2421.28,
        2414.84,
        2398.31,
        17.31,
        6.47
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3863'\n  AND mk.movie_id <= '4948'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3659.93,
        3648.34,
        3618.62,
        25.6,
        5.53,
        5.52
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '419'\n  AND mk.movie_id <= '1782'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4125.58,
        4111.23,
        4074.43,
        29.98,
        5.05,
        5.04
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1006'\n  AND mk.movie_id <= '2786'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4588.76,
        4570.26,
        40.05,
        4.42,
        4.41
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1015'\n  AND mk.movie_id <= '1565'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2372.06,
        2365.8,
        2349.72,
        17.1,
        6.52
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '591'\n  AND mk.movie_id <= '2972'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4982.03,
        4957.55,
        4479.66,
        125.95,
        49.35
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '85'\n  AND mk.movie_id <= '942'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3152.12,
        3142.81,
        3118.9,
        21.82,
        5.91,
        5.9
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1852'\n  AND mk.movie_id <= '2600'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2884.62,
        2876.39,
        2855.28,
        20.5,
        6.11,
        6.1
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '388'\n  AND mk.movie_id <= '5229'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5160.29,
        5111.34,
        4479.66,
        262.26,
        95.14
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '902'\n  AND mk.movie_id <= '983'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        731.88,
        730.29,
        726.19,
        10.38,
        7.87
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2854'\n  AND mk.movie_id <= '5192'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4979.2,
        4955.16,
        4479.66,
        123.87,
        48.82
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1759'\n  AND mk.movie_id <= '2304'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2358.5,
        2352.29,
        2336.35,
        17.03,
        6.53
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '723'\n  AND mk.movie_id <= '1561'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3110.34,
        3101.2,
        3077.75,
        21.61,
        5.94,
        5.93
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '647'\n  AND mk.movie_id <= '4828'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5110.13,
        5067.75,
        4479.66,
        223.36,
        81.16
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '389'\n  AND mk.movie_id <= '4948'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5136.28,
        5090.15,
        4479.66,
        243.09,
        86.72
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '934'\n  AND mk.movie_id <= '1396'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2102.03,
        2096.64,
        2082.78,
        16.03,
        6.71
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1554'\n  AND mk.movie_id <= '2304'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2893.76,
        2885.5,
        2864.29,
        20.54,
        6.1,
        6.09
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1042'\n  AND mk.movie_id <= '4220'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5040.84,
        5008.43,
        4479.66,
        171.16,
        66.02
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '936'\n  AND mk.movie_id <= '3282'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4979.77,
        4955.64,
        4479.66,
        124.28,
        48.92
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2280'\n  AND mk.movie_id <= '5192'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5018.36,
        4988.61,
        4479.66,
        153.24,
        57.77
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1006'\n  AND mk.movie_id <= '3281'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4975.13,
        4951.72,
        4479.66,
        120.88,
        48.05
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '964'\n  AND mk.movie_id <= '1858'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3238.33,
        3228.65,
        3203.8,
        22.27,
        5.84,
        5.83
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '651'\n  AND mk.movie_id <= '4030'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5054.01,
        5019.6,
        4479.66,
        180.91,
        68.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2608'\n  AND mk.movie_id <= '3191'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2466.97,
        2460.37,
        2443.44,
        18.51,
        6.43
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '11'\n  AND mk.movie_id <= '4035'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5098.6,
        5057.79,
        4479.66,
        214.52,
        78.25
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '582'\n  AND mk.movie_id <= '4125'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5065.79,
        5029.75,
        4479.66,
        189.9,
        71.43
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '969'\n  AND mk.movie_id <= '3679'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5004.31,
        4976.55,
        4479.66,
        142.61,
        54.34
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2037'\n  AND mk.movie_id <= '4659'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4998.6,
        4971.72,
        4479.66,
        138.41,
        53.28
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '972'\n  AND mk.movie_id <= '2920'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4766.93,
        4746.77,
        43.08,
        4.23,
        4.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '992'\n  AND mk.movie_id <= '4706'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5077.06,
        5039.33,
        4479.66,
        198.27,
        73.5
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '679'\n  AND mk.movie_id <= '1863'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3856.42,
        3843.85,
        3811.65,
        26.8,
        5.38,
        5.37
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '4496'\n  AND mk.movie_id <= '5022'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2300.76,
        2294.74,
        2279.3,
        16.8,
        6.58
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '947'\n  AND mk.movie_id <= '3849'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5017.78,
        4988.12,
        4479.66,
        152.82,
        57.67
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2931'\n  AND mk.movie_id <= '5009'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4897.44,
        4875.99,
        44.66,
        4.09,
        4.08
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '887'\n  AND mk.movie_id <= '4037'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5037.99,
        5005.86,
        4479.66,
        168.8,
        64.68
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1864'\n  AND mk.movie_id <= '3283'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4199.29,
        4184.38,
        4146.18,
        30.67,
        4.95,
        4.94
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '587'\n  AND mk.movie_id <= '1069'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2167.76,
        2162.18,
        2147.83,
        16.26,
        6.68
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '912'\n  AND mk.movie_id <= '3342'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4985.09,
        4960.14,
        4479.66,
        128.2,
        49.93
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1023'\n  AND mk.movie_id <= '3342'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4977.96,
        4954.11,
        4479.66,
        122.95,
        48.58
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2872'\n  AND mk.movie_id <= '4802'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4749.33,
        4729.35,
        42.86,
        4.24,
        4.23
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '813'\n  AND mk.movie_id <= '1025'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1250.99,
        1248.08,
        1240.61,
        11.99,
        7.4
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '50'\n  AND mk.movie_id <= '1400'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4109.2,
        4094.98,
        4058.5,
        29.83,
        5.08,
        5.07
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '3851'\n  AND mk.movie_id <= '5007'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3804.38,
        3792.09,
        3760.57,
        26.46,
        5.43,
        5.42
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '4496'\n  AND mk.movie_id <= '5259'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2923.63,
        2915.25,
        2893.73,
        20.69,
        6.08,
        6.07
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2914'\n  AND mk.movie_id <= '4903'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4812.48,
        4791.9,
        43.59,
        4.18,
        4.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1069'\n  AND mk.movie_id <= '1832'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2923.63,
        2915.25,
        2893.73,
        20.69,
        6.08,
        6.07
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '930'\n  AND mk.movie_id <= '960'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        516.76,
        515.67,
        512.88,
        9.76,
        8.11
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1335'\n  AND mk.movie_id <= '3037'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4504.58,
        4486.85,
        39.11,
        4.52,
        4.51
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1057'\n  AND mk.movie_id <= '1855'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3015.08,
        3006.35,
        2983.93,
        21.12,
        6.02,
        6.01
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '907'\n  AND mk.movie_id <= '1089'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1142.12,
        1139.52,
        1132.81,
        11.62,
        7.52
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1859'\n  AND mk.movie_id <= '4665'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5010.48,
        4981.78,
        4479.66,
        147.17,
        55.49
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '418'\n  AND mk.movie_id <= '4006'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5068.8,
        5032.32,
        4479.66,
        192.14,
        71.98
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2929'\n  AND mk.movie_id <= '4440'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4317.01,
        4301.19,
        4260.65,
        35.78,
        4.8,
        4.79
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '683'\n  AND mk.movie_id <= '4288'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5069.85,
        5033.21,
        4479.66,
        192.92,
        72.18
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1636'\n  AND mk.movie_id <= '1636'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        379.9,
        379.11,
        377.08,
        9.4,
        8.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1535'\n  AND mk.movie_id <= '4314'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5008.77,
        4980.33,
        4479.66,
        145.9,
        55.17
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1864'\n  AND mk.movie_id <= '4737'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5015.83,
        4986.47,
        4479.66,
        151.38,
        57.31
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1031'\n  AND mk.movie_id <= '1149'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        882.83,
        880.87,
        875.83,
        10.83,
        7.72
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '919'\n  AND mk.movie_id <= '1012'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        783.53,
        781.82,
        777.41,
        10.53,
        7.83
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '591'\n  AND mk.movie_id <= '2685'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4918.62,
        4897.01,
        44.85,
        4.08,
        4.07
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1082'\n  AND mk.movie_id <= '2281'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3893.63,
        3880.9,
        3848.29,
        26.99,
        5.37,
        5.36
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '467'\n  AND mk.movie_id <= '1031'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2412.24,
        2405.83,
        2389.4,
        17.27,
        6.48
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1600'\n  AND mk.movie_id <= '4426'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5011.74,
        4982.85,
        4479.66,
        148.1,
        55.73
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '918'\n  AND mk.movie_id <= '1030'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        865.27,
        863.36,
        858.45,
        10.77,
        7.78
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1076'\n  AND mk.movie_id <= '1565'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2189.81,
        2184.16,
        2169.66,
        16.35,
        6.67
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '826'\n  AND mk.movie_id <= '1020'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1185.77,
        1183.04,
        1176.02,
        11.77,
        7.46
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1074'\n  AND mk.movie_id <= '4700'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5071.25,
        5034.39,
        4479.66,
        193.95,
        72.43
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '82'\n  AND mk.movie_id <= '912'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3087.47,
        3078.43,
        3055.2,
        21.5,
        5.96,
        5.95
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1058'\n  AND mk.movie_id <= '4482'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5056.9,
        5022.06,
        4479.66,
        183.06,
        68.98
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1041'\n  AND mk.movie_id <= '4027'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5023.18,
        4992.69,
        4479.66,
        156.8,
        58.67
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2920'\n  AND mk.movie_id <= '3680'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2920.55,
        2912.2,
        2890.77,
        20.65,
        6.09,
        6.08
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1333'\n  AND mk.movie_id <= '3845'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4990.43,
        4964.65,
        4479.66,
        132.13,
        50.93
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '587'\n  AND mk.movie_id <= '1018'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2004.64,
        1999.57,
        1986.52,
        15.64,
        6.8
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '114'\n  AND mk.movie_id <= '2599'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4988.73,
        4963.21,
        4479.66,
        130.87,
        50.61
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1012'\n  AND mk.movie_id <= '2071'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        3603.13,
        3591.8,
        3562.76,
        25.28,
        5.57,
        5.56
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1015'\n  AND mk.movie_id <= '1549'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2323.37,
        2317.26,
        2301.59,
        16.91,
        6.55
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '106'\n  AND mk.movie_id <= '284'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1116.56,
        1114.0,
        1107.43,
        11.56,
        7.51
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '44'\n  AND mk.movie_id <= '2834'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5009.45,
        4980.91,
        4479.66,
        146.41,
        55.3
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '334'\n  AND mk.movie_id <= '3282'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5020.77,
        4990.65,
        4479.66,
        155.02,
        58.22
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '593'\n  AND mk.movie_id <= '1072'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2159.24,
        2153.68,
        2139.37,
        16.24,
        6.68
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '951'\n  AND mk.movie_id <= '4566'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5070.55,
        5033.8,
        4479.66,
        193.43,
        72.3
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1061'\n  AND mk.movie_id <= '5006'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        5093.34,
        5053.31,
        4479.66,
        210.61,
        77.29
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '591'\n  AND mk.movie_id <= '1047'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2083.94,
        2078.62,
        2064.94,
        15.94,
        6.74
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '945'\n  AND mk.movie_id <= '1002'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        633.1,
        631.74,
        628.23,
        10.1,
        7.92
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '919'\n  AND mk.movie_id <= '1677'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        2912.04,
        2903.71,
        2882.33,
        20.62,
        6.09,
        6.08
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '1033'\n  AND mk.movie_id <= '2872'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        4650.76,
        4631.69,
        40.75,
        4.35,
        4.34
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '980'\n  AND mk.movie_id <= '1179'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        1198.82,
        1196.05,
        1188.94,
        11.82,
        7.45
    ],
    "-- Refined SQL Template Metadata\n-- Refinement Time: 2025-07-22 03:04:46\n-- Operation: both\n-- Old Join Path: keyword\n-- New Join Path: movie_keyword JOIN keyword\n-- Table Size Changes: Changed from using the small 'keyword' table (10 MB, 134K rows) to joining with 'movie_keyword' (360 MB, 4.5M rows) to increase the cost.\n-- Structural Changes: Replaced single-table access with a join; modified the predicates to filter on movie_keyword.movie_id with two placeholder values; added an aggregation using COUNT(*).\n-- LLM Reasoning: To push the cost into the [5000.0, 6000.0] range, I increased the complexity by joining a larger table ('movie_keyword') with 'keyword'. This join, together with aggregation and filtering on a high-cardinality column, increases the amount of data processed and thus the execution cost.\n\n-- SQL Template Metadata\n-- Template ID: 12\n-- Creation Time: 2025-07-22 02:58:48\n-- LLM Model: o3-mini\n-- Constraints:\n--   Number of unique Tables Accessed: 2\n--   Number of Joins: 1\n--   Number of Aggregations: 1\n--   Semantic Requirement: The query should use group-by, and have at least two predicate values to fill.\n--   Tables Involved: ['movie_keyword', 'keyword']\n-- Rewrite Attempts Number for Constraints Check: 1\n-- Rewrite Attempts Number for Grammar Check: 1\n\nSELECT mk.movie_id,\n       k.keyword,\n       COUNT(*) AS occurrence\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mk.movie_id >= '2'\n  AND mk.movie_id <= '2'\nGROUP BY mk.movie_id,\n         k.keyword;": [
        379.9,
        379.11,
        377.08,
        9.4,
        8.17
    ]
}